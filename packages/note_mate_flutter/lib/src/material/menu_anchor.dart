// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/material/menu_anchor.dart';
import 'package:note/mate.dart';
import 'package:flutter/src/foundation/key.dart';
import 'package:flutter/src/widgets/focus_manager.dart';
import 'package:flutter/src/material/menu_style.dart';
import 'dart:ui';
import 'dart:core';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/foundation/basic_types.dart';
import 'package:flutter/src/widgets/platform_menu_bar.dart';
import 'package:flutter/src/material/button_style.dart';
import 'package:flutter/src/material/material_state.dart';

/// class MenuAnchor extends StatefulWidget
class MenuAnchor$Mate extends MenuAnchor with Mate {
  /// MenuAnchor MenuAnchor({Key? key, MenuController? controller, FocusNode? childFocusNode, MenuStyle? style, Offset? alignmentOffset = Offset.zero, Clip clipBehavior = Clip.none, bool anchorTapClosesMenu = false, void Function()? onOpen, void Function()? onClose, bool crossAxisUnconstrained = true, required List<Widget> menuChildren, Widget Function(BuildContext, MenuController, Widget?)? builder, Widget? child})
  MenuAnchor$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {MenuController? controller} , defaultValue:none
    MenuController? controller,

    /// optionalParameters: {FocusNode? childFocusNode} , defaultValue:none
    FocusNode? childFocusNode,

    /// optionalParameters: {MenuStyle? style} , defaultValue:none
    MenuStyle? style,

    /// optionalParameters: {Offset? alignmentOffset = Offset.zero} , defaultValue:unprocessed
    Offset? alignmentOffset,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {bool anchorTapClosesMenu = false} , defaultValue:Literal
    bool anchorTapClosesMenu = false,

    /// optionalParameters: {void Function()? onOpen} , defaultValue:none
    VoidCallback? onOpen,

    /// optionalParameters: {void Function()? onClose} , defaultValue:none
    VoidCallback? onClose,

    /// optionalParameters: {bool crossAxisUnconstrained = true} , defaultValue:Literal
    bool crossAxisUnconstrained = true,

    /// optionalParameters: {required List<Widget> menuChildren} , defaultValue:none
    required List<Widget> menuChildren,

    /// optionalParameters: {Widget Function(BuildContext, MenuController, Widget?)? builder} , defaultValue:none
    MenuAnchorChildBuilder? builder,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          controller: controller,
          childFocusNode: childFocusNode,
          style: style,
          alignmentOffset: alignmentOffset,
          clipBehavior: clipBehavior,
          anchorTapClosesMenu: anchorTapClosesMenu,
          onOpen: onOpen,
          onClose: onClose,
          crossAxisUnconstrained: crossAxisUnconstrained,
          menuChildren: menuChildren,
          builder: builder,
          child: child,
        ) {
    mateBuilder = (p) => MenuAnchor$Mate(
          key: p.get('key').build(),
          controller: p.get('controller').build(),
          childFocusNode: p.get('childFocusNode').build(),
          style: p.get('style').build(),
          alignmentOffset: p.get('alignmentOffset').build(),
          clipBehavior: p.get('clipBehavior').build(),
          anchorTapClosesMenu: p.get('anchorTapClosesMenu').build(),
          onOpen: p.get('onOpen').build(),
          onClose: p.get('onClose').build(),
          crossAxisUnconstrained: p.get('crossAxisUnconstrained').build(),
          menuChildren: p.get('menuChildren').build(),
          builder: p.get('builder').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('controller', controller);
    mateDeclare('childFocusNode', childFocusNode);
    mateDeclare('style', style);
    mateDeclare('alignmentOffset', alignmentOffset);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('anchorTapClosesMenu', anchorTapClosesMenu);
    mateDeclare('onOpen', onOpen);
    mateDeclare('onClose', onClose);
    mateDeclare('crossAxisUnconstrained', crossAxisUnconstrained);
    mateDeclare('menuChildren', menuChildren);
    mateDeclare('builder', builder);
    mateDeclare('child', child);
  }
}

/// class MenuBar extends StatelessWidget
class MenuBar$Mate extends MenuBar with Mate {
  /// MenuBar MenuBar({Key? key, MenuStyle? style, Clip clipBehavior = Clip.none, MenuController? controller, required List<Widget> children})
  MenuBar$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {MenuStyle? style} , defaultValue:none
    MenuStyle? style,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {MenuController? controller} , defaultValue:none
    MenuController? controller,

    /// optionalParameters: {required List<Widget> children} , defaultValue:none
    required List<Widget> children,
  }) : super(
          key: key,
          style: style,
          clipBehavior: clipBehavior,
          controller: controller,
          children: children,
        ) {
    mateBuilder = (p) => MenuBar$Mate(
          key: p.get('key').build(),
          style: p.get('style').build(),
          clipBehavior: p.get('clipBehavior').build(),
          controller: p.get('controller').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('style', style);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('controller', controller);
    mateDeclare('children', children);
  }
}

/// class MenuItemButton extends StatefulWidget
class MenuItemButton$Mate extends MenuItemButton with Mate {
  /// MenuItemButton MenuItemButton({Key? key, void Function()? onPressed, void Function(bool)? onHover, bool requestFocusOnHover = true, void Function(bool)? onFocusChange, FocusNode? focusNode, MenuSerializableShortcut? shortcut, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? leadingIcon, Widget? trailingIcon, required Widget? child})
  MenuItemButton$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {void Function()? onPressed} , defaultValue:none
    VoidCallback? onPressed,

    /// optionalParameters: {void Function(bool)? onHover} , defaultValue:none
    ValueChanged<bool>? onHover,

    /// optionalParameters: {bool requestFocusOnHover = true} , defaultValue:Literal
    bool requestFocusOnHover = true,

    /// optionalParameters: {void Function(bool)? onFocusChange} , defaultValue:none
    ValueChanged<bool>? onFocusChange,

    /// optionalParameters: {FocusNode? focusNode} , defaultValue:none
    FocusNode? focusNode,

    /// optionalParameters: {MenuSerializableShortcut? shortcut} , defaultValue:none
    MenuSerializableShortcut? shortcut,

    /// optionalParameters: {ButtonStyle? style} , defaultValue:none
    ButtonStyle? style,

    /// optionalParameters: {MaterialStatesController? statesController} , defaultValue:none
    MaterialStatesController? statesController,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? leadingIcon} , defaultValue:none
    Widget? leadingIcon,

    /// optionalParameters: {Widget? trailingIcon} , defaultValue:none
    Widget? trailingIcon,

    /// optionalParameters: {required Widget? child} , defaultValue:none
    required Widget? child,
  }) : super(
          key: key,
          onPressed: onPressed,
          onHover: onHover,
          requestFocusOnHover: requestFocusOnHover,
          onFocusChange: onFocusChange,
          focusNode: focusNode,
          shortcut: shortcut,
          style: style,
          statesController: statesController,
          clipBehavior: clipBehavior,
          leadingIcon: leadingIcon,
          trailingIcon: trailingIcon,
          child: child,
        ) {
    mateBuilder = (p) => MenuItemButton$Mate(
          key: p.get('key').build(),
          onPressed: p.get('onPressed').build(),
          onHover: p.get('onHover').build(),
          requestFocusOnHover: p.get('requestFocusOnHover').build(),
          onFocusChange: p.get('onFocusChange').build(),
          focusNode: p.get('focusNode').build(),
          shortcut: p.get('shortcut').build(),
          style: p.get('style').build(),
          statesController: p.get('statesController').build(),
          clipBehavior: p.get('clipBehavior').build(),
          leadingIcon: p.get('leadingIcon').build(),
          trailingIcon: p.get('trailingIcon').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('onPressed', onPressed);
    mateDeclare('onHover', onHover);
    mateDeclare('requestFocusOnHover', requestFocusOnHover);
    mateDeclare('onFocusChange', onFocusChange);
    mateDeclare('focusNode', focusNode);
    mateDeclare('shortcut', shortcut);
    mateDeclare('style', style);
    mateDeclare('statesController', statesController);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('leadingIcon', leadingIcon);
    mateDeclare('trailingIcon', trailingIcon);
    mateDeclare('child', child);
  }
}

/// class CheckboxMenuButton extends StatelessWidget
class CheckboxMenuButton$Mate extends CheckboxMenuButton with Mate {
  /// CheckboxMenuButton CheckboxMenuButton({Key? key, required bool? value, bool tristate = false, bool isError = false, required void Function(bool?)? onChanged, void Function(bool)? onHover, void Function(bool)? onFocusChange, FocusNode? focusNode, MenuSerializableShortcut? shortcut, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? trailingIcon, required Widget? child})
  CheckboxMenuButton$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required bool? value} , defaultValue:none
    required bool? value,

    /// optionalParameters: {bool tristate = false} , defaultValue:Literal
    bool tristate = false,

    /// optionalParameters: {bool isError = false} , defaultValue:Literal
    bool isError = false,

    /// optionalParameters: {required void Function(bool?)? onChanged} , defaultValue:none
    required ValueChanged<bool?>? onChanged,

    /// optionalParameters: {void Function(bool)? onHover} , defaultValue:none
    ValueChanged<bool>? onHover,

    /// optionalParameters: {void Function(bool)? onFocusChange} , defaultValue:none
    ValueChanged<bool>? onFocusChange,

    /// optionalParameters: {FocusNode? focusNode} , defaultValue:none
    FocusNode? focusNode,

    /// optionalParameters: {MenuSerializableShortcut? shortcut} , defaultValue:none
    MenuSerializableShortcut? shortcut,

    /// optionalParameters: {ButtonStyle? style} , defaultValue:none
    ButtonStyle? style,

    /// optionalParameters: {MaterialStatesController? statesController} , defaultValue:none
    MaterialStatesController? statesController,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? trailingIcon} , defaultValue:none
    Widget? trailingIcon,

    /// optionalParameters: {required Widget? child} , defaultValue:none
    required Widget? child,
  }) : super(
          key: key,
          value: value,
          tristate: tristate,
          isError: isError,
          onChanged: onChanged,
          onHover: onHover,
          onFocusChange: onFocusChange,
          focusNode: focusNode,
          shortcut: shortcut,
          style: style,
          statesController: statesController,
          clipBehavior: clipBehavior,
          trailingIcon: trailingIcon,
          child: child,
        ) {
    mateBuilder = (p) => CheckboxMenuButton$Mate(
          key: p.get('key').build(),
          value: p.get('value').build(),
          tristate: p.get('tristate').build(),
          isError: p.get('isError').build(),
          onChanged: p.get('onChanged').build(),
          onHover: p.get('onHover').build(),
          onFocusChange: p.get('onFocusChange').build(),
          focusNode: p.get('focusNode').build(),
          shortcut: p.get('shortcut').build(),
          style: p.get('style').build(),
          statesController: p.get('statesController').build(),
          clipBehavior: p.get('clipBehavior').build(),
          trailingIcon: p.get('trailingIcon').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('value', value);
    mateDeclare('tristate', tristate);
    mateDeclare('isError', isError);
    mateDeclare('onChanged', onChanged);
    mateDeclare('onHover', onHover);
    mateDeclare('onFocusChange', onFocusChange);
    mateDeclare('focusNode', focusNode);
    mateDeclare('shortcut', shortcut);
    mateDeclare('style', style);
    mateDeclare('statesController', statesController);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('trailingIcon', trailingIcon);
    mateDeclare('child', child);
  }
}

/// class RadioMenuButton<T> extends StatelessWidget
class RadioMenuButton$Mate<T> extends RadioMenuButton<T> with Mate {
  /// RadioMenuButton<T> RadioMenuButton({Key? key, required T value, required T? groupValue, required void Function(T?)? onChanged, bool toggleable = false, void Function(bool)? onHover, void Function(bool)? onFocusChange, FocusNode? focusNode, MenuSerializableShortcut? shortcut, ButtonStyle? style, MaterialStatesController? statesController, Clip clipBehavior = Clip.none, Widget? trailingIcon, required Widget? child})
  RadioMenuButton$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required T value} , defaultValue:none
    required T value,

    /// optionalParameters: {required T? groupValue} , defaultValue:none
    required T? groupValue,

    /// optionalParameters: {required void Function(T?)? onChanged} , defaultValue:none
    required ValueChanged<T?>? onChanged,

    /// optionalParameters: {bool toggleable = false} , defaultValue:Literal
    bool toggleable = false,

    /// optionalParameters: {void Function(bool)? onHover} , defaultValue:none
    ValueChanged<bool>? onHover,

    /// optionalParameters: {void Function(bool)? onFocusChange} , defaultValue:none
    ValueChanged<bool>? onFocusChange,

    /// optionalParameters: {FocusNode? focusNode} , defaultValue:none
    FocusNode? focusNode,

    /// optionalParameters: {MenuSerializableShortcut? shortcut} , defaultValue:none
    MenuSerializableShortcut? shortcut,

    /// optionalParameters: {ButtonStyle? style} , defaultValue:none
    ButtonStyle? style,

    /// optionalParameters: {MaterialStatesController? statesController} , defaultValue:none
    MaterialStatesController? statesController,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? trailingIcon} , defaultValue:none
    Widget? trailingIcon,

    /// optionalParameters: {required Widget? child} , defaultValue:none
    required Widget? child,
  }) : super(
          key: key,
          value: value,
          groupValue: groupValue,
          onChanged: onChanged,
          toggleable: toggleable,
          onHover: onHover,
          onFocusChange: onFocusChange,
          focusNode: focusNode,
          shortcut: shortcut,
          style: style,
          statesController: statesController,
          clipBehavior: clipBehavior,
          trailingIcon: trailingIcon,
          child: child,
        ) {
    mateBuilder = (p) => RadioMenuButton$Mate<T>(
          key: p.get('key').build(),
          value: p.get('value').build(),
          groupValue: p.get('groupValue').build(),
          onChanged: p.get('onChanged').build(),
          toggleable: p.get('toggleable').build(),
          onHover: p.get('onHover').build(),
          onFocusChange: p.get('onFocusChange').build(),
          focusNode: p.get('focusNode').build(),
          shortcut: p.get('shortcut').build(),
          style: p.get('style').build(),
          statesController: p.get('statesController').build(),
          clipBehavior: p.get('clipBehavior').build(),
          trailingIcon: p.get('trailingIcon').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('value', value);
    mateDeclare('groupValue', groupValue);
    mateDeclare('onChanged', onChanged);
    mateDeclare('toggleable', toggleable);
    mateDeclare('onHover', onHover);
    mateDeclare('onFocusChange', onFocusChange);
    mateDeclare('focusNode', focusNode);
    mateDeclare('shortcut', shortcut);
    mateDeclare('style', style);
    mateDeclare('statesController', statesController);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('trailingIcon', trailingIcon);
    mateDeclare('child', child);
  }
}

/// class SubmenuButton extends StatefulWidget
class SubmenuButton$Mate extends SubmenuButton with Mate {
  /// SubmenuButton SubmenuButton({Key? key, void Function(bool)? onHover, void Function(bool)? onFocusChange, void Function()? onOpen, void Function()? onClose, ButtonStyle? style, MenuStyle? menuStyle, Offset? alignmentOffset, Clip clipBehavior = Clip.none, FocusNode? focusNode, MaterialStatesController? statesController, Widget? leadingIcon, Widget? trailingIcon, required List<Widget> menuChildren, required Widget? child})
  SubmenuButton$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {void Function(bool)? onHover} , defaultValue:none
    ValueChanged<bool>? onHover,

    /// optionalParameters: {void Function(bool)? onFocusChange} , defaultValue:none
    ValueChanged<bool>? onFocusChange,

    /// optionalParameters: {void Function()? onOpen} , defaultValue:none
    VoidCallback? onOpen,

    /// optionalParameters: {void Function()? onClose} , defaultValue:none
    VoidCallback? onClose,

    /// optionalParameters: {ButtonStyle? style} , defaultValue:none
    ButtonStyle? style,

    /// optionalParameters: {MenuStyle? menuStyle} , defaultValue:none
    MenuStyle? menuStyle,

    /// optionalParameters: {Offset? alignmentOffset} , defaultValue:none
    Offset? alignmentOffset,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {FocusNode? focusNode} , defaultValue:none
    FocusNode? focusNode,

    /// optionalParameters: {MaterialStatesController? statesController} , defaultValue:none
    MaterialStatesController? statesController,

    /// optionalParameters: {Widget? leadingIcon} , defaultValue:none
    Widget? leadingIcon,

    /// optionalParameters: {Widget? trailingIcon} , defaultValue:none
    Widget? trailingIcon,

    /// optionalParameters: {required List<Widget> menuChildren} , defaultValue:none
    required List<Widget> menuChildren,

    /// optionalParameters: {required Widget? child} , defaultValue:none
    required Widget? child,
  }) : super(
          key: key,
          onHover: onHover,
          onFocusChange: onFocusChange,
          onOpen: onOpen,
          onClose: onClose,
          style: style,
          menuStyle: menuStyle,
          alignmentOffset: alignmentOffset,
          clipBehavior: clipBehavior,
          focusNode: focusNode,
          statesController: statesController,
          leadingIcon: leadingIcon,
          trailingIcon: trailingIcon,
          menuChildren: menuChildren,
          child: child,
        ) {
    mateBuilder = (p) => SubmenuButton$Mate(
          key: p.get('key').build(),
          onHover: p.get('onHover').build(),
          onFocusChange: p.get('onFocusChange').build(),
          onOpen: p.get('onOpen').build(),
          onClose: p.get('onClose').build(),
          style: p.get('style').build(),
          menuStyle: p.get('menuStyle').build(),
          alignmentOffset: p.get('alignmentOffset').build(),
          clipBehavior: p.get('clipBehavior').build(),
          focusNode: p.get('focusNode').build(),
          statesController: p.get('statesController').build(),
          leadingIcon: p.get('leadingIcon').build(),
          trailingIcon: p.get('trailingIcon').build(),
          menuChildren: p.get('menuChildren').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('onHover', onHover);
    mateDeclare('onFocusChange', onFocusChange);
    mateDeclare('onOpen', onOpen);
    mateDeclare('onClose', onClose);
    mateDeclare('style', style);
    mateDeclare('menuStyle', menuStyle);
    mateDeclare('alignmentOffset', alignmentOffset);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('focusNode', focusNode);
    mateDeclare('statesController', statesController);
    mateDeclare('leadingIcon', leadingIcon);
    mateDeclare('trailingIcon', trailingIcon);
    mateDeclare('menuChildren', menuChildren);
    mateDeclare('child', child);
  }
}

/// class DismissMenuAction extends DismissAction
class DismissMenuAction$Mate extends DismissMenuAction with Mate {
  /// DismissMenuAction DismissMenuAction({required MenuController controller})
  DismissMenuAction$Mate(
      {
      /// optionalParameters: {required MenuController controller} , defaultValue:none
      required MenuController controller})
      : super(controller: controller) {
    mateBuilder = (p) => DismissMenuAction$Mate(controller: p.get('controller').build());
    mateDeclare('controller', controller);
  }
}

/// class MenuAcceleratorCallbackBinding extends InheritedWidget
class MenuAcceleratorCallbackBinding$Mate extends MenuAcceleratorCallbackBinding with Mate {
  /// MenuAcceleratorCallbackBinding MenuAcceleratorCallbackBinding({Key? key, void Function()? onInvoke, bool hasSubmenu = false, required Widget child})
  MenuAcceleratorCallbackBinding$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {void Function()? onInvoke} , defaultValue:none
    VoidCallback? onInvoke,

    /// optionalParameters: {bool hasSubmenu = false} , defaultValue:Literal
    bool hasSubmenu = false,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          onInvoke: onInvoke,
          hasSubmenu: hasSubmenu,
          child: child,
        ) {
    mateBuilder = (p) => MenuAcceleratorCallbackBinding$Mate(
          key: p.get('key').build(),
          onInvoke: p.get('onInvoke').build(),
          hasSubmenu: p.get('hasSubmenu').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('onInvoke', onInvoke);
    mateDeclare('hasSubmenu', hasSubmenu);
    mateDeclare('child', child);
  }
}

/// class MenuAcceleratorLabel extends StatefulWidget
class MenuAcceleratorLabel$Mate extends MenuAcceleratorLabel with Mate {
  /// MenuAcceleratorLabel MenuAcceleratorLabel(String label, {Key? key, Widget Function(BuildContext, String, int) builder = defaultLabelBuilder})
  MenuAcceleratorLabel$Mate(
    /// requiredParameters: String label
    String label, {
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget Function(BuildContext, String, int) builder = defaultLabelBuilder} , defaultValue:unprocessed
    required MenuAcceleratorChildBuilder builder,
  }) : super(
          label,
          key: key,
          builder: builder,
        ) {
    mateBuilder = (p) => MenuAcceleratorLabel$Mate(
          p.get('label').value,
          key: p.get('key').build(),
          builder: p.get('builder').build(),
        );
    mateDeclare('label', label);
    mateDeclare('key', key);
    mateDeclare('builder', builder);
  }
}
