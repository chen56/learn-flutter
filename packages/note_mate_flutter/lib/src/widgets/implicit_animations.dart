// /// Generated by gen_maters.dart, please don't edit! 

import 'package:flutter/src/widgets/implicit_animations.dart';import 'package:flutter/src/rendering/box.dart';import 'package:flutter/src/painting/decoration.dart';import 'package:flutter/src/painting/edge_insets.dart';import 'package:flutter/src/painting/border_radius.dart';import 'package:flutter/src/painting/box_border.dart';import 'package:vector_math/vector_math_64.dart';import 'package:flutter/src/painting/text_style.dart';import 'package:flutter/src/foundation/key.dart';import 'package:flutter/src/painting/alignment.dart';import 'dart:ui';import 'dart:core';import 'package:flutter/src/widgets/framework.dart';import 'package:flutter/src/animation/curves.dart';import 'package:flutter/src/painting/text_painter.dart';import 'package:note/mate.dart' show Mate;/// class BoxConstraintsTween extends Tween<BoxConstraints>
class BoxConstraintsTween$Mate extends BoxConstraintsTween with Mate {/// BoxConstraintsTween BoxConstraintsTween({BoxConstraints? begin, BoxConstraints? end})
BoxConstraintsTween$Mate({/// optionalParameters: {BoxConstraints? begin} , hasDefaultValue:false, defaultValueCode:null
BoxConstraints? begin, /// optionalParameters: {BoxConstraints? end} , hasDefaultValue:false, defaultValueCode:null
BoxConstraints? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => BoxConstraintsTween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class DecorationTween extends Tween<Decoration>
class DecorationTween$Mate extends DecorationTween with Mate {/// DecorationTween DecorationTween({Decoration? begin, Decoration? end})
DecorationTween$Mate({/// optionalParameters: {Decoration? begin} , hasDefaultValue:false, defaultValueCode:null
Decoration? begin, /// optionalParameters: {Decoration? end} , hasDefaultValue:false, defaultValueCode:null
Decoration? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => DecorationTween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class EdgeInsetsTween extends Tween<EdgeInsets>
class EdgeInsetsTween$Mate extends EdgeInsetsTween with Mate {/// EdgeInsetsTween EdgeInsetsTween({EdgeInsets? begin, EdgeInsets? end})
EdgeInsetsTween$Mate({/// optionalParameters: {EdgeInsets? begin} , hasDefaultValue:false, defaultValueCode:null
EdgeInsets? begin, /// optionalParameters: {EdgeInsets? end} , hasDefaultValue:false, defaultValueCode:null
EdgeInsets? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => EdgeInsetsTween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class EdgeInsetsGeometryTween extends Tween<EdgeInsetsGeometry>
class EdgeInsetsGeometryTween$Mate extends EdgeInsetsGeometryTween with Mate {/// EdgeInsetsGeometryTween EdgeInsetsGeometryTween({EdgeInsetsGeometry? begin, EdgeInsetsGeometry? end})
EdgeInsetsGeometryTween$Mate({/// optionalParameters: {EdgeInsetsGeometry? begin} , hasDefaultValue:false, defaultValueCode:null
EdgeInsetsGeometry? begin, /// optionalParameters: {EdgeInsetsGeometry? end} , hasDefaultValue:false, defaultValueCode:null
EdgeInsetsGeometry? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => EdgeInsetsGeometryTween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class BorderRadiusTween extends Tween<BorderRadius?>
class BorderRadiusTween$Mate extends BorderRadiusTween with Mate {/// BorderRadiusTween BorderRadiusTween({BorderRadius? begin, BorderRadius? end})
BorderRadiusTween$Mate({/// optionalParameters: {BorderRadius? begin} , hasDefaultValue:false, defaultValueCode:null
BorderRadius? begin, /// optionalParameters: {BorderRadius? end} , hasDefaultValue:false, defaultValueCode:null
BorderRadius? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => BorderRadiusTween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class BorderTween extends Tween<Border?>
class BorderTween$Mate extends BorderTween with Mate {/// BorderTween BorderTween({Border? begin, Border? end})
BorderTween$Mate({/// optionalParameters: {Border? begin} , hasDefaultValue:false, defaultValueCode:null
Border? begin, /// optionalParameters: {Border? end} , hasDefaultValue:false, defaultValueCode:null
Border? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => BorderTween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class Matrix4Tween extends Tween<Matrix4>
class Matrix4Tween$Mate extends Matrix4Tween with Mate {/// Matrix4Tween Matrix4Tween({Matrix4? begin, Matrix4? end})
Matrix4Tween$Mate({/// optionalParameters: {Matrix4? begin} , hasDefaultValue:false, defaultValueCode:null
Matrix4? begin, /// optionalParameters: {Matrix4? end} , hasDefaultValue:false, defaultValueCode:null
Matrix4? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => Matrix4Tween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class TextStyleTween extends Tween<TextStyle>
class TextStyleTween$Mate extends TextStyleTween with Mate {/// TextStyleTween TextStyleTween({TextStyle? begin, TextStyle? end})
TextStyleTween$Mate({/// optionalParameters: {TextStyle? begin} , hasDefaultValue:false, defaultValueCode:null
TextStyle? begin, /// optionalParameters: {TextStyle? end} , hasDefaultValue:false, defaultValueCode:null
TextStyle? end, }) : super(begin: begin, end: end, ) { mateBuilder = (p) => TextStyleTween$Mate(begin: p.get('begin').build(), end: p.get('end').build(), );
matePut('begin', begin);
matePut('end', end); }

 }
/// class AnimatedContainer extends ImplicitlyAnimatedWidget
class AnimatedContainer$Mate extends AnimatedContainer with Mate {/// AnimatedContainer AnimatedContainer({Key? key, AlignmentGeometry? alignment, EdgeInsetsGeometry? padding, Color? color, Decoration? decoration, Decoration? foregroundDecoration, double? width, double? height, BoxConstraints? constraints, EdgeInsetsGeometry? margin, Matrix4? transform, AlignmentGeometry? transformAlignment, Widget? child, Clip clipBehavior = Clip.none, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedContainer$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AlignmentGeometry? alignment} , hasDefaultValue:false, defaultValueCode:null
AlignmentGeometry? alignment, /// optionalParameters: {EdgeInsetsGeometry? padding} , hasDefaultValue:false, defaultValueCode:null
EdgeInsetsGeometry? padding, /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
Color? color, /// optionalParameters: {Decoration? decoration} , hasDefaultValue:false, defaultValueCode:null
Decoration? decoration, /// optionalParameters: {Decoration? foregroundDecoration} , hasDefaultValue:false, defaultValueCode:null
Decoration? foregroundDecoration, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {BoxConstraints? constraints} , hasDefaultValue:false, defaultValueCode:null
BoxConstraints? constraints, /// optionalParameters: {EdgeInsetsGeometry? margin} , hasDefaultValue:false, defaultValueCode:null
EdgeInsetsGeometry? margin, /// optionalParameters: {Matrix4? transform} , hasDefaultValue:false, defaultValueCode:null
Matrix4? transform, /// optionalParameters: {AlignmentGeometry? transformAlignment} , hasDefaultValue:false, defaultValueCode:null
AlignmentGeometry? transformAlignment, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, alignment: alignment, padding: padding, color: color, decoration: decoration, foregroundDecoration: foregroundDecoration, width: width, height: height, constraints: constraints, margin: margin, transform: transform, transformAlignment: transformAlignment, child: child, clipBehavior: clipBehavior, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedContainer$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), padding: p.get('padding').build(), color: p.get('color').build(), decoration: p.get('decoration').build(), foregroundDecoration: p.get('foregroundDecoration').build(), width: p.get('width').build(), height: p.get('height').build(), constraints: p.get('constraints').build(), margin: p.get('margin').build(), transform: p.get('transform').build(), transformAlignment: p.get('transformAlignment').build(), child: p.get('child').build(), clipBehavior: p.get('clipBehavior').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('padding', padding);
matePut('color', color);
matePut('decoration', decoration);
matePut('foregroundDecoration', foregroundDecoration);
matePut('width', width);
matePut('height', height);
matePut('constraints', constraints);
matePut('margin', margin);
matePut('transform', transform);
matePut('transformAlignment', transformAlignment);
matePut('child', child);
matePut('clipBehavior', clipBehavior);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedPadding extends ImplicitlyAnimatedWidget
class AnimatedPadding$Mate extends AnimatedPadding with Mate {/// AnimatedPadding AnimatedPadding({Key? key, required EdgeInsetsGeometry padding, Widget? child, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedPadding$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required EdgeInsetsGeometry padding} , hasDefaultValue:false, defaultValueCode:null
required EdgeInsetsGeometry padding, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, padding: padding, child: child, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedPadding$Mate(key: p.get('key').build(), padding: p.get('padding').build(), child: p.get('child').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('padding', padding);
matePut('child', child);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedAlign extends ImplicitlyAnimatedWidget
class AnimatedAlign$Mate extends AnimatedAlign with Mate {/// AnimatedAlign AnimatedAlign({Key? key, required AlignmentGeometry alignment, Widget? child, double? heightFactor, double? widthFactor, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedAlign$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required AlignmentGeometry alignment} , hasDefaultValue:false, defaultValueCode:null
required AlignmentGeometry alignment, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
double? heightFactor, /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
double? widthFactor, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, alignment: alignment, child: child, heightFactor: heightFactor, widthFactor: widthFactor, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedAlign$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), child: p.get('child').build(), heightFactor: p.get('heightFactor').build(), widthFactor: p.get('widthFactor').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('child', child);
matePut('heightFactor', heightFactor);
matePut('widthFactor', widthFactor);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedPositioned extends ImplicitlyAnimatedWidget
class AnimatedPositioned$Mate extends AnimatedPositioned with Mate {/// AnimatedPositioned AnimatedPositioned({Key? key, required Widget child, double? left, double? top, double? right, double? bottom, double? width, double? height, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedPositioned$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, /// optionalParameters: {double? left} , hasDefaultValue:false, defaultValueCode:null
double? left, /// optionalParameters: {double? top} , hasDefaultValue:false, defaultValueCode:null
double? top, /// optionalParameters: {double? right} , hasDefaultValue:false, defaultValueCode:null
double? right, /// optionalParameters: {double? bottom} , hasDefaultValue:false, defaultValueCode:null
double? bottom, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, child: child, left: left, top: top, right: right, bottom: bottom, width: width, height: height, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedPositioned$Mate(key: p.get('key').build(), child: p.get('child').build(), left: p.get('left').build(), top: p.get('top').build(), right: p.get('right').build(), bottom: p.get('bottom').build(), width: p.get('width').build(), height: p.get('height').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('left', left);
matePut('top', top);
matePut('right', right);
matePut('bottom', bottom);
matePut('width', width);
matePut('height', height);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

/// AnimatedPositioned AnimatedPositioned.fromRect({Key? key, required Widget child, required Rect rect, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedPositioned$Mate.fromRect({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, /// optionalParameters: {required Rect rect} , hasDefaultValue:false, defaultValueCode:null
required Rect rect, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super.fromRect(key: key, child: child, rect: rect, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedPositioned$Mate.fromRect(key: p.get('key').build(), child: p.get('child').build(), rect: p.get('rect').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('rect', rect);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedPositionedDirectional extends ImplicitlyAnimatedWidget
class AnimatedPositionedDirectional$Mate extends AnimatedPositionedDirectional with Mate {/// AnimatedPositionedDirectional AnimatedPositionedDirectional({Key? key, required Widget child, double? start, double? top, double? end, double? bottom, double? width, double? height, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedPositionedDirectional$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, /// optionalParameters: {double? start} , hasDefaultValue:false, defaultValueCode:null
double? start, /// optionalParameters: {double? top} , hasDefaultValue:false, defaultValueCode:null
double? top, /// optionalParameters: {double? end} , hasDefaultValue:false, defaultValueCode:null
double? end, /// optionalParameters: {double? bottom} , hasDefaultValue:false, defaultValueCode:null
double? bottom, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, child: child, start: start, top: top, end: end, bottom: bottom, width: width, height: height, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedPositionedDirectional$Mate(key: p.get('key').build(), child: p.get('child').build(), start: p.get('start').build(), top: p.get('top').build(), end: p.get('end').build(), bottom: p.get('bottom').build(), width: p.get('width').build(), height: p.get('height').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('start', start);
matePut('top', top);
matePut('end', end);
matePut('bottom', bottom);
matePut('width', width);
matePut('height', height);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedScale extends ImplicitlyAnimatedWidget
class AnimatedScale$Mate extends AnimatedScale with Mate {/// AnimatedScale AnimatedScale({Key? key, Widget? child, required double scale, Alignment alignment = Alignment.center, FilterQuality? filterQuality, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedScale$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {required double scale} , hasDefaultValue:false, defaultValueCode:null
required double scale, /// optionalParameters: {Alignment alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required Alignment alignment, /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
FilterQuality? filterQuality, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, child: child, scale: scale, alignment: alignment, filterQuality: filterQuality, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedScale$Mate(key: p.get('key').build(), child: p.get('child').build(), scale: p.get('scale').build(), alignment: p.get('alignment').build(), filterQuality: p.get('filterQuality').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('scale', scale);
matePut('alignment', alignment);
matePut('filterQuality', filterQuality);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedRotation extends ImplicitlyAnimatedWidget
class AnimatedRotation$Mate extends AnimatedRotation with Mate {/// AnimatedRotation AnimatedRotation({Key? key, Widget? child, required double turns, Alignment alignment = Alignment.center, FilterQuality? filterQuality, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedRotation$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {required double turns} , hasDefaultValue:false, defaultValueCode:null
required double turns, /// optionalParameters: {Alignment alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required Alignment alignment, /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
FilterQuality? filterQuality, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, child: child, turns: turns, alignment: alignment, filterQuality: filterQuality, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedRotation$Mate(key: p.get('key').build(), child: p.get('child').build(), turns: p.get('turns').build(), alignment: p.get('alignment').build(), filterQuality: p.get('filterQuality').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('turns', turns);
matePut('alignment', alignment);
matePut('filterQuality', filterQuality);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedSlide extends ImplicitlyAnimatedWidget
class AnimatedSlide$Mate extends AnimatedSlide with Mate {/// AnimatedSlide AnimatedSlide({Key? key, Widget? child, required Offset offset, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedSlide$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {required Offset offset} , hasDefaultValue:false, defaultValueCode:null
required Offset offset, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, child: child, offset: offset, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedSlide$Mate(key: p.get('key').build(), child: p.get('child').build(), offset: p.get('offset').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('offset', offset);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedOpacity extends ImplicitlyAnimatedWidget
class AnimatedOpacity$Mate extends AnimatedOpacity with Mate {/// AnimatedOpacity AnimatedOpacity({Key? key, Widget? child, required double opacity, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd, bool alwaysIncludeSemantics = false})
AnimatedOpacity$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {required double opacity} , hasDefaultValue:false, defaultValueCode:null
required double opacity, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool alwaysIncludeSemantics, }) : super(key: key, child: child, opacity: opacity, curve: curve, duration: duration, onEnd: onEnd, alwaysIncludeSemantics: alwaysIncludeSemantics, ) { mateBuilder = (p) => AnimatedOpacity$Mate(key: p.get('key').build(), child: p.get('child').build(), opacity: p.get('opacity').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(), );
matePut('key', key);
matePut('child', child);
matePut('opacity', opacity);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd);
matePut('alwaysIncludeSemantics', alwaysIncludeSemantics); }

 }
/// class SliverAnimatedOpacity extends ImplicitlyAnimatedWidget
class SliverAnimatedOpacity$Mate extends SliverAnimatedOpacity with Mate {/// SliverAnimatedOpacity SliverAnimatedOpacity({Key? key, Widget? sliver, required double opacity, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd, bool alwaysIncludeSemantics = false})
SliverAnimatedOpacity$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? sliver} , hasDefaultValue:false, defaultValueCode:null
Widget? sliver, /// optionalParameters: {required double opacity} , hasDefaultValue:false, defaultValueCode:null
required double opacity, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool alwaysIncludeSemantics, }) : super(key: key, sliver: sliver, opacity: opacity, curve: curve, duration: duration, onEnd: onEnd, alwaysIncludeSemantics: alwaysIncludeSemantics, ) { mateBuilder = (p) => SliverAnimatedOpacity$Mate(key: p.get('key').build(), sliver: p.get('sliver').build(), opacity: p.get('opacity').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(), );
matePut('key', key);
matePut('sliver', sliver);
matePut('opacity', opacity);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd);
matePut('alwaysIncludeSemantics', alwaysIncludeSemantics); }

 }
/// class AnimatedDefaultTextStyle extends ImplicitlyAnimatedWidget
class AnimatedDefaultTextStyle$Mate extends AnimatedDefaultTextStyle with Mate {/// AnimatedDefaultTextStyle AnimatedDefaultTextStyle({Key? key, required Widget child, required TextStyle style, TextAlign? textAlign, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, int? maxLines, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedDefaultTextStyle$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, /// optionalParameters: {required TextStyle style} , hasDefaultValue:false, defaultValueCode:null
required TextStyle style, /// optionalParameters: {TextAlign? textAlign} , hasDefaultValue:false, defaultValueCode:null
TextAlign? textAlign, /// optionalParameters: {bool softWrap = true} , hasDefaultValue:true, defaultValueCode:true
required bool softWrap, /// optionalParameters: {TextOverflow overflow = TextOverflow.clip} , hasDefaultValue:true, defaultValueCode:TextOverflow.clip
required TextOverflow overflow, /// optionalParameters: {int? maxLines} , hasDefaultValue:false, defaultValueCode:null
int? maxLines, /// optionalParameters: {TextWidthBasis textWidthBasis = TextWidthBasis.parent} , hasDefaultValue:true, defaultValueCode:TextWidthBasis.parent
required TextWidthBasis textWidthBasis, /// optionalParameters: {TextHeightBehavior? textHeightBehavior} , hasDefaultValue:false, defaultValueCode:null
TextHeightBehavior? textHeightBehavior, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, child: child, style: style, textAlign: textAlign, softWrap: softWrap, overflow: overflow, maxLines: maxLines, textWidthBasis: textWidthBasis, textHeightBehavior: textHeightBehavior, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedDefaultTextStyle$Mate(key: p.get('key').build(), child: p.get('child').build(), style: p.get('style').build(), textAlign: p.get('textAlign').build(), softWrap: p.get('softWrap').build(), overflow: p.get('overflow').build(), maxLines: p.get('maxLines').build(), textWidthBasis: p.get('textWidthBasis').build(), textHeightBehavior: p.get('textHeightBehavior').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('style', style);
matePut('textAlign', textAlign);
matePut('softWrap', softWrap);
matePut('overflow', overflow);
matePut('maxLines', maxLines);
matePut('textWidthBasis', textWidthBasis);
matePut('textHeightBehavior', textHeightBehavior);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedPhysicalModel extends ImplicitlyAnimatedWidget
class AnimatedPhysicalModel$Mate extends AnimatedPhysicalModel with Mate {/// AnimatedPhysicalModel AnimatedPhysicalModel({Key? key, required Widget child, required BoxShape shape, Clip clipBehavior = Clip.none, BorderRadius borderRadius = BorderRadius.zero, required double elevation, required Color color, bool animateColor = true, required Color shadowColor, bool animateShadowColor = true, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedPhysicalModel$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, /// optionalParameters: {required BoxShape shape} , hasDefaultValue:false, defaultValueCode:null
required BoxShape shape, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {BorderRadius borderRadius = BorderRadius.zero} , hasDefaultValue:true, defaultValueCode:BorderRadius.zero
required BorderRadius borderRadius, /// optionalParameters: {required double elevation} , hasDefaultValue:false, defaultValueCode:null
required double elevation, /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
required Color color, /// optionalParameters: {bool animateColor = true} , hasDefaultValue:true, defaultValueCode:true
required bool animateColor, /// optionalParameters: {required Color shadowColor} , hasDefaultValue:false, defaultValueCode:null
required Color shadowColor, /// optionalParameters: {bool animateShadowColor = true} , hasDefaultValue:true, defaultValueCode:true
required bool animateShadowColor, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, child: child, shape: shape, clipBehavior: clipBehavior, borderRadius: borderRadius, elevation: elevation, color: color, animateColor: animateColor, shadowColor: shadowColor, animateShadowColor: animateShadowColor, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedPhysicalModel$Mate(key: p.get('key').build(), child: p.get('child').build(), shape: p.get('shape').build(), clipBehavior: p.get('clipBehavior').build(), borderRadius: p.get('borderRadius').build(), elevation: p.get('elevation').build(), color: p.get('color').build(), animateColor: p.get('animateColor').build(), shadowColor: p.get('shadowColor').build(), animateShadowColor: p.get('animateShadowColor').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('child', child);
matePut('shape', shape);
matePut('clipBehavior', clipBehavior);
matePut('borderRadius', borderRadius);
matePut('elevation', elevation);
matePut('color', color);
matePut('animateColor', animateColor);
matePut('shadowColor', shadowColor);
matePut('animateShadowColor', animateShadowColor);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
/// class AnimatedFractionallySizedBox extends ImplicitlyAnimatedWidget
class AnimatedFractionallySizedBox$Mate extends AnimatedFractionallySizedBox with Mate {/// AnimatedFractionallySizedBox AnimatedFractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, Widget? child, double? heightFactor, double? widthFactor, Curve curve = Curves.linear, required Duration duration, void Function()? onEnd})
AnimatedFractionallySizedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
double? heightFactor, /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
double? widthFactor, /// optionalParameters: {Curve curve = Curves.linear} , hasDefaultValue:true, defaultValueCode:Curves.linear
required Curve curve, /// optionalParameters: {required Duration duration} , hasDefaultValue:false, defaultValueCode:null
required Duration duration, /// optionalParameters: {void Function()? onEnd} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onEnd, }) : super(key: key, alignment: alignment, child: child, heightFactor: heightFactor, widthFactor: widthFactor, curve: curve, duration: duration, onEnd: onEnd, ) { mateBuilder = (p) => AnimatedFractionallySizedBox$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), child: p.get('child').build(), heightFactor: p.get('heightFactor').build(), widthFactor: p.get('widthFactor').build(), curve: p.get('curve').build(), duration: p.get('duration').build(), onEnd: p.get('onEnd').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('child', child);
matePut('heightFactor', heightFactor);
matePut('widthFactor', widthFactor);
matePut('curve', curve);
matePut('duration', duration);
matePut('onEnd', onEnd); }

 }
