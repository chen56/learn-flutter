// /// Generated by gen_maters.dart, please don't edit!

import 'dart:core';
import 'package:flutter/src/widgets/drag_target.dart';
import 'package:note/mate.dart';
import 'package:flutter/src/foundation/key.dart';
import 'package:flutter/src/widgets/framework.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'dart:ui';
import 'package:flutter/animation.dart';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/src/gestures/recognizer.dart';
import 'package:flutter/src/gestures/velocity_tracker.dart';

/// class Draggable<T extends Object> extends StatefulWidget
class Draggable$Mate<T extends Object> extends Draggable<T> with Mate {
  /// Draggable<T> Draggable({Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy, Axis? affinity, int? maxSimultaneousDrags, void Function()? onDragStarted, void Function(DragUpdateDetails)? onDragUpdate, void Function(Velocity, Offset)? onDraggableCanceled, void Function(DraggableDetails)? onDragEnd, void Function()? onDragCompleted, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, bool rootOverlay = false, HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild, bool Function(int)? allowedButtonsFilter})
  Draggable$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,

    /// optionalParameters: {required Widget feedback} , default:none
    required Widget feedback,

    /// optionalParameters: {T? data} , default:none
    T? data,

    /// optionalParameters: {Axis? axis} , default:none
    Axis? axis,

    /// optionalParameters: {Widget? childWhenDragging} , default:none
    Widget? childWhenDragging,

    /// optionalParameters: {Offset feedbackOffset = Offset.zero} , default:processed=PrefixedIdentifierImpl
    Offset feedbackOffset = Offset.zero,

    /// optionalParameters: {Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy} , default:unprocessed=SimpleIdentifierImpl
    required DragAnchorStrategy dragAnchorStrategy,

    /// optionalParameters: {Axis? affinity} , default:none
    Axis? affinity,

    /// optionalParameters: {int? maxSimultaneousDrags} , default:none
    int? maxSimultaneousDrags,

    /// optionalParameters: {void Function()? onDragStarted} , default:none
    VoidCallback? onDragStarted,

    /// optionalParameters: {void Function(DragUpdateDetails)? onDragUpdate} , default:none
    DragUpdateCallback? onDragUpdate,

    /// optionalParameters: {void Function(Velocity, Offset)? onDraggableCanceled} , default:none
    DraggableCanceledCallback? onDraggableCanceled,

    /// optionalParameters: {void Function(DraggableDetails)? onDragEnd} , default:none
    DragEndCallback? onDragEnd,

    /// optionalParameters: {void Function()? onDragCompleted} , default:none
    VoidCallback? onDragCompleted,

    /// optionalParameters: {bool ignoringFeedbackSemantics = true} , default:processed=BooleanLiteralImpl
    bool ignoringFeedbackSemantics = true,

    /// optionalParameters: {bool ignoringFeedbackPointer = true} , default:processed=BooleanLiteralImpl
    bool ignoringFeedbackPointer = true,

    /// optionalParameters: {bool rootOverlay = false} , default:processed=BooleanLiteralImpl
    bool rootOverlay = false,

    /// optionalParameters: {HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild} , default:processed=PrefixedIdentifierImpl
    HitTestBehavior hitTestBehavior = HitTestBehavior.deferToChild,

    /// optionalParameters: {bool Function(int)? allowedButtonsFilter} , default:none
    AllowedButtonsFilter? allowedButtonsFilter,
  }) : super(
          key: key,
          child: child,
          feedback: feedback,
          data: data,
          axis: axis,
          childWhenDragging: childWhenDragging,
          feedbackOffset: feedbackOffset,
          dragAnchorStrategy: dragAnchorStrategy,
          affinity: affinity,
          maxSimultaneousDrags: maxSimultaneousDrags,
          onDragStarted: onDragStarted,
          onDragUpdate: onDragUpdate,
          onDraggableCanceled: onDraggableCanceled,
          onDragEnd: onDragEnd,
          onDragCompleted: onDragCompleted,
          ignoringFeedbackSemantics: ignoringFeedbackSemantics,
          ignoringFeedbackPointer: ignoringFeedbackPointer,
          rootOverlay: rootOverlay,
          hitTestBehavior: hitTestBehavior,
          allowedButtonsFilter: allowedButtonsFilter,
        ) {
    mateBuilderName = 'Draggable';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Draggable$Mate<T>(
          key: p.get('key').build(),
          child: p.get('child').build(),
          feedback: p.get('feedback').build(),
          data: p.get('data').build(),
          axis: p.get('axis').build(),
          childWhenDragging: p.get('childWhenDragging').build(),
          feedbackOffset: p.get('feedbackOffset').build(),
          dragAnchorStrategy: p.get('dragAnchorStrategy').build(),
          affinity: p.get('affinity').build(),
          maxSimultaneousDrags: p.get('maxSimultaneousDrags').build(),
          onDragStarted: p.get('onDragStarted').build(),
          onDragUpdate: p.get('onDragUpdate').build(),
          onDraggableCanceled: p.get('onDraggableCanceled').build(),
          onDragEnd: p.get('onDragEnd').build(),
          onDragCompleted: p.get('onDragCompleted').build(),
          ignoringFeedbackSemantics: p.get('ignoringFeedbackSemantics').build(),
          ignoringFeedbackPointer: p.get('ignoringFeedbackPointer').build(),
          rootOverlay: p.get('rootOverlay').build(),
          hitTestBehavior: p.get('hitTestBehavior').build(),
          allowedButtonsFilter: p.get('allowedButtonsFilter').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'feedback',
      feedback,
      isNamed: true,
    );
    mateUse(
      'data',
      data,
      isNamed: true,
    );
    mateUse(
      'axis',
      axis,
      isNamed: true,
    );
    mateUse(
      'childWhenDragging',
      childWhenDragging,
      isNamed: true,
    );
    mateUse(
      'feedbackOffset',
      feedbackOffset,
      isNamed: true,
      defaultValue: Offset.zero,
    );
    mateUse(
      'dragAnchorStrategy',
      dragAnchorStrategy,
      isNamed: true,
    );
    mateUse(
      'affinity',
      affinity,
      isNamed: true,
    );
    mateUse(
      'maxSimultaneousDrags',
      maxSimultaneousDrags,
      isNamed: true,
    );
    mateUse(
      'onDragStarted',
      onDragStarted,
      isNamed: true,
    );
    mateUse(
      'onDragUpdate',
      onDragUpdate,
      isNamed: true,
    );
    mateUse(
      'onDraggableCanceled',
      onDraggableCanceled,
      isNamed: true,
    );
    mateUse(
      'onDragEnd',
      onDragEnd,
      isNamed: true,
    );
    mateUse(
      'onDragCompleted',
      onDragCompleted,
      isNamed: true,
    );
    mateUse(
      'ignoringFeedbackSemantics',
      ignoringFeedbackSemantics,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'ignoringFeedbackPointer',
      ignoringFeedbackPointer,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'rootOverlay',
      rootOverlay,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'hitTestBehavior',
      hitTestBehavior,
      isNamed: true,
      defaultValue: HitTestBehavior.deferToChild,
    );
    mateUse(
      'allowedButtonsFilter',
      allowedButtonsFilter,
      isNamed: true,
    );
  }
}

/// class LongPressDraggable<T extends Object> extends Draggable<T>
class LongPressDraggable$Mate<T extends Object> extends LongPressDraggable<T>
    with Mate {
  /// LongPressDraggable<T> LongPressDraggable({Key? key, required Widget child, required Widget feedback, T? data, Axis? axis, Widget? childWhenDragging, Offset feedbackOffset = Offset.zero, Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy, int? maxSimultaneousDrags, void Function()? onDragStarted, void Function(DragUpdateDetails)? onDragUpdate, void Function(Velocity, Offset)? onDraggableCanceled, void Function(DraggableDetails)? onDragEnd, void Function()? onDragCompleted, bool hapticFeedbackOnStart = true, bool ignoringFeedbackSemantics = true, bool ignoringFeedbackPointer = true, Duration delay = kLongPressTimeout, bool Function(int)? allowedButtonsFilter})
  LongPressDraggable$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,

    /// optionalParameters: {required Widget feedback} , default:none
    required Widget feedback,

    /// optionalParameters: {T? data} , default:none
    T? data,

    /// optionalParameters: {Axis? axis} , default:none
    Axis? axis,

    /// optionalParameters: {Widget? childWhenDragging} , default:none
    Widget? childWhenDragging,

    /// optionalParameters: {Offset feedbackOffset = Offset.zero} , default:processed=PrefixedIdentifierImpl
    Offset feedbackOffset = Offset.zero,

    /// optionalParameters: {Offset Function(Draggable<Object>, BuildContext, Offset) dragAnchorStrategy = childDragAnchorStrategy} , default:unprocessed=SimpleIdentifierImpl
    required DragAnchorStrategy dragAnchorStrategy,

    /// optionalParameters: {int? maxSimultaneousDrags} , default:none
    int? maxSimultaneousDrags,

    /// optionalParameters: {void Function()? onDragStarted} , default:none
    VoidCallback? onDragStarted,

    /// optionalParameters: {void Function(DragUpdateDetails)? onDragUpdate} , default:none
    DragUpdateCallback? onDragUpdate,

    /// optionalParameters: {void Function(Velocity, Offset)? onDraggableCanceled} , default:none
    DraggableCanceledCallback? onDraggableCanceled,

    /// optionalParameters: {void Function(DraggableDetails)? onDragEnd} , default:none
    DragEndCallback? onDragEnd,

    /// optionalParameters: {void Function()? onDragCompleted} , default:none
    VoidCallback? onDragCompleted,

    /// optionalParameters: {bool hapticFeedbackOnStart = true} , default:processed=BooleanLiteralImpl
    bool hapticFeedbackOnStart = true,

    /// optionalParameters: {bool ignoringFeedbackSemantics = true} , default:processed=BooleanLiteralImpl
    bool ignoringFeedbackSemantics = true,

    /// optionalParameters: {bool ignoringFeedbackPointer = true} , default:processed=BooleanLiteralImpl
    bool ignoringFeedbackPointer = true,

    /// optionalParameters: {Duration delay = kLongPressTimeout} , default:unprocessed=SimpleIdentifierImpl
    required Duration delay,

    /// optionalParameters: {bool Function(int)? allowedButtonsFilter} , default:none
    AllowedButtonsFilter? allowedButtonsFilter,
  }) : super(
          key: key,
          child: child,
          feedback: feedback,
          data: data,
          axis: axis,
          childWhenDragging: childWhenDragging,
          feedbackOffset: feedbackOffset,
          dragAnchorStrategy: dragAnchorStrategy,
          maxSimultaneousDrags: maxSimultaneousDrags,
          onDragStarted: onDragStarted,
          onDragUpdate: onDragUpdate,
          onDraggableCanceled: onDraggableCanceled,
          onDragEnd: onDragEnd,
          onDragCompleted: onDragCompleted,
          hapticFeedbackOnStart: hapticFeedbackOnStart,
          ignoringFeedbackSemantics: ignoringFeedbackSemantics,
          ignoringFeedbackPointer: ignoringFeedbackPointer,
          delay: delay,
          allowedButtonsFilter: allowedButtonsFilter,
        ) {
    mateBuilderName = 'LongPressDraggable';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => LongPressDraggable$Mate<T>(
          key: p.get('key').build(),
          child: p.get('child').build(),
          feedback: p.get('feedback').build(),
          data: p.get('data').build(),
          axis: p.get('axis').build(),
          childWhenDragging: p.get('childWhenDragging').build(),
          feedbackOffset: p.get('feedbackOffset').build(),
          dragAnchorStrategy: p.get('dragAnchorStrategy').build(),
          maxSimultaneousDrags: p.get('maxSimultaneousDrags').build(),
          onDragStarted: p.get('onDragStarted').build(),
          onDragUpdate: p.get('onDragUpdate').build(),
          onDraggableCanceled: p.get('onDraggableCanceled').build(),
          onDragEnd: p.get('onDragEnd').build(),
          onDragCompleted: p.get('onDragCompleted').build(),
          hapticFeedbackOnStart: p.get('hapticFeedbackOnStart').build(),
          ignoringFeedbackSemantics: p.get('ignoringFeedbackSemantics').build(),
          ignoringFeedbackPointer: p.get('ignoringFeedbackPointer').build(),
          delay: p.get('delay').build(),
          allowedButtonsFilter: p.get('allowedButtonsFilter').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'feedback',
      feedback,
      isNamed: true,
    );
    mateUse(
      'data',
      data,
      isNamed: true,
    );
    mateUse(
      'axis',
      axis,
      isNamed: true,
    );
    mateUse(
      'childWhenDragging',
      childWhenDragging,
      isNamed: true,
    );
    mateUse(
      'feedbackOffset',
      feedbackOffset,
      isNamed: true,
      defaultValue: Offset.zero,
    );
    mateUse(
      'dragAnchorStrategy',
      dragAnchorStrategy,
      isNamed: true,
    );
    mateUse(
      'maxSimultaneousDrags',
      maxSimultaneousDrags,
      isNamed: true,
    );
    mateUse(
      'onDragStarted',
      onDragStarted,
      isNamed: true,
    );
    mateUse(
      'onDragUpdate',
      onDragUpdate,
      isNamed: true,
    );
    mateUse(
      'onDraggableCanceled',
      onDraggableCanceled,
      isNamed: true,
    );
    mateUse(
      'onDragEnd',
      onDragEnd,
      isNamed: true,
    );
    mateUse(
      'onDragCompleted',
      onDragCompleted,
      isNamed: true,
    );
    mateUse(
      'hapticFeedbackOnStart',
      hapticFeedbackOnStart,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'ignoringFeedbackSemantics',
      ignoringFeedbackSemantics,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'ignoringFeedbackPointer',
      ignoringFeedbackPointer,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'delay',
      delay,
      isNamed: true,
    );
    mateUse(
      'allowedButtonsFilter',
      allowedButtonsFilter,
      isNamed: true,
    );
  }
}

/// class DraggableDetails
class DraggableDetails$Mate extends DraggableDetails with Mate {
  /// DraggableDetails DraggableDetails({bool wasAccepted = false, required Velocity velocity, required Offset offset})
  DraggableDetails$Mate({
    /// optionalParameters: {bool wasAccepted = false} , default:processed=BooleanLiteralImpl
    bool wasAccepted = false,

    /// optionalParameters: {required Velocity velocity} , default:none
    required Velocity velocity,

    /// optionalParameters: {required Offset offset} , default:none
    required Offset offset,
  }) : super(
          wasAccepted: wasAccepted,
          velocity: velocity,
          offset: offset,
        ) {
    mateBuilderName = 'DraggableDetails';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => DraggableDetails$Mate(
          wasAccepted: p.get('wasAccepted').build(),
          velocity: p.get('velocity').build(),
          offset: p.get('offset').build(),
        );
    mateUse(
      'wasAccepted',
      wasAccepted,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'velocity',
      velocity,
      isNamed: true,
    );
    mateUse(
      'offset',
      offset,
      isNamed: true,
    );
  }
}

/// class DragTargetDetails<T>
class DragTargetDetails$Mate<T> extends DragTargetDetails<T> with Mate {
  /// DragTargetDetails<T> DragTargetDetails({required T data, required Offset offset})
  DragTargetDetails$Mate({
    /// optionalParameters: {required T data} , default:none
    required T data,

    /// optionalParameters: {required Offset offset} , default:none
    required Offset offset,
  }) : super(
          data: data,
          offset: offset,
        ) {
    mateBuilderName = 'DragTargetDetails';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => DragTargetDetails$Mate<T>(
          data: p.get('data').build(),
          offset: p.get('offset').build(),
        );
    mateUse(
      'data',
      data,
      isNamed: true,
    );
    mateUse(
      'offset',
      offset,
      isNamed: true,
    );
  }
}

/// class DragTarget<T extends Object> extends StatefulWidget
class DragTarget$Mate<T extends Object> extends DragTarget<T> with Mate {
  /// DragTarget<T> DragTarget({Key? key, required Widget Function(BuildContext, List<T?>, List<dynamic>) builder, bool Function(T?)? onWillAccept, void Function(T)? onAccept, void Function(DragTargetDetails<T>)? onAcceptWithDetails, void Function(T?)? onLeave, void Function(DragTargetDetails<T>)? onMove, HitTestBehavior hitTestBehavior = HitTestBehavior.translucent})
  DragTarget$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Widget Function(BuildContext, List<T?>, List<dynamic>) builder} , default:none
    required DragTargetBuilder<T> builder,

    /// optionalParameters: {bool Function(T?)? onWillAccept} , default:none
    DragTargetWillAccept<T>? onWillAccept,

    /// optionalParameters: {void Function(T)? onAccept} , default:none
    DragTargetAccept<T>? onAccept,

    /// optionalParameters: {void Function(DragTargetDetails<T>)? onAcceptWithDetails} , default:none
    DragTargetAcceptWithDetails<T>? onAcceptWithDetails,

    /// optionalParameters: {void Function(T?)? onLeave} , default:none
    DragTargetLeave<T>? onLeave,

    /// optionalParameters: {void Function(DragTargetDetails<T>)? onMove} , default:none
    DragTargetMove<T>? onMove,

    /// optionalParameters: {HitTestBehavior hitTestBehavior = HitTestBehavior.translucent} , default:processed=PrefixedIdentifierImpl
    HitTestBehavior hitTestBehavior = HitTestBehavior.translucent,
  }) : super(
          key: key,
          builder: builder,
          onWillAccept: onWillAccept,
          onAccept: onAccept,
          onAcceptWithDetails: onAcceptWithDetails,
          onLeave: onLeave,
          onMove: onMove,
          hitTestBehavior: hitTestBehavior,
        ) {
    mateBuilderName = 'DragTarget';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => DragTarget$Mate<T>(
          key: p.get('key').build(),
          builder: p.get('builder').build(),
          onWillAccept: p.get('onWillAccept').build(),
          onAccept: p.get('onAccept').build(),
          onAcceptWithDetails: p.get('onAcceptWithDetails').build(),
          onLeave: p.get('onLeave').build(),
          onMove: p.get('onMove').build(),
          hitTestBehavior: p.get('hitTestBehavior').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'builder',
      builder,
      isNamed: true,
    );
    mateUse(
      'onWillAccept',
      onWillAccept,
      isNamed: true,
    );
    mateUse(
      'onAccept',
      onAccept,
      isNamed: true,
    );
    mateUse(
      'onAcceptWithDetails',
      onAcceptWithDetails,
      isNamed: true,
    );
    mateUse(
      'onLeave',
      onLeave,
      isNamed: true,
    );
    mateUse(
      'onMove',
      onMove,
      isNamed: true,
    );
    mateUse(
      'hitTestBehavior',
      hitTestBehavior,
      isNamed: true,
      defaultValue: HitTestBehavior.translucent,
    );
  }
}
