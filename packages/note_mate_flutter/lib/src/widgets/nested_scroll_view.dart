// /// Generated by gen_maters.dart, please don't edit! 

import 'package:flutter/src/widgets/nested_scroll_view.dart';import 'package:flutter/src/foundation/key.dart';import 'package:flutter/src/widgets/scroll_controller.dart';import 'package:flutter/src/painting/basic_types.dart';import 'dart:core';import 'package:flutter/src/widgets/scroll_physics.dart';import 'package:flutter/src/widgets/framework.dart';import 'package:flutter/src/gestures/recognizer.dart';import 'dart:ui';import 'package:flutter/src/widgets/scroll_configuration.dart';import 'package:flutter/src/rendering/sliver.dart';import 'package:flutter/src/rendering/viewport_offset.dart';import 'package:note/mate.dart' show Mate;/// class NestedScrollView extends StatefulWidget
class NestedScrollView$Mate extends NestedScrollView with Mate {/// NestedScrollView NestedScrollView({Key? key, ScrollController? controller, Axis scrollDirection = Axis.vertical, bool reverse = false, ScrollPhysics? physics, required List<Widget> Function(BuildContext, bool) headerSliverBuilder, required Widget body, DragStartBehavior dragStartBehavior = DragStartBehavior.start, bool floatHeaderSlivers = false, Clip clipBehavior = Clip.hardEdge, String? restorationId, ScrollBehavior? scrollBehavior})
NestedScrollView$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {ScrollController? controller} , hasDefaultValue:false, defaultValueCode:null
ScrollController? controller, /// optionalParameters: {Axis scrollDirection = Axis.vertical} , hasDefaultValue:true, defaultValueCode:Axis.vertical
required Axis scrollDirection, /// optionalParameters: {bool reverse = false} , hasDefaultValue:true, defaultValueCode:false
required bool reverse, /// optionalParameters: {ScrollPhysics? physics} , hasDefaultValue:false, defaultValueCode:null
ScrollPhysics? physics, /// optionalParameters: {required List<Widget> Function(BuildContext, bool) headerSliverBuilder} , hasDefaultValue:false, defaultValueCode:null
required NestedScrollViewHeaderSliversBuilder headerSliverBuilder, /// optionalParameters: {required Widget body} , hasDefaultValue:false, defaultValueCode:null
required Widget body, /// optionalParameters: {DragStartBehavior dragStartBehavior = DragStartBehavior.start} , hasDefaultValue:true, defaultValueCode:DragStartBehavior.start
required DragStartBehavior dragStartBehavior, /// optionalParameters: {bool floatHeaderSlivers = false} , hasDefaultValue:true, defaultValueCode:false
required bool floatHeaderSlivers, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, /// optionalParameters: {String? restorationId} , hasDefaultValue:false, defaultValueCode:null
String? restorationId, /// optionalParameters: {ScrollBehavior? scrollBehavior} , hasDefaultValue:false, defaultValueCode:null
ScrollBehavior? scrollBehavior, }) : super(key: key, controller: controller, scrollDirection: scrollDirection, reverse: reverse, physics: physics, headerSliverBuilder: headerSliverBuilder, body: body, dragStartBehavior: dragStartBehavior, floatHeaderSlivers: floatHeaderSlivers, clipBehavior: clipBehavior, restorationId: restorationId, scrollBehavior: scrollBehavior, ) { mateBuilder = (p) => NestedScrollView$Mate(key: p.get('key').build(), controller: p.get('controller').build(), scrollDirection: p.get('scrollDirection').build(), reverse: p.get('reverse').build(), physics: p.get('physics').build(), headerSliverBuilder: p.get('headerSliverBuilder').build(), body: p.get('body').build(), dragStartBehavior: p.get('dragStartBehavior').build(), floatHeaderSlivers: p.get('floatHeaderSlivers').build(), clipBehavior: p.get('clipBehavior').build(), restorationId: p.get('restorationId').build(), scrollBehavior: p.get('scrollBehavior').build(), );
matePut('key', key);
matePut('controller', controller);
matePut('scrollDirection', scrollDirection);
matePut('reverse', reverse);
matePut('physics', physics);
matePut('headerSliverBuilder', headerSliverBuilder);
matePut('body', body);
matePut('dragStartBehavior', dragStartBehavior);
matePut('floatHeaderSlivers', floatHeaderSlivers);
matePut('clipBehavior', clipBehavior);
matePut('restorationId', restorationId);
matePut('scrollBehavior', scrollBehavior); }

 }
/// class SliverOverlapAbsorber extends SingleChildRenderObjectWidget
class SliverOverlapAbsorber$Mate extends SliverOverlapAbsorber with Mate {/// SliverOverlapAbsorber SliverOverlapAbsorber({Key? key, required SliverOverlapAbsorberHandle handle, Widget? sliver})
SliverOverlapAbsorber$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required SliverOverlapAbsorberHandle handle} , hasDefaultValue:false, defaultValueCode:null
required SliverOverlapAbsorberHandle handle, /// optionalParameters: {Widget? sliver} , hasDefaultValue:false, defaultValueCode:null
Widget? sliver, }) : super(key: key, handle: handle, sliver: sliver, ) { mateBuilder = (p) => SliverOverlapAbsorber$Mate(key: p.get('key').build(), handle: p.get('handle').build(), sliver: p.get('sliver').build(), );
matePut('key', key);
matePut('handle', handle);
matePut('sliver', sliver); }

 }
/// class RenderSliverOverlapAbsorber extends RenderSliver with RenderObjectWithChildMixin<RenderSliver>
class RenderSliverOverlapAbsorber$Mate extends RenderSliverOverlapAbsorber with Mate {/// RenderSliverOverlapAbsorber RenderSliverOverlapAbsorber({required SliverOverlapAbsorberHandle handle, RenderSliver? sliver})
RenderSliverOverlapAbsorber$Mate({/// optionalParameters: {required SliverOverlapAbsorberHandle handle} , hasDefaultValue:false, defaultValueCode:null
required SliverOverlapAbsorberHandle handle, /// optionalParameters: {RenderSliver? sliver} , hasDefaultValue:false, defaultValueCode:null
RenderSliver? sliver, }) : super(handle: handle, sliver: sliver, ) { mateBuilder = (p) => RenderSliverOverlapAbsorber$Mate(handle: p.get('handle').build(), sliver: p.get('sliver').build(), );
matePut('handle', handle);
matePut('sliver', sliver); }

 }
/// class SliverOverlapInjector extends SingleChildRenderObjectWidget
class SliverOverlapInjector$Mate extends SliverOverlapInjector with Mate {/// SliverOverlapInjector SliverOverlapInjector({Key? key, required SliverOverlapAbsorberHandle handle, Widget? sliver})
SliverOverlapInjector$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required SliverOverlapAbsorberHandle handle} , hasDefaultValue:false, defaultValueCode:null
required SliverOverlapAbsorberHandle handle, /// optionalParameters: {Widget? sliver} , hasDefaultValue:false, defaultValueCode:null
Widget? sliver, }) : super(key: key, handle: handle, sliver: sliver, ) { mateBuilder = (p) => SliverOverlapInjector$Mate(key: p.get('key').build(), handle: p.get('handle').build(), sliver: p.get('sliver').build(), );
matePut('key', key);
matePut('handle', handle);
matePut('sliver', sliver); }

 }
/// class RenderSliverOverlapInjector extends RenderSliver
class RenderSliverOverlapInjector$Mate extends RenderSliverOverlapInjector with Mate {/// RenderSliverOverlapInjector RenderSliverOverlapInjector({required SliverOverlapAbsorberHandle handle})
RenderSliverOverlapInjector$Mate({/// optionalParameters: {required SliverOverlapAbsorberHandle handle} , hasDefaultValue:false, defaultValueCode:null
required SliverOverlapAbsorberHandle handle}) : super(handle: handle) { mateBuilder = (p) => RenderSliverOverlapInjector$Mate(handle: p.get('handle').build());
matePut('handle', handle); }

 }
/// class NestedScrollViewViewport extends Viewport
class NestedScrollViewViewport$Mate extends NestedScrollViewViewport with Mate {/// NestedScrollViewViewport NestedScrollViewViewport({Key? key, AxisDirection axisDirection = AxisDirection.down, AxisDirection? crossAxisDirection, double anchor = 0.0, required ViewportOffset offset, Key? center, List<Widget> slivers = const <Widget>[], required SliverOverlapAbsorberHandle handle, Clip clipBehavior = Clip.hardEdge})
NestedScrollViewViewport$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AxisDirection axisDirection = AxisDirection.down} , hasDefaultValue:true, defaultValueCode:AxisDirection.down
required AxisDirection axisDirection, /// optionalParameters: {AxisDirection? crossAxisDirection} , hasDefaultValue:false, defaultValueCode:null
AxisDirection? crossAxisDirection, /// optionalParameters: {double anchor = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
required double anchor, /// optionalParameters: {required ViewportOffset offset} , hasDefaultValue:false, defaultValueCode:null
required ViewportOffset offset, /// optionalParameters: {Key? center} , hasDefaultValue:false, defaultValueCode:null
Key? center, /// optionalParameters: {List<Widget> slivers = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> slivers, /// optionalParameters: {required SliverOverlapAbsorberHandle handle} , hasDefaultValue:false, defaultValueCode:null
required SliverOverlapAbsorberHandle handle, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, }) : super(key: key, axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, anchor: anchor, offset: offset, center: center, slivers: slivers, handle: handle, clipBehavior: clipBehavior, ) { mateBuilder = (p) => NestedScrollViewViewport$Mate(key: p.get('key').build(), axisDirection: p.get('axisDirection').build(), crossAxisDirection: p.get('crossAxisDirection').build(), anchor: p.get('anchor').build(), offset: p.get('offset').build(), center: p.get('center').build(), slivers: p.get('slivers').build(), handle: p.get('handle').build(), clipBehavior: p.get('clipBehavior').build(), );
matePut('key', key);
matePut('axisDirection', axisDirection);
matePut('crossAxisDirection', crossAxisDirection);
matePut('anchor', anchor);
matePut('offset', offset);
matePut('center', center);
matePut('slivers', slivers);
matePut('handle', handle);
matePut('clipBehavior', clipBehavior); }

 }
/// class RenderNestedScrollViewViewport extends RenderViewport
class RenderNestedScrollViewViewport$Mate extends RenderNestedScrollViewViewport with Mate {/// RenderNestedScrollViewViewport RenderNestedScrollViewViewport({AxisDirection axisDirection = AxisDirection.down, required AxisDirection crossAxisDirection, required ViewportOffset offset, double anchor = 0.0, List<RenderSliver>? children, RenderSliver? center, required SliverOverlapAbsorberHandle handle, Clip clipBehavior = Clip.hardEdge})
RenderNestedScrollViewViewport$Mate({/// optionalParameters: {AxisDirection axisDirection = AxisDirection.down} , hasDefaultValue:true, defaultValueCode:AxisDirection.down
required AxisDirection axisDirection, /// optionalParameters: {required AxisDirection crossAxisDirection} , hasDefaultValue:false, defaultValueCode:null
required AxisDirection crossAxisDirection, /// optionalParameters: {required ViewportOffset offset} , hasDefaultValue:false, defaultValueCode:null
required ViewportOffset offset, /// optionalParameters: {double anchor = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
required double anchor, /// optionalParameters: {List<RenderSliver>? children} , hasDefaultValue:false, defaultValueCode:null
List<RenderSliver>? children, /// optionalParameters: {RenderSliver? center} , hasDefaultValue:false, defaultValueCode:null
RenderSliver? center, /// optionalParameters: {required SliverOverlapAbsorberHandle handle} , hasDefaultValue:false, defaultValueCode:null
required SliverOverlapAbsorberHandle handle, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, }) : super(axisDirection: axisDirection, crossAxisDirection: crossAxisDirection, offset: offset, anchor: anchor, children: children, center: center, handle: handle, clipBehavior: clipBehavior, ) { mateBuilder = (p) => RenderNestedScrollViewViewport$Mate(axisDirection: p.get('axisDirection').build(), crossAxisDirection: p.get('crossAxisDirection').build(), offset: p.get('offset').build(), anchor: p.get('anchor').build(), children: p.get('children').build(), center: p.get('center').build(), handle: p.get('handle').build(), clipBehavior: p.get('clipBehavior').build(), );
matePut('axisDirection', axisDirection);
matePut('crossAxisDirection', crossAxisDirection);
matePut('offset', offset);
matePut('anchor', anchor);
matePut('children', children);
matePut('center', center);
matePut('handle', handle);
matePut('clipBehavior', clipBehavior); }

 }
