// /// Generated by gen_maters.dart, please don't edit! 

import 'package:flutter/src/widgets/basic.dart';import 'package:flutter/src/foundation/key.dart';import 'dart:ui';import 'package:flutter/src/widgets/framework.dart';import 'dart:core';import 'package:flutter/src/rendering/proxy_box.dart';import 'package:flutter/src/rendering/custom_paint.dart';import 'package:flutter/src/painting/border_radius.dart';import 'package:flutter/src/painting/box_border.dart';import 'package:vector_math/vector_math_64.dart';import 'package:flutter/src/painting/alignment.dart';import 'package:flutter/src/rendering/layer.dart';import 'package:flutter/src/painting/box_fit.dart';import 'package:flutter/src/painting/edge_insets.dart';import 'package:flutter/src/rendering/shifted_box.dart';import 'package:flutter/src/rendering/custom_layout.dart';import 'package:flutter/src/rendering/box.dart';import 'package:flutter/src/painting/basic_types.dart';import 'package:flutter/src/rendering/stack.dart';import 'package:flutter/src/rendering/flex.dart';import 'package:flutter/src/rendering/wrap.dart';import 'package:flutter/src/rendering/flow.dart';import 'package:flutter/src/painting/inline_span.dart';import 'package:flutter/src/painting/text_painter.dart';import 'package:flutter/src/painting/strut_style.dart';import 'package:flutter/src/rendering/selection.dart';import 'package:flutter/src/animation/animation.dart';import 'package:flutter/src/painting/decoration_image.dart';import 'package:flutter/src/services/asset_bundle.dart';import 'package:flutter/src/services/mouse_tracking.dart';import 'package:flutter/src/services/mouse_cursor.dart';import 'package:flutter/src/semantics/semantics.dart';import 'package:note/mate.dart' show Mate;export 'package:flutter/animation.dart';export 'package:flutter/painting.dart';/// class Directionality extends _UbiquitousInheritedWidget
class Directionality$Mate extends Directionality with Mate {/// Directionality Directionality({Key? key, required TextDirection textDirection, required Widget child})
Directionality$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required TextDirection textDirection} , hasDefaultValue:false, defaultValueCode:null
required TextDirection textDirection, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, textDirection: textDirection, child: child, ) { mateBuilder = (p) => Directionality$Mate(key: p.get('key').build(), textDirection: p.get('textDirection').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('textDirection', textDirection);
matePut('child', child); }

 }
/// class Opacity extends SingleChildRenderObjectWidget
class Opacity$Mate extends Opacity with Mate {/// Opacity Opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? child})
Opacity$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required double opacity} , hasDefaultValue:false, defaultValueCode:null
required double opacity, /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool alwaysIncludeSemantics, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, opacity: opacity, alwaysIncludeSemantics: alwaysIncludeSemantics, child: child, ) { mateBuilder = (p) => Opacity$Mate(key: p.get('key').build(), opacity: p.get('opacity').build(), alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('opacity', opacity);
matePut('alwaysIncludeSemantics', alwaysIncludeSemantics);
matePut('child', child); }

 }
/// class ShaderMask extends SingleChildRenderObjectWidget
class ShaderMask$Mate extends ShaderMask with Mate {/// ShaderMask ShaderMask({Key? key, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate, Widget? child})
ShaderMask$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Shader Function(Rect) shaderCallback} , hasDefaultValue:false, defaultValueCode:null
required ShaderCallback shaderCallback, /// optionalParameters: {BlendMode blendMode = BlendMode.modulate} , hasDefaultValue:true, defaultValueCode:BlendMode.modulate
required BlendMode blendMode, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, shaderCallback: shaderCallback, blendMode: blendMode, child: child, ) { mateBuilder = (p) => ShaderMask$Mate(key: p.get('key').build(), shaderCallback: p.get('shaderCallback').build(), blendMode: p.get('blendMode').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('shaderCallback', shaderCallback);
matePut('blendMode', blendMode);
matePut('child', child); }

 }
/// class BackdropFilter extends SingleChildRenderObjectWidget
class BackdropFilter$Mate extends BackdropFilter with Mate {/// BackdropFilter BackdropFilter({Key? key, required ImageFilter filter, Widget? child, BlendMode blendMode = BlendMode.srcOver})
BackdropFilter$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required ImageFilter filter} , hasDefaultValue:false, defaultValueCode:null
required ImageFilter filter, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {BlendMode blendMode = BlendMode.srcOver} , hasDefaultValue:true, defaultValueCode:BlendMode.srcOver
required BlendMode blendMode, }) : super(key: key, filter: filter, child: child, blendMode: blendMode, ) { mateBuilder = (p) => BackdropFilter$Mate(key: p.get('key').build(), filter: p.get('filter').build(), child: p.get('child').build(), blendMode: p.get('blendMode').build(), );
matePut('key', key);
matePut('filter', filter);
matePut('child', child);
matePut('blendMode', blendMode); }

 }
/// class CustomPaint extends SingleChildRenderObjectWidget
class CustomPaint$Mate extends CustomPaint with Mate {/// CustomPaint CustomPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false, Widget? child})
CustomPaint$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {CustomPainter? painter} , hasDefaultValue:false, defaultValueCode:null
CustomPainter? painter, /// optionalParameters: {CustomPainter? foregroundPainter} , hasDefaultValue:false, defaultValueCode:null
CustomPainter? foregroundPainter, /// optionalParameters: {Size size = Size.zero} , hasDefaultValue:true, defaultValueCode:Size.zero
required Size size, /// optionalParameters: {bool isComplex = false} , hasDefaultValue:true, defaultValueCode:false
required bool isComplex, /// optionalParameters: {bool willChange = false} , hasDefaultValue:true, defaultValueCode:false
required bool willChange, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, painter: painter, foregroundPainter: foregroundPainter, size: size, isComplex: isComplex, willChange: willChange, child: child, ) { mateBuilder = (p) => CustomPaint$Mate(key: p.get('key').build(), painter: p.get('painter').build(), foregroundPainter: p.get('foregroundPainter').build(), size: p.get('size').build(), isComplex: p.get('isComplex').build(), willChange: p.get('willChange').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('painter', painter);
matePut('foregroundPainter', foregroundPainter);
matePut('size', size);
matePut('isComplex', isComplex);
matePut('willChange', willChange);
matePut('child', child); }

 }
/// class ClipRect extends SingleChildRenderObjectWidget
class ClipRect$Mate extends ClipRect with Mate {/// ClipRect ClipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge, Widget? child})
ClipRect$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
CustomClipper<Rect>? clipper, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, clipper: clipper, clipBehavior: clipBehavior, child: child, ) { mateBuilder = (p) => ClipRect$Mate(key: p.get('key').build(), clipper: p.get('clipper').build(), clipBehavior: p.get('clipBehavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('clipper', clipper);
matePut('clipBehavior', clipBehavior);
matePut('child', child); }

 }
/// class ClipRRect extends SingleChildRenderObjectWidget
class ClipRRect$Mate extends ClipRRect with Mate {/// ClipRRect ClipRRect({Key? key, BorderRadiusGeometry? borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
ClipRRect$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {BorderRadiusGeometry? borderRadius = BorderRadius.zero} , hasDefaultValue:true, defaultValueCode:BorderRadius.zero
BorderRadiusGeometry? borderRadius, /// optionalParameters: {CustomClipper<RRect>? clipper} , hasDefaultValue:false, defaultValueCode:null
CustomClipper<RRect>? clipper, /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
required Clip clipBehavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, borderRadius: borderRadius, clipper: clipper, clipBehavior: clipBehavior, child: child, ) { mateBuilder = (p) => ClipRRect$Mate(key: p.get('key').build(), borderRadius: p.get('borderRadius').build(), clipper: p.get('clipper').build(), clipBehavior: p.get('clipBehavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('borderRadius', borderRadius);
matePut('clipper', clipper);
matePut('clipBehavior', clipBehavior);
matePut('child', child); }

 }
/// class ClipOval extends SingleChildRenderObjectWidget
class ClipOval$Mate extends ClipOval with Mate {/// ClipOval ClipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
ClipOval$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
CustomClipper<Rect>? clipper, /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
required Clip clipBehavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, clipper: clipper, clipBehavior: clipBehavior, child: child, ) { mateBuilder = (p) => ClipOval$Mate(key: p.get('key').build(), clipper: p.get('clipper').build(), clipBehavior: p.get('clipBehavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('clipper', clipper);
matePut('clipBehavior', clipBehavior);
matePut('child', child); }

 }
/// class ClipPath extends SingleChildRenderObjectWidget
class ClipPath$Mate extends ClipPath with Mate {/// ClipPath ClipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
ClipPath$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {CustomClipper<Path>? clipper} , hasDefaultValue:false, defaultValueCode:null
CustomClipper<Path>? clipper, /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
required Clip clipBehavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, clipper: clipper, clipBehavior: clipBehavior, child: child, ) { mateBuilder = (p) => ClipPath$Mate(key: p.get('key').build(), clipper: p.get('clipper').build(), clipBehavior: p.get('clipBehavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('clipper', clipper);
matePut('clipBehavior', clipBehavior);
matePut('child', child); }

 }
/// class PhysicalModel extends SingleChildRenderObjectWidget
class PhysicalModel$Mate extends PhysicalModel with Mate {/// PhysicalModel PhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
PhysicalModel$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {BoxShape shape = BoxShape.rectangle} , hasDefaultValue:true, defaultValueCode:BoxShape.rectangle
required BoxShape shape, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {BorderRadius? borderRadius} , hasDefaultValue:false, defaultValueCode:null
BorderRadius? borderRadius, /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
required double elevation, /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
required Color color, /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
required Color shadowColor, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, shape: shape, clipBehavior: clipBehavior, borderRadius: borderRadius, elevation: elevation, color: color, shadowColor: shadowColor, child: child, ) { mateBuilder = (p) => PhysicalModel$Mate(key: p.get('key').build(), shape: p.get('shape').build(), clipBehavior: p.get('clipBehavior').build(), borderRadius: p.get('borderRadius').build(), elevation: p.get('elevation').build(), color: p.get('color').build(), shadowColor: p.get('shadowColor').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('shape', shape);
matePut('clipBehavior', clipBehavior);
matePut('borderRadius', borderRadius);
matePut('elevation', elevation);
matePut('color', color);
matePut('shadowColor', shadowColor);
matePut('child', child); }

 }
/// class PhysicalShape extends SingleChildRenderObjectWidget
class PhysicalShape$Mate extends PhysicalShape with Mate {/// PhysicalShape PhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
PhysicalShape$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required CustomClipper<Path> clipper} , hasDefaultValue:false, defaultValueCode:null
required CustomClipper<Path> clipper, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
required double elevation, /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
required Color color, /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
required Color shadowColor, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, clipper: clipper, clipBehavior: clipBehavior, elevation: elevation, color: color, shadowColor: shadowColor, child: child, ) { mateBuilder = (p) => PhysicalShape$Mate(key: p.get('key').build(), clipper: p.get('clipper').build(), clipBehavior: p.get('clipBehavior').build(), elevation: p.get('elevation').build(), color: p.get('color').build(), shadowColor: p.get('shadowColor').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('clipper', clipper);
matePut('clipBehavior', clipBehavior);
matePut('elevation', elevation);
matePut('color', color);
matePut('shadowColor', shadowColor);
matePut('child', child); }

 }
/// class Transform extends SingleChildRenderObjectWidget
class Transform$Mate extends Transform with Mate {/// Transform Transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
Transform$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Matrix4 transform} , hasDefaultValue:false, defaultValueCode:null
required Matrix4 transform, /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
Offset? origin, /// optionalParameters: {AlignmentGeometry? alignment} , hasDefaultValue:false, defaultValueCode:null
AlignmentGeometry? alignment, /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
required bool transformHitTests, /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
FilterQuality? filterQuality, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, transform: transform, origin: origin, alignment: alignment, transformHitTests: transformHitTests, filterQuality: filterQuality, child: child, ) { mateBuilder = (p) => Transform$Mate(key: p.get('key').build(), transform: p.get('transform').build(), origin: p.get('origin').build(), alignment: p.get('alignment').build(), transformHitTests: p.get('transformHitTests').build(), filterQuality: p.get('filterQuality').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('transform', transform);
matePut('origin', origin);
matePut('alignment', alignment);
matePut('transformHitTests', transformHitTests);
matePut('filterQuality', filterQuality);
matePut('child', child); }

/// Transform Transform.rotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
Transform$Mate.rotate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required double angle} , hasDefaultValue:false, defaultValueCode:null
required double angle, /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
Offset? origin, /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
AlignmentGeometry? alignment, /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
required bool transformHitTests, /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
FilterQuality? filterQuality, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super.rotate(key: key, angle: angle, origin: origin, alignment: alignment, transformHitTests: transformHitTests, filterQuality: filterQuality, child: child, ) { mateBuilder = (p) => Transform$Mate.rotate(key: p.get('key').build(), angle: p.get('angle').build(), origin: p.get('origin').build(), alignment: p.get('alignment').build(), transformHitTests: p.get('transformHitTests').build(), filterQuality: p.get('filterQuality').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('angle', angle);
matePut('origin', origin);
matePut('alignment', alignment);
matePut('transformHitTests', transformHitTests);
matePut('filterQuality', filterQuality);
matePut('child', child); }

/// Transform Transform.translate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
Transform$Mate.translate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Offset offset} , hasDefaultValue:false, defaultValueCode:null
required Offset offset, /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
required bool transformHitTests, /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
FilterQuality? filterQuality, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super.translate(key: key, offset: offset, transformHitTests: transformHitTests, filterQuality: filterQuality, child: child, ) { mateBuilder = (p) => Transform$Mate.translate(key: p.get('key').build(), offset: p.get('offset').build(), transformHitTests: p.get('transformHitTests').build(), filterQuality: p.get('filterQuality').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('offset', offset);
matePut('transformHitTests', transformHitTests);
matePut('filterQuality', filterQuality);
matePut('child', child); }

/// Transform Transform.scale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
Transform$Mate.scale({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double? scale} , hasDefaultValue:false, defaultValueCode:null
double? scale, /// optionalParameters: {double? scaleX} , hasDefaultValue:false, defaultValueCode:null
double? scaleX, /// optionalParameters: {double? scaleY} , hasDefaultValue:false, defaultValueCode:null
double? scaleY, /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
Offset? origin, /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
AlignmentGeometry? alignment, /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
required bool transformHitTests, /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
FilterQuality? filterQuality, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super.scale(key: key, scale: scale, scaleX: scaleX, scaleY: scaleY, origin: origin, alignment: alignment, transformHitTests: transformHitTests, filterQuality: filterQuality, child: child, ) { mateBuilder = (p) => Transform$Mate.scale(key: p.get('key').build(), scale: p.get('scale').build(), scaleX: p.get('scaleX').build(), scaleY: p.get('scaleY').build(), origin: p.get('origin').build(), alignment: p.get('alignment').build(), transformHitTests: p.get('transformHitTests').build(), filterQuality: p.get('filterQuality').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('scale', scale);
matePut('scaleX', scaleX);
matePut('scaleY', scaleY);
matePut('origin', origin);
matePut('alignment', alignment);
matePut('transformHitTests', transformHitTests);
matePut('filterQuality', filterQuality);
matePut('child', child); }

/// Transform Transform.flip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
Transform$Mate.flip({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {bool flipX = false} , hasDefaultValue:true, defaultValueCode:false
required bool flipX, /// optionalParameters: {bool flipY = false} , hasDefaultValue:true, defaultValueCode:false
required bool flipY, /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
Offset? origin, /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
required bool transformHitTests, /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
FilterQuality? filterQuality, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super.flip(key: key, flipX: flipX, flipY: flipY, origin: origin, transformHitTests: transformHitTests, filterQuality: filterQuality, child: child, ) { mateBuilder = (p) => Transform$Mate.flip(key: p.get('key').build(), flipX: p.get('flipX').build(), flipY: p.get('flipY').build(), origin: p.get('origin').build(), transformHitTests: p.get('transformHitTests').build(), filterQuality: p.get('filterQuality').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('flipX', flipX);
matePut('flipY', flipY);
matePut('origin', origin);
matePut('transformHitTests', transformHitTests);
matePut('filterQuality', filterQuality);
matePut('child', child); }

 }
/// class CompositedTransformTarget extends SingleChildRenderObjectWidget
class CompositedTransformTarget$Mate extends CompositedTransformTarget with Mate {/// CompositedTransformTarget CompositedTransformTarget({Key? key, required LayerLink link, Widget? child})
CompositedTransformTarget$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
required LayerLink link, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, link: link, child: child, ) { mateBuilder = (p) => CompositedTransformTarget$Mate(key: p.get('key').build(), link: p.get('link').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('link', link);
matePut('child', child); }

 }
/// class CompositedTransformFollower extends SingleChildRenderObjectWidget
class CompositedTransformFollower$Mate extends CompositedTransformFollower with Mate {/// CompositedTransformFollower CompositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, Widget? child})
CompositedTransformFollower$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
required LayerLink link, /// optionalParameters: {bool showWhenUnlinked = true} , hasDefaultValue:true, defaultValueCode:true
required bool showWhenUnlinked, /// optionalParameters: {Offset offset = Offset.zero} , hasDefaultValue:true, defaultValueCode:Offset.zero
required Offset offset, /// optionalParameters: {Alignment targetAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
required Alignment targetAnchor, /// optionalParameters: {Alignment followerAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
required Alignment followerAnchor, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, link: link, showWhenUnlinked: showWhenUnlinked, offset: offset, targetAnchor: targetAnchor, followerAnchor: followerAnchor, child: child, ) { mateBuilder = (p) => CompositedTransformFollower$Mate(key: p.get('key').build(), link: p.get('link').build(), showWhenUnlinked: p.get('showWhenUnlinked').build(), offset: p.get('offset').build(), targetAnchor: p.get('targetAnchor').build(), followerAnchor: p.get('followerAnchor').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('link', link);
matePut('showWhenUnlinked', showWhenUnlinked);
matePut('offset', offset);
matePut('targetAnchor', targetAnchor);
matePut('followerAnchor', followerAnchor);
matePut('child', child); }

 }
/// class FittedBox extends SingleChildRenderObjectWidget
class FittedBox$Mate extends FittedBox with Mate {/// FittedBox FittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})
FittedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {BoxFit fit = BoxFit.contain} , hasDefaultValue:true, defaultValueCode:BoxFit.contain
required BoxFit fit, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, fit: fit, alignment: alignment, clipBehavior: clipBehavior, child: child, ) { mateBuilder = (p) => FittedBox$Mate(key: p.get('key').build(), fit: p.get('fit').build(), alignment: p.get('alignment').build(), clipBehavior: p.get('clipBehavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('fit', fit);
matePut('alignment', alignment);
matePut('clipBehavior', clipBehavior);
matePut('child', child); }

 }
/// class FractionalTranslation extends SingleChildRenderObjectWidget
class FractionalTranslation$Mate extends FractionalTranslation with Mate {/// FractionalTranslation FractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true, Widget? child})
FractionalTranslation$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Offset translation} , hasDefaultValue:false, defaultValueCode:null
required Offset translation, /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
required bool transformHitTests, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, translation: translation, transformHitTests: transformHitTests, child: child, ) { mateBuilder = (p) => FractionalTranslation$Mate(key: p.get('key').build(), translation: p.get('translation').build(), transformHitTests: p.get('transformHitTests').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('translation', translation);
matePut('transformHitTests', transformHitTests);
matePut('child', child); }

 }
/// class RotatedBox extends SingleChildRenderObjectWidget
class RotatedBox$Mate extends RotatedBox with Mate {/// RotatedBox RotatedBox({Key? key, required int quarterTurns, Widget? child})
RotatedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required int quarterTurns} , hasDefaultValue:false, defaultValueCode:null
required int quarterTurns, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, quarterTurns: quarterTurns, child: child, ) { mateBuilder = (p) => RotatedBox$Mate(key: p.get('key').build(), quarterTurns: p.get('quarterTurns').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('quarterTurns', quarterTurns);
matePut('child', child); }

 }
/// class Padding extends SingleChildRenderObjectWidget
class Padding$Mate extends Padding with Mate {/// Padding Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})
Padding$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required EdgeInsetsGeometry padding} , hasDefaultValue:false, defaultValueCode:null
required EdgeInsetsGeometry padding, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, padding: padding, child: child, ) { mateBuilder = (p) => Padding$Mate(key: p.get('key').build(), padding: p.get('padding').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('padding', padding);
matePut('child', child); }

 }
/// class Align extends SingleChildRenderObjectWidget
class Align$Mate extends Align with Mate {/// Align Align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
Align$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
double? widthFactor, /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
double? heightFactor, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, alignment: alignment, widthFactor: widthFactor, heightFactor: heightFactor, child: child, ) { mateBuilder = (p) => Align$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), widthFactor: p.get('widthFactor').build(), heightFactor: p.get('heightFactor').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('widthFactor', widthFactor);
matePut('heightFactor', heightFactor);
matePut('child', child); }

 }
/// class Center extends Align
class Center$Mate extends Center with Mate {/// Center Center({Key? key, double? widthFactor, double? heightFactor, Widget? child})
Center$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
double? widthFactor, /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
double? heightFactor, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, widthFactor: widthFactor, heightFactor: heightFactor, child: child, ) { mateBuilder = (p) => Center$Mate(key: p.get('key').build(), widthFactor: p.get('widthFactor').build(), heightFactor: p.get('heightFactor').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('widthFactor', widthFactor);
matePut('heightFactor', heightFactor);
matePut('child', child); }

 }
/// class CustomSingleChildLayout extends SingleChildRenderObjectWidget
class CustomSingleChildLayout$Mate extends CustomSingleChildLayout with Mate {/// CustomSingleChildLayout CustomSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate, Widget? child})
CustomSingleChildLayout$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required SingleChildLayoutDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
required SingleChildLayoutDelegate delegate, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, delegate: delegate, child: child, ) { mateBuilder = (p) => CustomSingleChildLayout$Mate(key: p.get('key').build(), delegate: p.get('delegate').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('delegate', delegate);
matePut('child', child); }

 }
/// class LayoutId extends ParentDataWidget<MultiChildLayoutParentData>
class LayoutId$Mate extends LayoutId with Mate {/// LayoutId LayoutId({Key? key, required Object id, required Widget child})
LayoutId$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Object id} , hasDefaultValue:false, defaultValueCode:null
required Object id, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, id: id, child: child, ) { mateBuilder = (p) => LayoutId$Mate(key: p.get('key').build(), id: p.get('id').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('id', id);
matePut('child', child); }

 }
/// class CustomMultiChildLayout extends MultiChildRenderObjectWidget
class CustomMultiChildLayout$Mate extends CustomMultiChildLayout with Mate {/// CustomMultiChildLayout CustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})
CustomMultiChildLayout$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required MultiChildLayoutDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
required MultiChildLayoutDelegate delegate, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, delegate: delegate, children: children, ) { mateBuilder = (p) => CustomMultiChildLayout$Mate(key: p.get('key').build(), delegate: p.get('delegate').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('delegate', delegate);
matePut('children', children); }

 }
/// class SizedBox extends SingleChildRenderObjectWidget
class SizedBox$Mate extends SizedBox with Mate {/// SizedBox SizedBox({Key? key, double? width, double? height, Widget? child})
SizedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, width: width, height: height, child: child, ) { mateBuilder = (p) => SizedBox$Mate(key: p.get('key').build(), width: p.get('width').build(), height: p.get('height').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('width', width);
matePut('height', height);
matePut('child', child); }

/// SizedBox SizedBox.expand({Key? key, Widget? child})
SizedBox$Mate.expand({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super.expand(key: key, child: child, ) { mateBuilder = (p) => SizedBox$Mate.expand(key: p.get('key').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('child', child); }

/// SizedBox SizedBox.shrink({Key? key, Widget? child})
SizedBox$Mate.shrink({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super.shrink(key: key, child: child, ) { mateBuilder = (p) => SizedBox$Mate.shrink(key: p.get('key').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('child', child); }

/// SizedBox SizedBox.fromSize({Key? key, Widget? child, Size? size})
SizedBox$Mate.fromSize({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {Size? size} , hasDefaultValue:false, defaultValueCode:null
Size? size, }) : super.fromSize(key: key, child: child, size: size, ) { mateBuilder = (p) => SizedBox$Mate.fromSize(key: p.get('key').build(), child: p.get('child').build(), size: p.get('size').build(), );
matePut('key', key);
matePut('child', child);
matePut('size', size); }

/// SizedBox SizedBox.square({Key? key, Widget? child, double? dimension})
SizedBox$Mate.square({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {double? dimension} , hasDefaultValue:false, defaultValueCode:null
double? dimension, }) : super.square(key: key, child: child, dimension: dimension, ) { mateBuilder = (p) => SizedBox$Mate.square(key: p.get('key').build(), child: p.get('child').build(), dimension: p.get('dimension').build(), );
matePut('key', key);
matePut('child', child);
matePut('dimension', dimension); }

 }
/// class ConstrainedBox extends SingleChildRenderObjectWidget
class ConstrainedBox$Mate extends ConstrainedBox with Mate {/// ConstrainedBox ConstrainedBox({Key? key, required BoxConstraints constraints, Widget? child})
ConstrainedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required BoxConstraints constraints} , hasDefaultValue:false, defaultValueCode:null
required BoxConstraints constraints, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, constraints: constraints, child: child, ) { mateBuilder = (p) => ConstrainedBox$Mate(key: p.get('key').build(), constraints: p.get('constraints').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('constraints', constraints);
matePut('child', child); }

 }
/// class ConstraintsTransformBox extends SingleChildRenderObjectWidget
class ConstraintsTransformBox$Mate extends ConstraintsTransformBox with Mate {/// ConstraintsTransformBox ConstraintsTransformBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraints Function(BoxConstraints) constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = ''})
ConstraintsTransformBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {required BoxConstraints Function(BoxConstraints) constraintsTransform} , hasDefaultValue:false, defaultValueCode:null
required BoxConstraintsTransform constraintsTransform, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {String debugTransformType = ''} , hasDefaultValue:true, defaultValueCode:''
required String debugTransformType, }) : super(key: key, child: child, textDirection: textDirection, alignment: alignment, constraintsTransform: constraintsTransform, clipBehavior: clipBehavior, debugTransformType: debugTransformType, ) { mateBuilder = (p) => ConstraintsTransformBox$Mate(key: p.get('key').build(), child: p.get('child').build(), textDirection: p.get('textDirection').build(), alignment: p.get('alignment').build(), constraintsTransform: p.get('constraintsTransform').build(), clipBehavior: p.get('clipBehavior').build(), debugTransformType: p.get('debugTransformType').build(), );
matePut('key', key);
matePut('child', child);
matePut('textDirection', textDirection);
matePut('alignment', alignment);
matePut('constraintsTransform', constraintsTransform);
matePut('clipBehavior', clipBehavior);
matePut('debugTransformType', debugTransformType); }

 }
/// class UnconstrainedBox extends StatelessWidget
class UnconstrainedBox$Mate extends UnconstrainedBox with Mate {/// UnconstrainedBox UnconstrainedBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none})
UnconstrainedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {Axis? constrainedAxis} , hasDefaultValue:false, defaultValueCode:null
Axis? constrainedAxis, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, }) : super(key: key, child: child, textDirection: textDirection, alignment: alignment, constrainedAxis: constrainedAxis, clipBehavior: clipBehavior, ) { mateBuilder = (p) => UnconstrainedBox$Mate(key: p.get('key').build(), child: p.get('child').build(), textDirection: p.get('textDirection').build(), alignment: p.get('alignment').build(), constrainedAxis: p.get('constrainedAxis').build(), clipBehavior: p.get('clipBehavior').build(), );
matePut('key', key);
matePut('child', child);
matePut('textDirection', textDirection);
matePut('alignment', alignment);
matePut('constrainedAxis', constrainedAxis);
matePut('clipBehavior', clipBehavior); }

 }
/// class FractionallySizedBox extends SingleChildRenderObjectWidget
class FractionallySizedBox$Mate extends FractionallySizedBox with Mate {/// FractionallySizedBox FractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
FractionallySizedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {double? widthFactor} , hasDefaultValue:false, defaultValueCode:null
double? widthFactor, /// optionalParameters: {double? heightFactor} , hasDefaultValue:false, defaultValueCode:null
double? heightFactor, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, alignment: alignment, widthFactor: widthFactor, heightFactor: heightFactor, child: child, ) { mateBuilder = (p) => FractionallySizedBox$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), widthFactor: p.get('widthFactor').build(), heightFactor: p.get('heightFactor').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('widthFactor', widthFactor);
matePut('heightFactor', heightFactor);
matePut('child', child); }

 }
/// class LimitedBox extends SingleChildRenderObjectWidget
class LimitedBox$Mate extends LimitedBox with Mate {/// LimitedBox LimitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity, Widget? child})
LimitedBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double maxWidth = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
required double maxWidth, /// optionalParameters: {double maxHeight = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
required double maxHeight, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, maxWidth: maxWidth, maxHeight: maxHeight, child: child, ) { mateBuilder = (p) => LimitedBox$Mate(key: p.get('key').build(), maxWidth: p.get('maxWidth').build(), maxHeight: p.get('maxHeight').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('maxWidth', maxWidth);
matePut('maxHeight', maxHeight);
matePut('child', child); }

 }
/// class OverflowBox extends SingleChildRenderObjectWidget
class OverflowBox$Mate extends OverflowBox with Mate {/// OverflowBox OverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})
OverflowBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {double? minWidth} , hasDefaultValue:false, defaultValueCode:null
double? minWidth, /// optionalParameters: {double? maxWidth} , hasDefaultValue:false, defaultValueCode:null
double? maxWidth, /// optionalParameters: {double? minHeight} , hasDefaultValue:false, defaultValueCode:null
double? minHeight, /// optionalParameters: {double? maxHeight} , hasDefaultValue:false, defaultValueCode:null
double? maxHeight, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, alignment: alignment, minWidth: minWidth, maxWidth: maxWidth, minHeight: minHeight, maxHeight: maxHeight, child: child, ) { mateBuilder = (p) => OverflowBox$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), minWidth: p.get('minWidth').build(), maxWidth: p.get('maxWidth').build(), minHeight: p.get('minHeight').build(), maxHeight: p.get('maxHeight').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('minWidth', minWidth);
matePut('maxWidth', maxWidth);
matePut('minHeight', minHeight);
matePut('maxHeight', maxHeight);
matePut('child', child); }

 }
/// class SizedOverflowBox extends SingleChildRenderObjectWidget
class SizedOverflowBox$Mate extends SizedOverflowBox with Mate {/// SizedOverflowBox SizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center, Widget? child})
SizedOverflowBox$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Size size} , hasDefaultValue:false, defaultValueCode:null
required Size size, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, size: size, alignment: alignment, child: child, ) { mateBuilder = (p) => SizedOverflowBox$Mate(key: p.get('key').build(), size: p.get('size').build(), alignment: p.get('alignment').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('size', size);
matePut('alignment', alignment);
matePut('child', child); }

 }
/// class Offstage extends SingleChildRenderObjectWidget
class Offstage$Mate extends Offstage with Mate {/// Offstage Offstage({Key? key, bool offstage = true, Widget? child})
Offstage$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {bool offstage = true} , hasDefaultValue:true, defaultValueCode:true
required bool offstage, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, offstage: offstage, child: child, ) { mateBuilder = (p) => Offstage$Mate(key: p.get('key').build(), offstage: p.get('offstage').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('offstage', offstage);
matePut('child', child); }

 }
/// class AspectRatio extends SingleChildRenderObjectWidget
class AspectRatio$Mate extends AspectRatio with Mate {/// AspectRatio AspectRatio({Key? key, required double aspectRatio, Widget? child})
AspectRatio$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required double aspectRatio} , hasDefaultValue:false, defaultValueCode:null
required double aspectRatio, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, aspectRatio: aspectRatio, child: child, ) { mateBuilder = (p) => AspectRatio$Mate(key: p.get('key').build(), aspectRatio: p.get('aspectRatio').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('aspectRatio', aspectRatio);
matePut('child', child); }

 }
/// class IntrinsicWidth extends SingleChildRenderObjectWidget
class IntrinsicWidth$Mate extends IntrinsicWidth with Mate {/// IntrinsicWidth IntrinsicWidth({Key? key, double? stepWidth, double? stepHeight, Widget? child})
IntrinsicWidth$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double? stepWidth} , hasDefaultValue:false, defaultValueCode:null
double? stepWidth, /// optionalParameters: {double? stepHeight} , hasDefaultValue:false, defaultValueCode:null
double? stepHeight, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, stepWidth: stepWidth, stepHeight: stepHeight, child: child, ) { mateBuilder = (p) => IntrinsicWidth$Mate(key: p.get('key').build(), stepWidth: p.get('stepWidth').build(), stepHeight: p.get('stepHeight').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('stepWidth', stepWidth);
matePut('stepHeight', stepHeight);
matePut('child', child); }

 }
/// class IntrinsicHeight extends SingleChildRenderObjectWidget
class IntrinsicHeight$Mate extends IntrinsicHeight with Mate {/// IntrinsicHeight IntrinsicHeight({Key? key, Widget? child})
IntrinsicHeight$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, child: child, ) { mateBuilder = (p) => IntrinsicHeight$Mate(key: p.get('key').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('child', child); }

 }
/// class Baseline extends SingleChildRenderObjectWidget
class Baseline$Mate extends Baseline with Mate {/// Baseline Baseline({Key? key, required double baseline, required TextBaseline baselineType, Widget? child})
Baseline$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required double baseline} , hasDefaultValue:false, defaultValueCode:null
required double baseline, /// optionalParameters: {required TextBaseline baselineType} , hasDefaultValue:false, defaultValueCode:null
required TextBaseline baselineType, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, baseline: baseline, baselineType: baselineType, child: child, ) { mateBuilder = (p) => Baseline$Mate(key: p.get('key').build(), baseline: p.get('baseline').build(), baselineType: p.get('baselineType').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('baseline', baseline);
matePut('baselineType', baselineType);
matePut('child', child); }

 }
/// class SliverToBoxAdapter extends SingleChildRenderObjectWidget
class SliverToBoxAdapter$Mate extends SliverToBoxAdapter with Mate {/// SliverToBoxAdapter SliverToBoxAdapter({Key? key, Widget? child})
SliverToBoxAdapter$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, child: child, ) { mateBuilder = (p) => SliverToBoxAdapter$Mate(key: p.get('key').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('child', child); }

 }
/// class SliverPadding extends SingleChildRenderObjectWidget
class SliverPadding$Mate extends SliverPadding with Mate {/// SliverPadding SliverPadding({Key? key, required EdgeInsetsGeometry padding, Widget? sliver})
SliverPadding$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required EdgeInsetsGeometry padding} , hasDefaultValue:false, defaultValueCode:null
required EdgeInsetsGeometry padding, /// optionalParameters: {Widget? sliver} , hasDefaultValue:false, defaultValueCode:null
Widget? sliver, }) : super(key: key, padding: padding, sliver: sliver, ) { mateBuilder = (p) => SliverPadding$Mate(key: p.get('key').build(), padding: p.get('padding').build(), sliver: p.get('sliver').build(), );
matePut('key', key);
matePut('padding', padding);
matePut('sliver', sliver); }

 }
/// class ListBody extends MultiChildRenderObjectWidget
class ListBody$Mate extends ListBody with Mate {/// ListBody ListBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false, List<Widget> children = const <Widget>[]})
ListBody$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Axis mainAxis = Axis.vertical} , hasDefaultValue:true, defaultValueCode:Axis.vertical
required Axis mainAxis, /// optionalParameters: {bool reverse = false} , hasDefaultValue:true, defaultValueCode:false
required bool reverse, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, mainAxis: mainAxis, reverse: reverse, children: children, ) { mateBuilder = (p) => ListBody$Mate(key: p.get('key').build(), mainAxis: p.get('mainAxis').build(), reverse: p.get('reverse').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('mainAxis', mainAxis);
matePut('reverse', reverse);
matePut('children', children); }

 }
/// class Stack extends MultiChildRenderObjectWidget
class Stack$Mate extends Stack with Mate {/// Stack Stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]})
Stack$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , hasDefaultValue:true, defaultValueCode:AlignmentDirectional.topStart
required AlignmentGeometry alignment, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {StackFit fit = StackFit.loose} , hasDefaultValue:true, defaultValueCode:StackFit.loose
required StackFit fit, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, alignment: alignment, textDirection: textDirection, fit: fit, clipBehavior: clipBehavior, children: children, ) { mateBuilder = (p) => Stack$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), textDirection: p.get('textDirection').build(), fit: p.get('fit').build(), clipBehavior: p.get('clipBehavior').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('textDirection', textDirection);
matePut('fit', fit);
matePut('clipBehavior', clipBehavior);
matePut('children', children); }

 }
/// class IndexedStack extends Stack
class IndexedStack$Mate extends IndexedStack with Mate {/// IndexedStack IndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})
IndexedStack$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , hasDefaultValue:true, defaultValueCode:AlignmentDirectional.topStart
required AlignmentGeometry alignment, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, /// optionalParameters: {StackFit sizing = StackFit.loose} , hasDefaultValue:true, defaultValueCode:StackFit.loose
required StackFit sizing, /// optionalParameters: {int? index = 0} , hasDefaultValue:true, defaultValueCode:0
int? index, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, alignment: alignment, textDirection: textDirection, clipBehavior: clipBehavior, sizing: sizing, index: index, children: children, ) { mateBuilder = (p) => IndexedStack$Mate(key: p.get('key').build(), alignment: p.get('alignment').build(), textDirection: p.get('textDirection').build(), clipBehavior: p.get('clipBehavior').build(), sizing: p.get('sizing').build(), index: p.get('index').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('alignment', alignment);
matePut('textDirection', textDirection);
matePut('clipBehavior', clipBehavior);
matePut('sizing', sizing);
matePut('index', index);
matePut('children', children); }

 }
/// class Positioned extends ParentDataWidget<StackParentData>
class Positioned$Mate extends Positioned with Mate {/// Positioned Positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, required Widget child})
Positioned$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double? left} , hasDefaultValue:false, defaultValueCode:null
double? left, /// optionalParameters: {double? top} , hasDefaultValue:false, defaultValueCode:null
double? top, /// optionalParameters: {double? right} , hasDefaultValue:false, defaultValueCode:null
double? right, /// optionalParameters: {double? bottom} , hasDefaultValue:false, defaultValueCode:null
double? bottom, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, left: left, top: top, right: right, bottom: bottom, width: width, height: height, child: child, ) { mateBuilder = (p) => Positioned$Mate(key: p.get('key').build(), left: p.get('left').build(), top: p.get('top').build(), right: p.get('right').build(), bottom: p.get('bottom').build(), width: p.get('width').build(), height: p.get('height').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('left', left);
matePut('top', top);
matePut('right', right);
matePut('bottom', bottom);
matePut('width', width);
matePut('height', height);
matePut('child', child); }

/// Positioned Positioned.fromRect({Key? key, required Rect rect, required Widget child})
Positioned$Mate.fromRect({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Rect rect} , hasDefaultValue:false, defaultValueCode:null
required Rect rect, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super.fromRect(key: key, rect: rect, child: child, ) { mateBuilder = (p) => Positioned$Mate.fromRect(key: p.get('key').build(), rect: p.get('rect').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('rect', rect);
matePut('child', child); }

/// Positioned Positioned.fromRelativeRect({Key? key, required RelativeRect rect, required Widget child})
Positioned$Mate.fromRelativeRect({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required RelativeRect rect} , hasDefaultValue:false, defaultValueCode:null
required RelativeRect rect, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super.fromRelativeRect(key: key, rect: rect, child: child, ) { mateBuilder = (p) => Positioned$Mate.fromRelativeRect(key: p.get('key').build(), rect: p.get('rect').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('rect', rect);
matePut('child', child); }

/// Positioned Positioned.fill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0, required Widget child})
Positioned$Mate.fill({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double? left = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
double? left, /// optionalParameters: {double? top = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
double? top, /// optionalParameters: {double? right = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
double? right, /// optionalParameters: {double? bottom = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
double? bottom, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super.fill(key: key, left: left, top: top, right: right, bottom: bottom, child: child, ) { mateBuilder = (p) => Positioned$Mate.fill(key: p.get('key').build(), left: p.get('left').build(), top: p.get('top').build(), right: p.get('right').build(), bottom: p.get('bottom').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('left', left);
matePut('top', top);
matePut('right', right);
matePut('bottom', bottom);
matePut('child', child); }

 }
/// class PositionedDirectional extends StatelessWidget
class PositionedDirectional$Mate extends PositionedDirectional with Mate {/// PositionedDirectional PositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child})
PositionedDirectional$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double? start} , hasDefaultValue:false, defaultValueCode:null
double? start, /// optionalParameters: {double? top} , hasDefaultValue:false, defaultValueCode:null
double? top, /// optionalParameters: {double? end} , hasDefaultValue:false, defaultValueCode:null
double? end, /// optionalParameters: {double? bottom} , hasDefaultValue:false, defaultValueCode:null
double? bottom, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, start: start, top: top, end: end, bottom: bottom, width: width, height: height, child: child, ) { mateBuilder = (p) => PositionedDirectional$Mate(key: p.get('key').build(), start: p.get('start').build(), top: p.get('top').build(), end: p.get('end').build(), bottom: p.get('bottom').build(), width: p.get('width').build(), height: p.get('height').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('start', start);
matePut('top', top);
matePut('end', end);
matePut('bottom', bottom);
matePut('width', width);
matePut('height', height);
matePut('child', child); }

 }
/// class Flex extends MultiChildRenderObjectWidget
class Flex$Mate extends Flex with Mate {/// Flex Flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
Flex$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Axis direction} , hasDefaultValue:false, defaultValueCode:null
required Axis direction, /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , hasDefaultValue:true, defaultValueCode:MainAxisAlignment.start
required MainAxisAlignment mainAxisAlignment, /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , hasDefaultValue:true, defaultValueCode:MainAxisSize.max
required MainAxisSize mainAxisSize, /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , hasDefaultValue:true, defaultValueCode:CrossAxisAlignment.center
required CrossAxisAlignment crossAxisAlignment, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
required VerticalDirection verticalDirection, /// optionalParameters: {TextBaseline? textBaseline} , hasDefaultValue:false, defaultValueCode:null
TextBaseline? textBaseline, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, direction: direction, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline, clipBehavior: clipBehavior, children: children, ) { mateBuilder = (p) => Flex$Mate(key: p.get('key').build(), direction: p.get('direction').build(), mainAxisAlignment: p.get('mainAxisAlignment').build(), mainAxisSize: p.get('mainAxisSize').build(), crossAxisAlignment: p.get('crossAxisAlignment').build(), textDirection: p.get('textDirection').build(), verticalDirection: p.get('verticalDirection').build(), textBaseline: p.get('textBaseline').build(), clipBehavior: p.get('clipBehavior').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('direction', direction);
matePut('mainAxisAlignment', mainAxisAlignment);
matePut('mainAxisSize', mainAxisSize);
matePut('crossAxisAlignment', crossAxisAlignment);
matePut('textDirection', textDirection);
matePut('verticalDirection', verticalDirection);
matePut('textBaseline', textBaseline);
matePut('clipBehavior', clipBehavior);
matePut('children', children); }

 }
/// class Row extends Flex
class Row$Mate extends Row with Mate {/// Row Row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
Row$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , hasDefaultValue:true, defaultValueCode:MainAxisAlignment.start
required MainAxisAlignment mainAxisAlignment, /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , hasDefaultValue:true, defaultValueCode:MainAxisSize.max
required MainAxisSize mainAxisSize, /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , hasDefaultValue:true, defaultValueCode:CrossAxisAlignment.center
required CrossAxisAlignment crossAxisAlignment, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
required VerticalDirection verticalDirection, /// optionalParameters: {TextBaseline? textBaseline} , hasDefaultValue:false, defaultValueCode:null
TextBaseline? textBaseline, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline, children: children, ) { mateBuilder = (p) => Row$Mate(key: p.get('key').build(), mainAxisAlignment: p.get('mainAxisAlignment').build(), mainAxisSize: p.get('mainAxisSize').build(), crossAxisAlignment: p.get('crossAxisAlignment').build(), textDirection: p.get('textDirection').build(), verticalDirection: p.get('verticalDirection').build(), textBaseline: p.get('textBaseline').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('mainAxisAlignment', mainAxisAlignment);
matePut('mainAxisSize', mainAxisSize);
matePut('crossAxisAlignment', crossAxisAlignment);
matePut('textDirection', textDirection);
matePut('verticalDirection', verticalDirection);
matePut('textBaseline', textBaseline);
matePut('children', children); }

 }
/// class Column extends Flex
class Column$Mate extends Column with Mate {/// Column Column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
Column$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , hasDefaultValue:true, defaultValueCode:MainAxisAlignment.start
required MainAxisAlignment mainAxisAlignment, /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , hasDefaultValue:true, defaultValueCode:MainAxisSize.max
required MainAxisSize mainAxisSize, /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , hasDefaultValue:true, defaultValueCode:CrossAxisAlignment.center
required CrossAxisAlignment crossAxisAlignment, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
required VerticalDirection verticalDirection, /// optionalParameters: {TextBaseline? textBaseline} , hasDefaultValue:false, defaultValueCode:null
TextBaseline? textBaseline, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, mainAxisAlignment: mainAxisAlignment, mainAxisSize: mainAxisSize, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, textBaseline: textBaseline, children: children, ) { mateBuilder = (p) => Column$Mate(key: p.get('key').build(), mainAxisAlignment: p.get('mainAxisAlignment').build(), mainAxisSize: p.get('mainAxisSize').build(), crossAxisAlignment: p.get('crossAxisAlignment').build(), textDirection: p.get('textDirection').build(), verticalDirection: p.get('verticalDirection').build(), textBaseline: p.get('textBaseline').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('mainAxisAlignment', mainAxisAlignment);
matePut('mainAxisSize', mainAxisSize);
matePut('crossAxisAlignment', crossAxisAlignment);
matePut('textDirection', textDirection);
matePut('verticalDirection', verticalDirection);
matePut('textBaseline', textBaseline);
matePut('children', children); }

 }
/// class Flexible extends ParentDataWidget<FlexParentData>
class Flexible$Mate extends Flexible with Mate {/// Flexible Flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose, required Widget child})
Flexible$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {int flex = 1} , hasDefaultValue:true, defaultValueCode:1
required int flex, /// optionalParameters: {FlexFit fit = FlexFit.loose} , hasDefaultValue:true, defaultValueCode:FlexFit.loose
required FlexFit fit, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, flex: flex, fit: fit, child: child, ) { mateBuilder = (p) => Flexible$Mate(key: p.get('key').build(), flex: p.get('flex').build(), fit: p.get('fit').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('flex', flex);
matePut('fit', fit);
matePut('child', child); }

 }
/// class Expanded extends Flexible
class Expanded$Mate extends Expanded with Mate {/// Expanded Expanded({Key? key, int flex = 1, required Widget child})
Expanded$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {int flex = 1} , hasDefaultValue:true, defaultValueCode:1
required int flex, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, flex: flex, child: child, ) { mateBuilder = (p) => Expanded$Mate(key: p.get('key').build(), flex: p.get('flex').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('flex', flex);
matePut('child', child); }

 }
/// class Wrap extends MultiChildRenderObjectWidget
class Wrap$Mate extends Wrap with Mate {/// Wrap Wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
Wrap$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Axis direction = Axis.horizontal} , hasDefaultValue:true, defaultValueCode:Axis.horizontal
required Axis direction, /// optionalParameters: {WrapAlignment alignment = WrapAlignment.start} , hasDefaultValue:true, defaultValueCode:WrapAlignment.start
required WrapAlignment alignment, /// optionalParameters: {double spacing = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
required double spacing, /// optionalParameters: {WrapAlignment runAlignment = WrapAlignment.start} , hasDefaultValue:true, defaultValueCode:WrapAlignment.start
required WrapAlignment runAlignment, /// optionalParameters: {double runSpacing = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
required double runSpacing, /// optionalParameters: {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start} , hasDefaultValue:true, defaultValueCode:WrapCrossAlignment.start
required WrapCrossAlignment crossAxisAlignment, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , hasDefaultValue:true, defaultValueCode:VerticalDirection.down
required VerticalDirection verticalDirection, /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
required Clip clipBehavior, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, }) : super(key: key, direction: direction, alignment: alignment, spacing: spacing, runAlignment: runAlignment, runSpacing: runSpacing, crossAxisAlignment: crossAxisAlignment, textDirection: textDirection, verticalDirection: verticalDirection, clipBehavior: clipBehavior, children: children, ) { mateBuilder = (p) => Wrap$Mate(key: p.get('key').build(), direction: p.get('direction').build(), alignment: p.get('alignment').build(), spacing: p.get('spacing').build(), runAlignment: p.get('runAlignment').build(), runSpacing: p.get('runSpacing').build(), crossAxisAlignment: p.get('crossAxisAlignment').build(), textDirection: p.get('textDirection').build(), verticalDirection: p.get('verticalDirection').build(), clipBehavior: p.get('clipBehavior').build(), children: p.get('children').build(), );
matePut('key', key);
matePut('direction', direction);
matePut('alignment', alignment);
matePut('spacing', spacing);
matePut('runAlignment', runAlignment);
matePut('runSpacing', runSpacing);
matePut('crossAxisAlignment', crossAxisAlignment);
matePut('textDirection', textDirection);
matePut('verticalDirection', verticalDirection);
matePut('clipBehavior', clipBehavior);
matePut('children', children); }

 }
/// class Flow extends MultiChildRenderObjectWidget
class Flow$Mate extends Flow with Mate {/// Flow Flow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
Flow$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required FlowDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
required FlowDelegate delegate, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, }) : super(key: key, delegate: delegate, children: children, clipBehavior: clipBehavior, ) { mateBuilder = (p) => Flow$Mate(key: p.get('key').build(), delegate: p.get('delegate').build(), children: p.get('children').build(), clipBehavior: p.get('clipBehavior').build(), );
matePut('key', key);
matePut('delegate', delegate);
matePut('children', children);
matePut('clipBehavior', clipBehavior); }

/// Flow Flow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
Flow$Mate.unwrapped({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required FlowDelegate delegate} , hasDefaultValue:false, defaultValueCode:null
required FlowDelegate delegate, /// optionalParameters: {List<Widget> children = const <Widget>[]} , hasDefaultValue:true, defaultValueCode:const <Widget>[]
required List<Widget> children, /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , hasDefaultValue:true, defaultValueCode:Clip.hardEdge
required Clip clipBehavior, }) : super.unwrapped(key: key, delegate: delegate, children: children, clipBehavior: clipBehavior, ) { mateBuilder = (p) => Flow$Mate.unwrapped(key: p.get('key').build(), delegate: p.get('delegate').build(), children: p.get('children').build(), clipBehavior: p.get('clipBehavior').build(), );
matePut('key', key);
matePut('delegate', delegate);
matePut('children', children);
matePut('clipBehavior', clipBehavior); }

 }
/// class RichText extends MultiChildRenderObjectWidget
class RichText$Mate extends RichText with Mate {/// RichText RichText({Key? key, required InlineSpan text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, SelectionRegistrar? selectionRegistrar, Color? selectionColor})
RichText$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required InlineSpan text} , hasDefaultValue:false, defaultValueCode:null
required InlineSpan text, /// optionalParameters: {TextAlign textAlign = TextAlign.start} , hasDefaultValue:true, defaultValueCode:TextAlign.start
required TextAlign textAlign, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {bool softWrap = true} , hasDefaultValue:true, defaultValueCode:true
required bool softWrap, /// optionalParameters: {TextOverflow overflow = TextOverflow.clip} , hasDefaultValue:true, defaultValueCode:TextOverflow.clip
required TextOverflow overflow, /// optionalParameters: {double textScaleFactor = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
required double textScaleFactor, /// optionalParameters: {int? maxLines} , hasDefaultValue:false, defaultValueCode:null
int? maxLines, /// optionalParameters: {Locale? locale} , hasDefaultValue:false, defaultValueCode:null
Locale? locale, /// optionalParameters: {StrutStyle? strutStyle} , hasDefaultValue:false, defaultValueCode:null
StrutStyle? strutStyle, /// optionalParameters: {TextWidthBasis textWidthBasis = TextWidthBasis.parent} , hasDefaultValue:true, defaultValueCode:TextWidthBasis.parent
required TextWidthBasis textWidthBasis, /// optionalParameters: {TextHeightBehavior? textHeightBehavior} , hasDefaultValue:false, defaultValueCode:null
TextHeightBehavior? textHeightBehavior, /// optionalParameters: {SelectionRegistrar? selectionRegistrar} , hasDefaultValue:false, defaultValueCode:null
SelectionRegistrar? selectionRegistrar, /// optionalParameters: {Color? selectionColor} , hasDefaultValue:false, defaultValueCode:null
Color? selectionColor, }) : super(key: key, text: text, textAlign: textAlign, textDirection: textDirection, softWrap: softWrap, overflow: overflow, textScaleFactor: textScaleFactor, maxLines: maxLines, locale: locale, strutStyle: strutStyle, textWidthBasis: textWidthBasis, textHeightBehavior: textHeightBehavior, selectionRegistrar: selectionRegistrar, selectionColor: selectionColor, ) { mateBuilder = (p) => RichText$Mate(key: p.get('key').build(), text: p.get('text').build(), textAlign: p.get('textAlign').build(), textDirection: p.get('textDirection').build(), softWrap: p.get('softWrap').build(), overflow: p.get('overflow').build(), textScaleFactor: p.get('textScaleFactor').build(), maxLines: p.get('maxLines').build(), locale: p.get('locale').build(), strutStyle: p.get('strutStyle').build(), textWidthBasis: p.get('textWidthBasis').build(), textHeightBehavior: p.get('textHeightBehavior').build(), selectionRegistrar: p.get('selectionRegistrar').build(), selectionColor: p.get('selectionColor').build(), );
matePut('key', key);
matePut('text', text);
matePut('textAlign', textAlign);
matePut('textDirection', textDirection);
matePut('softWrap', softWrap);
matePut('overflow', overflow);
matePut('textScaleFactor', textScaleFactor);
matePut('maxLines', maxLines);
matePut('locale', locale);
matePut('strutStyle', strutStyle);
matePut('textWidthBasis', textWidthBasis);
matePut('textHeightBehavior', textHeightBehavior);
matePut('selectionRegistrar', selectionRegistrar);
matePut('selectionColor', selectionColor); }

 }
/// class RawImage extends LeafRenderObjectWidget
class RawImage$Mate extends RawImage with Mate {/// RawImage RawImage({Key? key, Image? image, String? debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool invertColors = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false})
RawImage$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Image? image} , hasDefaultValue:false, defaultValueCode:null
Image? image, /// optionalParameters: {String? debugImageLabel} , hasDefaultValue:false, defaultValueCode:null
String? debugImageLabel, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {double scale = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
required double scale, /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
Color? color, /// optionalParameters: {Animation<double>? opacity} , hasDefaultValue:false, defaultValueCode:null
Animation<double>? opacity, /// optionalParameters: {BlendMode? colorBlendMode} , hasDefaultValue:false, defaultValueCode:null
BlendMode? colorBlendMode, /// optionalParameters: {BoxFit? fit} , hasDefaultValue:false, defaultValueCode:null
BoxFit? fit, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , hasDefaultValue:true, defaultValueCode:ImageRepeat.noRepeat
required ImageRepeat repeat, /// optionalParameters: {Rect? centerSlice} , hasDefaultValue:false, defaultValueCode:null
Rect? centerSlice, /// optionalParameters: {bool matchTextDirection = false} , hasDefaultValue:true, defaultValueCode:false
required bool matchTextDirection, /// optionalParameters: {bool invertColors = false} , hasDefaultValue:true, defaultValueCode:false
required bool invertColors, /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , hasDefaultValue:true, defaultValueCode:FilterQuality.low
required FilterQuality filterQuality, /// optionalParameters: {bool isAntiAlias = false} , hasDefaultValue:true, defaultValueCode:false
required bool isAntiAlias, }) : super(key: key, image: image, debugImageLabel: debugImageLabel, width: width, height: height, scale: scale, color: color, opacity: opacity, colorBlendMode: colorBlendMode, fit: fit, alignment: alignment, repeat: repeat, centerSlice: centerSlice, matchTextDirection: matchTextDirection, invertColors: invertColors, filterQuality: filterQuality, isAntiAlias: isAntiAlias, ) { mateBuilder = (p) => RawImage$Mate(key: p.get('key').build(), image: p.get('image').build(), debugImageLabel: p.get('debugImageLabel').build(), width: p.get('width').build(), height: p.get('height').build(), scale: p.get('scale').build(), color: p.get('color').build(), opacity: p.get('opacity').build(), colorBlendMode: p.get('colorBlendMode').build(), fit: p.get('fit').build(), alignment: p.get('alignment').build(), repeat: p.get('repeat').build(), centerSlice: p.get('centerSlice').build(), matchTextDirection: p.get('matchTextDirection').build(), invertColors: p.get('invertColors').build(), filterQuality: p.get('filterQuality').build(), isAntiAlias: p.get('isAntiAlias').build(), );
matePut('key', key);
matePut('image', image);
matePut('debugImageLabel', debugImageLabel);
matePut('width', width);
matePut('height', height);
matePut('scale', scale);
matePut('color', color);
matePut('opacity', opacity);
matePut('colorBlendMode', colorBlendMode);
matePut('fit', fit);
matePut('alignment', alignment);
matePut('repeat', repeat);
matePut('centerSlice', centerSlice);
matePut('matchTextDirection', matchTextDirection);
matePut('invertColors', invertColors);
matePut('filterQuality', filterQuality);
matePut('isAntiAlias', isAntiAlias); }

 }
/// class DefaultAssetBundle extends InheritedWidget
class DefaultAssetBundle$Mate extends DefaultAssetBundle with Mate {/// DefaultAssetBundle DefaultAssetBundle({Key? key, required AssetBundle bundle, required Widget child})
DefaultAssetBundle$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required AssetBundle bundle} , hasDefaultValue:false, defaultValueCode:null
required AssetBundle bundle, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, bundle: bundle, child: child, ) { mateBuilder = (p) => DefaultAssetBundle$Mate(key: p.get('key').build(), bundle: p.get('bundle').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('bundle', bundle);
matePut('child', child); }

 }
/// class WidgetToRenderBoxAdapter extends LeafRenderObjectWidget
class WidgetToRenderBoxAdapter$Mate extends WidgetToRenderBoxAdapter with Mate {/// WidgetToRenderBoxAdapter WidgetToRenderBoxAdapter({required RenderBox renderBox, void Function()? onBuild, void Function()? onUnmount})
WidgetToRenderBoxAdapter$Mate({/// optionalParameters: {required RenderBox renderBox} , hasDefaultValue:false, defaultValueCode:null
required RenderBox renderBox, /// optionalParameters: {void Function()? onBuild} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onBuild, /// optionalParameters: {void Function()? onUnmount} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onUnmount, }) : super(renderBox: renderBox, onBuild: onBuild, onUnmount: onUnmount, ) { mateBuilder = (p) => WidgetToRenderBoxAdapter$Mate(renderBox: p.get('renderBox').build(), onBuild: p.get('onBuild').build(), onUnmount: p.get('onUnmount').build(), );
matePut('renderBox', renderBox);
matePut('onBuild', onBuild);
matePut('onUnmount', onUnmount); }

 }
/// class Listener extends SingleChildRenderObjectWidget
class Listener$Mate extends Listener with Mate {/// Listener Listener({Key? key, void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
Listener$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {void Function(PointerDownEvent)? onPointerDown} , hasDefaultValue:false, defaultValueCode:null
PointerDownEventListener? onPointerDown, /// optionalParameters: {void Function(PointerMoveEvent)? onPointerMove} , hasDefaultValue:false, defaultValueCode:null
PointerMoveEventListener? onPointerMove, /// optionalParameters: {void Function(PointerUpEvent)? onPointerUp} , hasDefaultValue:false, defaultValueCode:null
PointerUpEventListener? onPointerUp, /// optionalParameters: {void Function(PointerHoverEvent)? onPointerHover} , hasDefaultValue:false, defaultValueCode:null
PointerHoverEventListener? onPointerHover, /// optionalParameters: {void Function(PointerCancelEvent)? onPointerCancel} , hasDefaultValue:false, defaultValueCode:null
PointerCancelEventListener? onPointerCancel, /// optionalParameters: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart} , hasDefaultValue:false, defaultValueCode:null
PointerPanZoomStartEventListener? onPointerPanZoomStart, /// optionalParameters: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate} , hasDefaultValue:false, defaultValueCode:null
PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate, /// optionalParameters: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd} , hasDefaultValue:false, defaultValueCode:null
PointerPanZoomEndEventListener? onPointerPanZoomEnd, /// optionalParameters: {void Function(PointerSignalEvent)? onPointerSignal} , hasDefaultValue:false, defaultValueCode:null
PointerSignalEventListener? onPointerSignal, /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
required HitTestBehavior behavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, onPointerDown: onPointerDown, onPointerMove: onPointerMove, onPointerUp: onPointerUp, onPointerHover: onPointerHover, onPointerCancel: onPointerCancel, onPointerPanZoomStart: onPointerPanZoomStart, onPointerPanZoomUpdate: onPointerPanZoomUpdate, onPointerPanZoomEnd: onPointerPanZoomEnd, onPointerSignal: onPointerSignal, behavior: behavior, child: child, ) { mateBuilder = (p) => Listener$Mate(key: p.get('key').build(), onPointerDown: p.get('onPointerDown').build(), onPointerMove: p.get('onPointerMove').build(), onPointerUp: p.get('onPointerUp').build(), onPointerHover: p.get('onPointerHover').build(), onPointerCancel: p.get('onPointerCancel').build(), onPointerPanZoomStart: p.get('onPointerPanZoomStart').build(), onPointerPanZoomUpdate: p.get('onPointerPanZoomUpdate').build(), onPointerPanZoomEnd: p.get('onPointerPanZoomEnd').build(), onPointerSignal: p.get('onPointerSignal').build(), behavior: p.get('behavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('onPointerDown', onPointerDown);
matePut('onPointerMove', onPointerMove);
matePut('onPointerUp', onPointerUp);
matePut('onPointerHover', onPointerHover);
matePut('onPointerCancel', onPointerCancel);
matePut('onPointerPanZoomStart', onPointerPanZoomStart);
matePut('onPointerPanZoomUpdate', onPointerPanZoomUpdate);
matePut('onPointerPanZoomEnd', onPointerPanZoomEnd);
matePut('onPointerSignal', onPointerSignal);
matePut('behavior', behavior);
matePut('child', child); }

 }
/// class MouseRegion extends SingleChildRenderObjectWidget
class MouseRegion$Mate extends MouseRegion with Mate {/// MouseRegion MouseRegion({Key? key, void Function(PointerEnterEvent)? onEnter, void Function(PointerExitEvent)? onExit, void Function(PointerHoverEvent)? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})
MouseRegion$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {void Function(PointerEnterEvent)? onEnter} , hasDefaultValue:false, defaultValueCode:null
PointerEnterEventListener? onEnter, /// optionalParameters: {void Function(PointerExitEvent)? onExit} , hasDefaultValue:false, defaultValueCode:null
PointerExitEventListener? onExit, /// optionalParameters: {void Function(PointerHoverEvent)? onHover} , hasDefaultValue:false, defaultValueCode:null
PointerHoverEventListener? onHover, /// optionalParameters: {MouseCursor cursor = MouseCursor.defer} , hasDefaultValue:true, defaultValueCode:MouseCursor.defer
required MouseCursor cursor, /// optionalParameters: {bool opaque = true} , hasDefaultValue:true, defaultValueCode:true
required bool opaque, /// optionalParameters: {HitTestBehavior? hitTestBehavior} , hasDefaultValue:false, defaultValueCode:null
HitTestBehavior? hitTestBehavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, onEnter: onEnter, onExit: onExit, onHover: onHover, cursor: cursor, opaque: opaque, hitTestBehavior: hitTestBehavior, child: child, ) { mateBuilder = (p) => MouseRegion$Mate(key: p.get('key').build(), onEnter: p.get('onEnter').build(), onExit: p.get('onExit').build(), onHover: p.get('onHover').build(), cursor: p.get('cursor').build(), opaque: p.get('opaque').build(), hitTestBehavior: p.get('hitTestBehavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('onEnter', onEnter);
matePut('onExit', onExit);
matePut('onHover', onHover);
matePut('cursor', cursor);
matePut('opaque', opaque);
matePut('hitTestBehavior', hitTestBehavior);
matePut('child', child); }

 }
/// class RepaintBoundary extends SingleChildRenderObjectWidget
class RepaintBoundary$Mate extends RepaintBoundary with Mate {/// RepaintBoundary RepaintBoundary({Key? key, Widget? child})
RepaintBoundary$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, child: child, ) { mateBuilder = (p) => RepaintBoundary$Mate(key: p.get('key').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('child', child); }

 }
/// class IgnorePointer extends SingleChildRenderObjectWidget
class IgnorePointer$Mate extends IgnorePointer with Mate {/// IgnorePointer IgnorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics, Widget? child})
IgnorePointer$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {bool ignoring = true} , hasDefaultValue:true, defaultValueCode:true
required bool ignoring, /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
bool? ignoringSemantics, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, ignoring: ignoring, ignoringSemantics: ignoringSemantics, child: child, ) { mateBuilder = (p) => IgnorePointer$Mate(key: p.get('key').build(), ignoring: p.get('ignoring').build(), ignoringSemantics: p.get('ignoringSemantics').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('ignoring', ignoring);
matePut('ignoringSemantics', ignoringSemantics);
matePut('child', child); }

 }
/// class AbsorbPointer extends SingleChildRenderObjectWidget
class AbsorbPointer$Mate extends AbsorbPointer with Mate {/// AbsorbPointer AbsorbPointer({Key? key, bool absorbing = true, Widget? child, bool? ignoringSemantics})
AbsorbPointer$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {bool absorbing = true} , hasDefaultValue:true, defaultValueCode:true
required bool absorbing, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
bool? ignoringSemantics, }) : super(key: key, absorbing: absorbing, child: child, ignoringSemantics: ignoringSemantics, ) { mateBuilder = (p) => AbsorbPointer$Mate(key: p.get('key').build(), absorbing: p.get('absorbing').build(), child: p.get('child').build(), ignoringSemantics: p.get('ignoringSemantics').build(), );
matePut('key', key);
matePut('absorbing', absorbing);
matePut('child', child);
matePut('ignoringSemantics', ignoringSemantics); }

 }
/// class MetaData extends SingleChildRenderObjectWidget
class MetaData$Mate extends MetaData with Mate {/// MetaData MetaData({Key? key, dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
MetaData$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {dynamic metaData} , hasDefaultValue:false, defaultValueCode:null
required dynamic metaData, /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
required HitTestBehavior behavior, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, metaData: metaData, behavior: behavior, child: child, ) { mateBuilder = (p) => MetaData$Mate(key: p.get('key').build(), metaData: p.get('metaData').build(), behavior: p.get('behavior').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('metaData', metaData);
matePut('behavior', behavior);
matePut('child', child); }

 }
/// class Semantics extends SingleChildRenderObjectWidget
class Semantics$Mate extends Semantics with Mate {/// Semantics Semantics({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, void Function()? onTap, void Function()? onLongPress, void Function()? onScrollLeft, void Function()? onScrollRight, void Function()? onScrollUp, void Function()? onScrollDown, void Function()? onIncrease, void Function()? onDecrease, void Function()? onCopy, void Function()? onCut, void Function()? onPaste, void Function()? onDismiss, void Function(bool)? onMoveCursorForwardByCharacter, void Function(bool)? onMoveCursorBackwardByCharacter, void Function(TextSelection)? onSetSelection, void Function(String)? onSetText, void Function()? onDidGainAccessibilityFocus, void Function()? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, void Function()>? customSemanticsActions})
Semantics$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {bool container = false} , hasDefaultValue:true, defaultValueCode:false
required bool container, /// optionalParameters: {bool explicitChildNodes = false} , hasDefaultValue:true, defaultValueCode:false
required bool explicitChildNodes, /// optionalParameters: {bool excludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool excludeSemantics, /// optionalParameters: {bool? enabled} , hasDefaultValue:false, defaultValueCode:null
bool? enabled, /// optionalParameters: {bool? checked} , hasDefaultValue:false, defaultValueCode:null
bool? checked, /// optionalParameters: {bool? mixed} , hasDefaultValue:false, defaultValueCode:null
bool? mixed, /// optionalParameters: {bool? selected} , hasDefaultValue:false, defaultValueCode:null
bool? selected, /// optionalParameters: {bool? toggled} , hasDefaultValue:false, defaultValueCode:null
bool? toggled, /// optionalParameters: {bool? button} , hasDefaultValue:false, defaultValueCode:null
bool? button, /// optionalParameters: {bool? slider} , hasDefaultValue:false, defaultValueCode:null
bool? slider, /// optionalParameters: {bool? keyboardKey} , hasDefaultValue:false, defaultValueCode:null
bool? keyboardKey, /// optionalParameters: {bool? link} , hasDefaultValue:false, defaultValueCode:null
bool? link, /// optionalParameters: {bool? header} , hasDefaultValue:false, defaultValueCode:null
bool? header, /// optionalParameters: {bool? textField} , hasDefaultValue:false, defaultValueCode:null
bool? textField, /// optionalParameters: {bool? readOnly} , hasDefaultValue:false, defaultValueCode:null
bool? readOnly, /// optionalParameters: {bool? focusable} , hasDefaultValue:false, defaultValueCode:null
bool? focusable, /// optionalParameters: {bool? focused} , hasDefaultValue:false, defaultValueCode:null
bool? focused, /// optionalParameters: {bool? inMutuallyExclusiveGroup} , hasDefaultValue:false, defaultValueCode:null
bool? inMutuallyExclusiveGroup, /// optionalParameters: {bool? obscured} , hasDefaultValue:false, defaultValueCode:null
bool? obscured, /// optionalParameters: {bool? multiline} , hasDefaultValue:false, defaultValueCode:null
bool? multiline, /// optionalParameters: {bool? scopesRoute} , hasDefaultValue:false, defaultValueCode:null
bool? scopesRoute, /// optionalParameters: {bool? namesRoute} , hasDefaultValue:false, defaultValueCode:null
bool? namesRoute, /// optionalParameters: {bool? hidden} , hasDefaultValue:false, defaultValueCode:null
bool? hidden, /// optionalParameters: {bool? image} , hasDefaultValue:false, defaultValueCode:null
bool? image, /// optionalParameters: {bool? liveRegion} , hasDefaultValue:false, defaultValueCode:null
bool? liveRegion, /// optionalParameters: {int? maxValueLength} , hasDefaultValue:false, defaultValueCode:null
int? maxValueLength, /// optionalParameters: {int? currentValueLength} , hasDefaultValue:false, defaultValueCode:null
int? currentValueLength, /// optionalParameters: {String? label} , hasDefaultValue:false, defaultValueCode:null
String? label, /// optionalParameters: {AttributedString? attributedLabel} , hasDefaultValue:false, defaultValueCode:null
AttributedString? attributedLabel, /// optionalParameters: {String? value} , hasDefaultValue:false, defaultValueCode:null
String? value, /// optionalParameters: {AttributedString? attributedValue} , hasDefaultValue:false, defaultValueCode:null
AttributedString? attributedValue, /// optionalParameters: {String? increasedValue} , hasDefaultValue:false, defaultValueCode:null
String? increasedValue, /// optionalParameters: {AttributedString? attributedIncreasedValue} , hasDefaultValue:false, defaultValueCode:null
AttributedString? attributedIncreasedValue, /// optionalParameters: {String? decreasedValue} , hasDefaultValue:false, defaultValueCode:null
String? decreasedValue, /// optionalParameters: {AttributedString? attributedDecreasedValue} , hasDefaultValue:false, defaultValueCode:null
AttributedString? attributedDecreasedValue, /// optionalParameters: {String? hint} , hasDefaultValue:false, defaultValueCode:null
String? hint, /// optionalParameters: {AttributedString? attributedHint} , hasDefaultValue:false, defaultValueCode:null
AttributedString? attributedHint, /// optionalParameters: {String? tooltip} , hasDefaultValue:false, defaultValueCode:null
String? tooltip, /// optionalParameters: {String? onTapHint} , hasDefaultValue:false, defaultValueCode:null
String? onTapHint, /// optionalParameters: {String? onLongPressHint} , hasDefaultValue:false, defaultValueCode:null
String? onLongPressHint, /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
TextDirection? textDirection, /// optionalParameters: {SemanticsSortKey? sortKey} , hasDefaultValue:false, defaultValueCode:null
SemanticsSortKey? sortKey, /// optionalParameters: {SemanticsTag? tagForChildren} , hasDefaultValue:false, defaultValueCode:null
SemanticsTag? tagForChildren, /// optionalParameters: {void Function()? onTap} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onTap, /// optionalParameters: {void Function()? onLongPress} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onLongPress, /// optionalParameters: {void Function()? onScrollLeft} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onScrollLeft, /// optionalParameters: {void Function()? onScrollRight} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onScrollRight, /// optionalParameters: {void Function()? onScrollUp} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onScrollUp, /// optionalParameters: {void Function()? onScrollDown} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onScrollDown, /// optionalParameters: {void Function()? onIncrease} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onIncrease, /// optionalParameters: {void Function()? onDecrease} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onDecrease, /// optionalParameters: {void Function()? onCopy} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onCopy, /// optionalParameters: {void Function()? onCut} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onCut, /// optionalParameters: {void Function()? onPaste} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onPaste, /// optionalParameters: {void Function()? onDismiss} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onDismiss, /// optionalParameters: {void Function(bool)? onMoveCursorForwardByCharacter} , hasDefaultValue:false, defaultValueCode:null
MoveCursorHandler? onMoveCursorForwardByCharacter, /// optionalParameters: {void Function(bool)? onMoveCursorBackwardByCharacter} , hasDefaultValue:false, defaultValueCode:null
MoveCursorHandler? onMoveCursorBackwardByCharacter, /// optionalParameters: {void Function(TextSelection)? onSetSelection} , hasDefaultValue:false, defaultValueCode:null
SetSelectionHandler? onSetSelection, /// optionalParameters: {void Function(String)? onSetText} , hasDefaultValue:false, defaultValueCode:null
SetTextHandler? onSetText, /// optionalParameters: {void Function()? onDidGainAccessibilityFocus} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onDidGainAccessibilityFocus, /// optionalParameters: {void Function()? onDidLoseAccessibilityFocus} , hasDefaultValue:false, defaultValueCode:null
VoidCallback? onDidLoseAccessibilityFocus, /// optionalParameters: {Map<CustomSemanticsAction, void Function()>? customSemanticsActions} , hasDefaultValue:false, defaultValueCode:null
Map<CustomSemanticsAction,VoidCallback>? customSemanticsActions, }) : super(key: key, child: child, container: container, explicitChildNodes: explicitChildNodes, excludeSemantics: excludeSemantics, enabled: enabled, checked: checked, mixed: mixed, selected: selected, toggled: toggled, button: button, slider: slider, keyboardKey: keyboardKey, link: link, header: header, textField: textField, readOnly: readOnly, focusable: focusable, focused: focused, inMutuallyExclusiveGroup: inMutuallyExclusiveGroup, obscured: obscured, multiline: multiline, scopesRoute: scopesRoute, namesRoute: namesRoute, hidden: hidden, image: image, liveRegion: liveRegion, maxValueLength: maxValueLength, currentValueLength: currentValueLength, label: label, attributedLabel: attributedLabel, value: value, attributedValue: attributedValue, increasedValue: increasedValue, attributedIncreasedValue: attributedIncreasedValue, decreasedValue: decreasedValue, attributedDecreasedValue: attributedDecreasedValue, hint: hint, attributedHint: attributedHint, tooltip: tooltip, onTapHint: onTapHint, onLongPressHint: onLongPressHint, textDirection: textDirection, sortKey: sortKey, tagForChildren: tagForChildren, onTap: onTap, onLongPress: onLongPress, onScrollLeft: onScrollLeft, onScrollRight: onScrollRight, onScrollUp: onScrollUp, onScrollDown: onScrollDown, onIncrease: onIncrease, onDecrease: onDecrease, onCopy: onCopy, onCut: onCut, onPaste: onPaste, onDismiss: onDismiss, onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter, onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter, onSetSelection: onSetSelection, onSetText: onSetText, onDidGainAccessibilityFocus: onDidGainAccessibilityFocus, onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus, customSemanticsActions: customSemanticsActions, ) { mateBuilder = (p) => Semantics$Mate(key: p.get('key').build(), child: p.get('child').build(), container: p.get('container').build(), explicitChildNodes: p.get('explicitChildNodes').build(), excludeSemantics: p.get('excludeSemantics').build(), enabled: p.get('enabled').build(), checked: p.get('checked').build(), mixed: p.get('mixed').build(), selected: p.get('selected').build(), toggled: p.get('toggled').build(), button: p.get('button').build(), slider: p.get('slider').build(), keyboardKey: p.get('keyboardKey').build(), link: p.get('link').build(), header: p.get('header').build(), textField: p.get('textField').build(), readOnly: p.get('readOnly').build(), focusable: p.get('focusable').build(), focused: p.get('focused').build(), inMutuallyExclusiveGroup: p.get('inMutuallyExclusiveGroup').build(), obscured: p.get('obscured').build(), multiline: p.get('multiline').build(), scopesRoute: p.get('scopesRoute').build(), namesRoute: p.get('namesRoute').build(), hidden: p.get('hidden').build(), image: p.get('image').build(), liveRegion: p.get('liveRegion').build(), maxValueLength: p.get('maxValueLength').build(), currentValueLength: p.get('currentValueLength').build(), label: p.get('label').build(), attributedLabel: p.get('attributedLabel').build(), value: p.get('value').build(), attributedValue: p.get('attributedValue').build(), increasedValue: p.get('increasedValue').build(), attributedIncreasedValue: p.get('attributedIncreasedValue').build(), decreasedValue: p.get('decreasedValue').build(), attributedDecreasedValue: p.get('attributedDecreasedValue').build(), hint: p.get('hint').build(), attributedHint: p.get('attributedHint').build(), tooltip: p.get('tooltip').build(), onTapHint: p.get('onTapHint').build(), onLongPressHint: p.get('onLongPressHint').build(), textDirection: p.get('textDirection').build(), sortKey: p.get('sortKey').build(), tagForChildren: p.get('tagForChildren').build(), onTap: p.get('onTap').build(), onLongPress: p.get('onLongPress').build(), onScrollLeft: p.get('onScrollLeft').build(), onScrollRight: p.get('onScrollRight').build(), onScrollUp: p.get('onScrollUp').build(), onScrollDown: p.get('onScrollDown').build(), onIncrease: p.get('onIncrease').build(), onDecrease: p.get('onDecrease').build(), onCopy: p.get('onCopy').build(), onCut: p.get('onCut').build(), onPaste: p.get('onPaste').build(), onDismiss: p.get('onDismiss').build(), onMoveCursorForwardByCharacter: p.get('onMoveCursorForwardByCharacter').build(), onMoveCursorBackwardByCharacter: p.get('onMoveCursorBackwardByCharacter').build(), onSetSelection: p.get('onSetSelection').build(), onSetText: p.get('onSetText').build(), onDidGainAccessibilityFocus: p.get('onDidGainAccessibilityFocus').build(), onDidLoseAccessibilityFocus: p.get('onDidLoseAccessibilityFocus').build(), customSemanticsActions: p.get('customSemanticsActions').build(), );
matePut('key', key);
matePut('child', child);
matePut('container', container);
matePut('explicitChildNodes', explicitChildNodes);
matePut('excludeSemantics', excludeSemantics);
matePut('enabled', enabled);
matePut('checked', checked);
matePut('mixed', mixed);
matePut('selected', selected);
matePut('toggled', toggled);
matePut('button', button);
matePut('slider', slider);
matePut('keyboardKey', keyboardKey);
matePut('link', link);
matePut('header', header);
matePut('textField', textField);
matePut('readOnly', readOnly);
matePut('focusable', focusable);
matePut('focused', focused);
matePut('inMutuallyExclusiveGroup', inMutuallyExclusiveGroup);
matePut('obscured', obscured);
matePut('multiline', multiline);
matePut('scopesRoute', scopesRoute);
matePut('namesRoute', namesRoute);
matePut('hidden', hidden);
matePut('image', image);
matePut('liveRegion', liveRegion);
matePut('maxValueLength', maxValueLength);
matePut('currentValueLength', currentValueLength);
matePut('label', label);
matePut('attributedLabel', attributedLabel);
matePut('value', value);
matePut('attributedValue', attributedValue);
matePut('increasedValue', increasedValue);
matePut('attributedIncreasedValue', attributedIncreasedValue);
matePut('decreasedValue', decreasedValue);
matePut('attributedDecreasedValue', attributedDecreasedValue);
matePut('hint', hint);
matePut('attributedHint', attributedHint);
matePut('tooltip', tooltip);
matePut('onTapHint', onTapHint);
matePut('onLongPressHint', onLongPressHint);
matePut('textDirection', textDirection);
matePut('sortKey', sortKey);
matePut('tagForChildren', tagForChildren);
matePut('onTap', onTap);
matePut('onLongPress', onLongPress);
matePut('onScrollLeft', onScrollLeft);
matePut('onScrollRight', onScrollRight);
matePut('onScrollUp', onScrollUp);
matePut('onScrollDown', onScrollDown);
matePut('onIncrease', onIncrease);
matePut('onDecrease', onDecrease);
matePut('onCopy', onCopy);
matePut('onCut', onCut);
matePut('onPaste', onPaste);
matePut('onDismiss', onDismiss);
matePut('onMoveCursorForwardByCharacter', onMoveCursorForwardByCharacter);
matePut('onMoveCursorBackwardByCharacter', onMoveCursorBackwardByCharacter);
matePut('onSetSelection', onSetSelection);
matePut('onSetText', onSetText);
matePut('onDidGainAccessibilityFocus', onDidGainAccessibilityFocus);
matePut('onDidLoseAccessibilityFocus', onDidLoseAccessibilityFocus);
matePut('customSemanticsActions', customSemanticsActions); }

/// Semantics Semantics.fromProperties({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, required SemanticsProperties properties})
Semantics$Mate.fromProperties({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {bool container = false} , hasDefaultValue:true, defaultValueCode:false
required bool container, /// optionalParameters: {bool explicitChildNodes = false} , hasDefaultValue:true, defaultValueCode:false
required bool explicitChildNodes, /// optionalParameters: {bool excludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool excludeSemantics, /// optionalParameters: {required SemanticsProperties properties} , hasDefaultValue:false, defaultValueCode:null
required SemanticsProperties properties, }) : super.fromProperties(key: key, child: child, container: container, explicitChildNodes: explicitChildNodes, excludeSemantics: excludeSemantics, properties: properties, ) { mateBuilder = (p) => Semantics$Mate.fromProperties(key: p.get('key').build(), child: p.get('child').build(), container: p.get('container').build(), explicitChildNodes: p.get('explicitChildNodes').build(), excludeSemantics: p.get('excludeSemantics').build(), properties: p.get('properties').build(), );
matePut('key', key);
matePut('child', child);
matePut('container', container);
matePut('explicitChildNodes', explicitChildNodes);
matePut('excludeSemantics', excludeSemantics);
matePut('properties', properties); }

 }
/// class MergeSemantics extends SingleChildRenderObjectWidget
class MergeSemantics$Mate extends MergeSemantics with Mate {/// MergeSemantics MergeSemantics({Key? key, Widget? child})
MergeSemantics$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, child: child, ) { mateBuilder = (p) => MergeSemantics$Mate(key: p.get('key').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('child', child); }

 }
/// class BlockSemantics extends SingleChildRenderObjectWidget
class BlockSemantics$Mate extends BlockSemantics with Mate {/// BlockSemantics BlockSemantics({Key? key, bool blocking = true, Widget? child})
BlockSemantics$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {bool blocking = true} , hasDefaultValue:true, defaultValueCode:true
required bool blocking, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, blocking: blocking, child: child, ) { mateBuilder = (p) => BlockSemantics$Mate(key: p.get('key').build(), blocking: p.get('blocking').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('blocking', blocking);
matePut('child', child); }

 }
/// class ExcludeSemantics extends SingleChildRenderObjectWidget
class ExcludeSemantics$Mate extends ExcludeSemantics with Mate {/// ExcludeSemantics ExcludeSemantics({Key? key, bool excluding = true, Widget? child})
ExcludeSemantics$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {bool excluding = true} , hasDefaultValue:true, defaultValueCode:true
required bool excluding, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, excluding: excluding, child: child, ) { mateBuilder = (p) => ExcludeSemantics$Mate(key: p.get('key').build(), excluding: p.get('excluding').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('excluding', excluding);
matePut('child', child); }

 }
/// class IndexedSemantics extends SingleChildRenderObjectWidget
class IndexedSemantics$Mate extends IndexedSemantics with Mate {/// IndexedSemantics IndexedSemantics({Key? key, required int index, Widget? child})
IndexedSemantics$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required int index} , hasDefaultValue:false, defaultValueCode:null
required int index, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, }) : super(key: key, index: index, child: child, ) { mateBuilder = (p) => IndexedSemantics$Mate(key: p.get('key').build(), index: p.get('index').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('index', index);
matePut('child', child); }

 }
/// class KeyedSubtree extends StatelessWidget
class KeyedSubtree$Mate extends KeyedSubtree with Mate {/// KeyedSubtree KeyedSubtree({Key? key, required Widget child})
KeyedSubtree$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget child} , hasDefaultValue:false, defaultValueCode:null
required Widget child, }) : super(key: key, child: child, ) { mateBuilder = (p) => KeyedSubtree$Mate(key: p.get('key').build(), child: p.get('child').build(), );
matePut('key', key);
matePut('child', child); }

 }
/// class Builder extends StatelessWidget
class Builder$Mate extends Builder with Mate {/// Builder Builder({Key? key, required Widget Function(BuildContext) builder})
Builder$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget Function(BuildContext) builder} , hasDefaultValue:false, defaultValueCode:null
required WidgetBuilder builder, }) : super(key: key, builder: builder, ) { mateBuilder = (p) => Builder$Mate(key: p.get('key').build(), builder: p.get('builder').build(), );
matePut('key', key);
matePut('builder', builder); }

 }
/// class StatefulBuilder extends StatefulWidget
class StatefulBuilder$Mate extends StatefulBuilder with Mate {/// StatefulBuilder StatefulBuilder({Key? key, required Widget Function(BuildContext, void Function(void Function())) builder})
StatefulBuilder$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required Widget Function(BuildContext, void Function(void Function())) builder} , hasDefaultValue:false, defaultValueCode:null
required StatefulWidgetBuilder builder, }) : super(key: key, builder: builder, ) { mateBuilder = (p) => StatefulBuilder$Mate(key: p.get('key').build(), builder: p.get('builder').build(), );
matePut('key', key);
matePut('builder', builder); }

 }
/// class ColoredBox extends SingleChildRenderObjectWidget
class ColoredBox$Mate extends ColoredBox with Mate {/// ColoredBox ColoredBox({required Color color, Widget? child, Key? key})
ColoredBox$Mate({/// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
required Color color, /// optionalParameters: {Widget? child} , hasDefaultValue:false, defaultValueCode:null
Widget? child, /// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, }) : super(color: color, child: child, key: key, ) { mateBuilder = (p) => ColoredBox$Mate(color: p.get('color').build(), child: p.get('child').build(), key: p.get('key').build(), );
matePut('color', color);
matePut('child', child);
matePut('key', key); }

 }
