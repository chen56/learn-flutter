// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/widgets/basic.dart';
import 'package:note/mate.dart';
import 'package:flutter/src/foundation/key.dart';
import 'dart:ui';
import 'package:flutter/src/widgets/framework.dart';
import 'dart:core';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/rendering/custom_paint.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/rendering/shifted_box.dart';
import 'package:flutter/src/rendering/custom_layout.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/rendering/stack.dart';
import 'package:flutter/src/rendering/flex.dart';
import 'package:flutter/src/rendering/wrap.dart';
import 'package:flutter/src/rendering/flow.dart';
import 'package:flutter/src/painting/inline_span.dart';
import 'package:flutter/src/painting/text_painter.dart';
import 'package:flutter/src/painting/strut_style.dart';
import 'package:flutter/src/rendering/selection.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/painting/decoration_image.dart';
import 'package:flutter/src/services/asset_bundle.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/semantics/semantics.dart';
export 'package:flutter/animation.dart';
export 'package:flutter/painting.dart';

/// class Directionality extends _UbiquitousInheritedWidget
class Directionality$Mate extends Directionality with Mate {
  /// Directionality Directionality({Key? key, required TextDirection textDirection, required Widget child})
  Directionality$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required TextDirection textDirection} , defaultValue:none
    required TextDirection textDirection,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          textDirection: textDirection,
          child: child,
        ) {
    mateBuilder = (p) => Directionality$Mate(
          key: p.get('key').build(),
          textDirection: p.get('textDirection').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('textDirection', textDirection);
    mateDeclare('child', child);
  }
}

/// class Opacity extends SingleChildRenderObjectWidget
class Opacity$Mate extends Opacity with Mate {
  /// Opacity Opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? child})
  Opacity$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required double opacity} , defaultValue:none
    required double opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , defaultValue:Literal
    bool alwaysIncludeSemantics = false,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateBuilder = (p) => Opacity$Mate(
          key: p.get('key').build(),
          opacity: p.get('opacity').build(),
          alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('opacity', opacity);
    mateDeclare('alwaysIncludeSemantics', alwaysIncludeSemantics);
    mateDeclare('child', child);
  }
}

/// class ShaderMask extends SingleChildRenderObjectWidget
class ShaderMask$Mate extends ShaderMask with Mate {
  /// ShaderMask ShaderMask({Key? key, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate, Widget? child})
  ShaderMask$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Shader Function(Rect) shaderCallback} , defaultValue:none
    required ShaderCallback shaderCallback,

    /// optionalParameters: {BlendMode blendMode = BlendMode.modulate} , defaultValue:unprocessed
    required BlendMode blendMode,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
          child: child,
        ) {
    mateBuilder = (p) => ShaderMask$Mate(
          key: p.get('key').build(),
          shaderCallback: p.get('shaderCallback').build(),
          blendMode: p.get('blendMode').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('shaderCallback', shaderCallback);
    mateDeclare('blendMode', blendMode);
    mateDeclare('child', child);
  }
}

/// class BackdropFilter extends SingleChildRenderObjectWidget
class BackdropFilter$Mate extends BackdropFilter with Mate {
  /// BackdropFilter BackdropFilter({Key? key, required ImageFilter filter, Widget? child, BlendMode blendMode = BlendMode.srcOver})
  BackdropFilter$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required ImageFilter filter} , defaultValue:none
    required ImageFilter filter,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {BlendMode blendMode = BlendMode.srcOver} , defaultValue:unprocessed
    required BlendMode blendMode,
  }) : super(
          key: key,
          filter: filter,
          child: child,
          blendMode: blendMode,
        ) {
    mateBuilder = (p) => BackdropFilter$Mate(
          key: p.get('key').build(),
          filter: p.get('filter').build(),
          child: p.get('child').build(),
          blendMode: p.get('blendMode').build(),
        );
    mateDeclare('key', key);
    mateDeclare('filter', filter);
    mateDeclare('child', child);
    mateDeclare('blendMode', blendMode);
  }
}

/// class CustomPaint extends SingleChildRenderObjectWidget
class CustomPaint$Mate extends CustomPaint with Mate {
  /// CustomPaint CustomPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false, Widget? child})
  CustomPaint$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {CustomPainter? painter} , defaultValue:none
    CustomPainter? painter,

    /// optionalParameters: {CustomPainter? foregroundPainter} , defaultValue:none
    CustomPainter? foregroundPainter,

    /// optionalParameters: {Size size = Size.zero} , defaultValue:unprocessed
    required Size size,

    /// optionalParameters: {bool isComplex = false} , defaultValue:Literal
    bool isComplex = false,

    /// optionalParameters: {bool willChange = false} , defaultValue:Literal
    bool willChange = false,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          painter: painter,
          foregroundPainter: foregroundPainter,
          size: size,
          isComplex: isComplex,
          willChange: willChange,
          child: child,
        ) {
    mateBuilder = (p) => CustomPaint$Mate(
          key: p.get('key').build(),
          painter: p.get('painter').build(),
          foregroundPainter: p.get('foregroundPainter').build(),
          size: p.get('size').build(),
          isComplex: p.get('isComplex').build(),
          willChange: p.get('willChange').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('painter', painter);
    mateDeclare('foregroundPainter', foregroundPainter);
    mateDeclare('size', size);
    mateDeclare('isComplex', isComplex);
    mateDeclare('willChange', willChange);
    mateDeclare('child', child);
  }
}

/// class ClipRect extends SingleChildRenderObjectWidget
class ClipRect$Mate extends ClipRect with Mate {
  /// ClipRect ClipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge, Widget? child})
  ClipRect$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , defaultValue:none
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilder = (p) => ClipRect$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('child', child);
  }
}

/// class ClipRRect extends SingleChildRenderObjectWidget
class ClipRRect$Mate extends ClipRRect with Mate {
  /// ClipRRect ClipRRect({Key? key, BorderRadiusGeometry? borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipRRect$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {BorderRadiusGeometry? borderRadius = BorderRadius.zero} , defaultValue:unprocessed
    BorderRadiusGeometry? borderRadius,

    /// optionalParameters: {CustomClipper<RRect>? clipper} , defaultValue:none
    CustomClipper<RRect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilder = (p) => ClipRRect$Mate(
          key: p.get('key').build(),
          borderRadius: p.get('borderRadius').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('borderRadius', borderRadius);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('child', child);
  }
}

/// class ClipOval extends SingleChildRenderObjectWidget
class ClipOval$Mate extends ClipOval with Mate {
  /// ClipOval ClipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipOval$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , defaultValue:none
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilder = (p) => ClipOval$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('child', child);
  }
}

/// class ClipPath extends SingleChildRenderObjectWidget
class ClipPath$Mate extends ClipPath with Mate {
  /// ClipPath ClipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipPath$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {CustomClipper<Path>? clipper} , defaultValue:none
    CustomClipper<Path>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilder = (p) => ClipPath$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('child', child);
  }
}

/// class PhysicalModel extends SingleChildRenderObjectWidget
class PhysicalModel$Mate extends PhysicalModel with Mate {
  /// PhysicalModel PhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalModel$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {BoxShape shape = BoxShape.rectangle} , defaultValue:unprocessed
    required BoxShape shape,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {BorderRadius? borderRadius} , defaultValue:none
    BorderRadius? borderRadius,

    /// optionalParameters: {double elevation = 0.0} , defaultValue:Literal
    double elevation = 0.0,

    /// optionalParameters: {required Color color} , defaultValue:none
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , defaultValue:unprocessed
    required Color shadowColor,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateBuilder = (p) => PhysicalModel$Mate(
          key: p.get('key').build(),
          shape: p.get('shape').build(),
          clipBehavior: p.get('clipBehavior').build(),
          borderRadius: p.get('borderRadius').build(),
          elevation: p.get('elevation').build(),
          color: p.get('color').build(),
          shadowColor: p.get('shadowColor').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('shape', shape);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('borderRadius', borderRadius);
    mateDeclare('elevation', elevation);
    mateDeclare('color', color);
    mateDeclare('shadowColor', shadowColor);
    mateDeclare('child', child);
  }
}

/// class PhysicalShape extends SingleChildRenderObjectWidget
class PhysicalShape$Mate extends PhysicalShape with Mate {
  /// PhysicalShape PhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalShape$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required CustomClipper<Path> clipper} , defaultValue:none
    required CustomClipper<Path> clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {double elevation = 0.0} , defaultValue:Literal
    double elevation = 0.0,

    /// optionalParameters: {required Color color} , defaultValue:none
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , defaultValue:unprocessed
    required Color shadowColor,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateBuilder = (p) => PhysicalShape$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          elevation: p.get('elevation').build(),
          color: p.get('color').build(),
          shadowColor: p.get('shadowColor').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('elevation', elevation);
    mateDeclare('color', color);
    mateDeclare('shadowColor', shadowColor);
    mateDeclare('child', child);
  }
}

/// class Transform extends SingleChildRenderObjectWidget
class Transform$Mate extends Transform with Mate {
  /// Transform Transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Matrix4 transform} , defaultValue:none
    required Matrix4 transform,

    /// optionalParameters: {Offset? origin} , defaultValue:none
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment} , defaultValue:none
    AlignmentGeometry? alignment,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , defaultValue:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          transform: transform,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilder = (p) => Transform$Mate(
          key: p.get('key').build(),
          transform: p.get('transform').build(),
          origin: p.get('origin').build(),
          alignment: p.get('alignment').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('transform', transform);
    mateDeclare('origin', origin);
    mateDeclare('alignment', alignment);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('filterQuality', filterQuality);
    mateDeclare('child', child);
  }

  /// Transform Transform.rotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.rotate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required double angle} , defaultValue:none
    required double angle,

    /// optionalParameters: {Offset? origin} , defaultValue:none
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , defaultValue:unprocessed
    AlignmentGeometry? alignment,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , defaultValue:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super.rotate(
          key: key,
          angle: angle,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilder = (p) => Transform$Mate.rotate(
          key: p.get('key').build(),
          angle: p.get('angle').build(),
          origin: p.get('origin').build(),
          alignment: p.get('alignment').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('angle', angle);
    mateDeclare('origin', origin);
    mateDeclare('alignment', alignment);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('filterQuality', filterQuality);
    mateDeclare('child', child);
  }

  /// Transform Transform.translate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.translate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Offset offset} , defaultValue:none
    required Offset offset,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , defaultValue:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super.translate(
          key: key,
          offset: offset,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilder = (p) => Transform$Mate.translate(
          key: p.get('key').build(),
          offset: p.get('offset').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('offset', offset);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('filterQuality', filterQuality);
    mateDeclare('child', child);
  }

  /// Transform Transform.scale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.scale({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double? scale} , defaultValue:none
    double? scale,

    /// optionalParameters: {double? scaleX} , defaultValue:none
    double? scaleX,

    /// optionalParameters: {double? scaleY} , defaultValue:none
    double? scaleY,

    /// optionalParameters: {Offset? origin} , defaultValue:none
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , defaultValue:unprocessed
    AlignmentGeometry? alignment,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , defaultValue:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super.scale(
          key: key,
          scale: scale,
          scaleX: scaleX,
          scaleY: scaleY,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilder = (p) => Transform$Mate.scale(
          key: p.get('key').build(),
          scale: p.get('scale').build(),
          scaleX: p.get('scaleX').build(),
          scaleY: p.get('scaleY').build(),
          origin: p.get('origin').build(),
          alignment: p.get('alignment').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('scale', scale);
    mateDeclare('scaleX', scaleX);
    mateDeclare('scaleY', scaleY);
    mateDeclare('origin', origin);
    mateDeclare('alignment', alignment);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('filterQuality', filterQuality);
    mateDeclare('child', child);
  }

  /// Transform Transform.flip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.flip({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {bool flipX = false} , defaultValue:Literal
    bool flipX = false,

    /// optionalParameters: {bool flipY = false} , defaultValue:Literal
    bool flipY = false,

    /// optionalParameters: {Offset? origin} , defaultValue:none
    Offset? origin,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , defaultValue:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super.flip(
          key: key,
          flipX: flipX,
          flipY: flipY,
          origin: origin,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilder = (p) => Transform$Mate.flip(
          key: p.get('key').build(),
          flipX: p.get('flipX').build(),
          flipY: p.get('flipY').build(),
          origin: p.get('origin').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('flipX', flipX);
    mateDeclare('flipY', flipY);
    mateDeclare('origin', origin);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('filterQuality', filterQuality);
    mateDeclare('child', child);
  }
}

/// class CompositedTransformTarget extends SingleChildRenderObjectWidget
class CompositedTransformTarget$Mate extends CompositedTransformTarget with Mate {
  /// CompositedTransformTarget CompositedTransformTarget({Key? key, required LayerLink link, Widget? child})
  CompositedTransformTarget$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required LayerLink link} , defaultValue:none
    required LayerLink link,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          link: link,
          child: child,
        ) {
    mateBuilder = (p) => CompositedTransformTarget$Mate(
          key: p.get('key').build(),
          link: p.get('link').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('link', link);
    mateDeclare('child', child);
  }
}

/// class CompositedTransformFollower extends SingleChildRenderObjectWidget
class CompositedTransformFollower$Mate extends CompositedTransformFollower with Mate {
  /// CompositedTransformFollower CompositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, Widget? child})
  CompositedTransformFollower$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required LayerLink link} , defaultValue:none
    required LayerLink link,

    /// optionalParameters: {bool showWhenUnlinked = true} , defaultValue:Literal
    bool showWhenUnlinked = true,

    /// optionalParameters: {Offset offset = Offset.zero} , defaultValue:unprocessed
    required Offset offset,

    /// optionalParameters: {Alignment targetAnchor = Alignment.topLeft} , defaultValue:unprocessed
    required Alignment targetAnchor,

    /// optionalParameters: {Alignment followerAnchor = Alignment.topLeft} , defaultValue:unprocessed
    required Alignment followerAnchor,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {
    mateBuilder = (p) => CompositedTransformFollower$Mate(
          key: p.get('key').build(),
          link: p.get('link').build(),
          showWhenUnlinked: p.get('showWhenUnlinked').build(),
          offset: p.get('offset').build(),
          targetAnchor: p.get('targetAnchor').build(),
          followerAnchor: p.get('followerAnchor').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('link', link);
    mateDeclare('showWhenUnlinked', showWhenUnlinked);
    mateDeclare('offset', offset);
    mateDeclare('targetAnchor', targetAnchor);
    mateDeclare('followerAnchor', followerAnchor);
    mateDeclare('child', child);
  }
}

/// class FittedBox extends SingleChildRenderObjectWidget
class FittedBox$Mate extends FittedBox with Mate {
  /// FittedBox FittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})
  FittedBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {BoxFit fit = BoxFit.contain} , defaultValue:unprocessed
    required BoxFit fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          fit: fit,
          alignment: alignment,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilder = (p) => FittedBox$Mate(
          key: p.get('key').build(),
          fit: p.get('fit').build(),
          alignment: p.get('alignment').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('fit', fit);
    mateDeclare('alignment', alignment);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('child', child);
  }
}

/// class FractionalTranslation extends SingleChildRenderObjectWidget
class FractionalTranslation$Mate extends FractionalTranslation with Mate {
  /// FractionalTranslation FractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true, Widget? child})
  FractionalTranslation$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Offset translation} , defaultValue:none
    required Offset translation,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {
    mateBuilder = (p) => FractionalTranslation$Mate(
          key: p.get('key').build(),
          translation: p.get('translation').build(),
          transformHitTests: p.get('transformHitTests').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('translation', translation);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('child', child);
  }
}

/// class RotatedBox extends SingleChildRenderObjectWidget
class RotatedBox$Mate extends RotatedBox with Mate {
  /// RotatedBox RotatedBox({Key? key, required int quarterTurns, Widget? child})
  RotatedBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required int quarterTurns} , defaultValue:none
    required int quarterTurns,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          quarterTurns: quarterTurns,
          child: child,
        ) {
    mateBuilder = (p) => RotatedBox$Mate(
          key: p.get('key').build(),
          quarterTurns: p.get('quarterTurns').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('quarterTurns', quarterTurns);
    mateDeclare('child', child);
  }
}

/// class Padding extends SingleChildRenderObjectWidget
class Padding$Mate extends Padding with Mate {
  /// Padding Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})
  Padding$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required EdgeInsetsGeometry padding} , defaultValue:none
    required EdgeInsetsGeometry padding,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          padding: padding,
          child: child,
        ) {
    mateBuilder = (p) => Padding$Mate(
          key: p.get('key').build(),
          padding: p.get('padding').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('padding', padding);
    mateDeclare('child', child);
  }
}

/// class Align extends SingleChildRenderObjectWidget
class Align$Mate extends Align with Mate {
  /// Align Align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  Align$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {double? widthFactor} , defaultValue:none
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , defaultValue:none
    double? heightFactor,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateBuilder = (p) => Align$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          widthFactor: p.get('widthFactor').build(),
          heightFactor: p.get('heightFactor').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('alignment', alignment);
    mateDeclare('widthFactor', widthFactor);
    mateDeclare('heightFactor', heightFactor);
    mateDeclare('child', child);
  }
}

/// class Center extends Align
class Center$Mate extends Center with Mate {
  /// Center Center({Key? key, double? widthFactor, double? heightFactor, Widget? child})
  Center$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double? widthFactor} , defaultValue:none
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , defaultValue:none
    double? heightFactor,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateBuilder = (p) => Center$Mate(
          key: p.get('key').build(),
          widthFactor: p.get('widthFactor').build(),
          heightFactor: p.get('heightFactor').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('widthFactor', widthFactor);
    mateDeclare('heightFactor', heightFactor);
    mateDeclare('child', child);
  }
}

/// class CustomSingleChildLayout extends SingleChildRenderObjectWidget
class CustomSingleChildLayout$Mate extends CustomSingleChildLayout with Mate {
  /// CustomSingleChildLayout CustomSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate, Widget? child})
  CustomSingleChildLayout$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required SingleChildLayoutDelegate delegate} , defaultValue:none
    required SingleChildLayoutDelegate delegate,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          delegate: delegate,
          child: child,
        ) {
    mateBuilder = (p) => CustomSingleChildLayout$Mate(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('delegate', delegate);
    mateDeclare('child', child);
  }
}

/// class LayoutId extends ParentDataWidget<MultiChildLayoutParentData>
class LayoutId$Mate extends LayoutId with Mate {
  /// LayoutId LayoutId({Key? key, required Object id, required Widget child})
  LayoutId$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Object id} , defaultValue:none
    required Object id,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          id: id,
          child: child,
        ) {
    mateBuilder = (p) => LayoutId$Mate(
          key: p.get('key').build(),
          id: p.get('id').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('id', id);
    mateDeclare('child', child);
  }
}

/// class CustomMultiChildLayout extends MultiChildRenderObjectWidget
class CustomMultiChildLayout$Mate extends CustomMultiChildLayout with Mate {
  /// CustomMultiChildLayout CustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})
  CustomMultiChildLayout$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required MultiChildLayoutDelegate delegate} , defaultValue:none
    required MultiChildLayoutDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
        ) {
    mateBuilder = (p) => CustomMultiChildLayout$Mate(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('delegate', delegate);
    mateDeclare('children', children);
  }
}

/// class SizedBox extends SingleChildRenderObjectWidget
class SizedBox$Mate extends SizedBox with Mate {
  /// SizedBox SizedBox({Key? key, double? width, double? height, Widget? child})
  SizedBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double? width} , defaultValue:none
    double? width,

    /// optionalParameters: {double? height} , defaultValue:none
    double? height,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          width: width,
          height: height,
          child: child,
        ) {
    mateBuilder = (p) => SizedBox$Mate(
          key: p.get('key').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('width', width);
    mateDeclare('height', height);
    mateDeclare('child', child);
  }

  /// SizedBox SizedBox.expand({Key? key, Widget? child})
  SizedBox$Mate.expand({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super.expand(
          key: key,
          child: child,
        ) {
    mateBuilder = (p) => SizedBox$Mate.expand(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
  }

  /// SizedBox SizedBox.shrink({Key? key, Widget? child})
  SizedBox$Mate.shrink({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super.shrink(
          key: key,
          child: child,
        ) {
    mateBuilder = (p) => SizedBox$Mate.shrink(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
  }

  /// SizedBox SizedBox.fromSize({Key? key, Widget? child, Size? size})
  SizedBox$Mate.fromSize({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {Size? size} , defaultValue:none
    Size? size,
  }) : super.fromSize(
          key: key,
          child: child,
          size: size,
        ) {
    mateBuilder = (p) => SizedBox$Mate.fromSize(
          key: p.get('key').build(),
          child: p.get('child').build(),
          size: p.get('size').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
    mateDeclare('size', size);
  }

  /// SizedBox SizedBox.square({Key? key, Widget? child, double? dimension})
  SizedBox$Mate.square({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {double? dimension} , defaultValue:none
    double? dimension,
  }) : super.square(
          key: key,
          child: child,
          dimension: dimension,
        ) {
    mateBuilder = (p) => SizedBox$Mate.square(
          key: p.get('key').build(),
          child: p.get('child').build(),
          dimension: p.get('dimension').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
    mateDeclare('dimension', dimension);
  }
}

/// class ConstrainedBox extends SingleChildRenderObjectWidget
class ConstrainedBox$Mate extends ConstrainedBox with Mate {
  /// ConstrainedBox ConstrainedBox({Key? key, required BoxConstraints constraints, Widget? child})
  ConstrainedBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required BoxConstraints constraints} , defaultValue:none
    required BoxConstraints constraints,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          constraints: constraints,
          child: child,
        ) {
    mateBuilder = (p) => ConstrainedBox$Mate(
          key: p.get('key').build(),
          constraints: p.get('constraints').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('constraints', constraints);
    mateDeclare('child', child);
  }
}

/// class ConstraintsTransformBox extends SingleChildRenderObjectWidget
class ConstraintsTransformBox$Mate extends ConstraintsTransformBox with Mate {
  /// ConstraintsTransformBox ConstraintsTransformBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraints Function(BoxConstraints) constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = ''})
  ConstraintsTransformBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {required BoxConstraints Function(BoxConstraints) constraintsTransform} , defaultValue:none
    required BoxConstraintsTransform constraintsTransform,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {String debugTransformType = ''} , defaultValue:Literal
    String debugTransformType = '',
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constraintsTransform: constraintsTransform,
          clipBehavior: clipBehavior,
          debugTransformType: debugTransformType,
        ) {
    mateBuilder = (p) => ConstraintsTransformBox$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
          textDirection: p.get('textDirection').build(),
          alignment: p.get('alignment').build(),
          constraintsTransform: p.get('constraintsTransform').build(),
          clipBehavior: p.get('clipBehavior').build(),
          debugTransformType: p.get('debugTransformType').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
    mateDeclare('textDirection', textDirection);
    mateDeclare('alignment', alignment);
    mateDeclare('constraintsTransform', constraintsTransform);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('debugTransformType', debugTransformType);
  }
}

/// class UnconstrainedBox extends StatelessWidget
class UnconstrainedBox$Mate extends UnconstrainedBox with Mate {
  /// UnconstrainedBox UnconstrainedBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none})
  UnconstrainedBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {Axis? constrainedAxis} , defaultValue:none
    Axis? constrainedAxis,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constrainedAxis: constrainedAxis,
          clipBehavior: clipBehavior,
        ) {
    mateBuilder = (p) => UnconstrainedBox$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
          textDirection: p.get('textDirection').build(),
          alignment: p.get('alignment').build(),
          constrainedAxis: p.get('constrainedAxis').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
    mateDeclare('textDirection', textDirection);
    mateDeclare('alignment', alignment);
    mateDeclare('constrainedAxis', constrainedAxis);
    mateDeclare('clipBehavior', clipBehavior);
  }
}

/// class FractionallySizedBox extends SingleChildRenderObjectWidget
class FractionallySizedBox$Mate extends FractionallySizedBox with Mate {
  /// FractionallySizedBox FractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  FractionallySizedBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {double? widthFactor} , defaultValue:none
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , defaultValue:none
    double? heightFactor,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateBuilder = (p) => FractionallySizedBox$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          widthFactor: p.get('widthFactor').build(),
          heightFactor: p.get('heightFactor').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('alignment', alignment);
    mateDeclare('widthFactor', widthFactor);
    mateDeclare('heightFactor', heightFactor);
    mateDeclare('child', child);
  }
}

/// class LimitedBox extends SingleChildRenderObjectWidget
class LimitedBox$Mate extends LimitedBox with Mate {
  /// LimitedBox LimitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity, Widget? child})
  LimitedBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double maxWidth = double.infinity} , defaultValue:unprocessed
    required double maxWidth,

    /// optionalParameters: {double maxHeight = double.infinity} , defaultValue:unprocessed
    required double maxHeight,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateBuilder = (p) => LimitedBox$Mate(
          key: p.get('key').build(),
          maxWidth: p.get('maxWidth').build(),
          maxHeight: p.get('maxHeight').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('maxWidth', maxWidth);
    mateDeclare('maxHeight', maxHeight);
    mateDeclare('child', child);
  }
}

/// class OverflowBox extends SingleChildRenderObjectWidget
class OverflowBox$Mate extends OverflowBox with Mate {
  /// OverflowBox OverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})
  OverflowBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {double? minWidth} , defaultValue:none
    double? minWidth,

    /// optionalParameters: {double? maxWidth} , defaultValue:none
    double? maxWidth,

    /// optionalParameters: {double? minHeight} , defaultValue:none
    double? minHeight,

    /// optionalParameters: {double? maxHeight} , defaultValue:none
    double? maxHeight,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          minWidth: minWidth,
          maxWidth: maxWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateBuilder = (p) => OverflowBox$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          minWidth: p.get('minWidth').build(),
          maxWidth: p.get('maxWidth').build(),
          minHeight: p.get('minHeight').build(),
          maxHeight: p.get('maxHeight').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('alignment', alignment);
    mateDeclare('minWidth', minWidth);
    mateDeclare('maxWidth', maxWidth);
    mateDeclare('minHeight', minHeight);
    mateDeclare('maxHeight', maxHeight);
    mateDeclare('child', child);
  }
}

/// class SizedOverflowBox extends SingleChildRenderObjectWidget
class SizedOverflowBox$Mate extends SizedOverflowBox with Mate {
  /// SizedOverflowBox SizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center, Widget? child})
  SizedOverflowBox$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Size size} , defaultValue:none
    required Size size,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          size: size,
          alignment: alignment,
          child: child,
        ) {
    mateBuilder = (p) => SizedOverflowBox$Mate(
          key: p.get('key').build(),
          size: p.get('size').build(),
          alignment: p.get('alignment').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('size', size);
    mateDeclare('alignment', alignment);
    mateDeclare('child', child);
  }
}

/// class Offstage extends SingleChildRenderObjectWidget
class Offstage$Mate extends Offstage with Mate {
  /// Offstage Offstage({Key? key, bool offstage = true, Widget? child})
  Offstage$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {bool offstage = true} , defaultValue:Literal
    bool offstage = true,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          offstage: offstage,
          child: child,
        ) {
    mateBuilder = (p) => Offstage$Mate(
          key: p.get('key').build(),
          offstage: p.get('offstage').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('offstage', offstage);
    mateDeclare('child', child);
  }
}

/// class AspectRatio extends SingleChildRenderObjectWidget
class AspectRatio$Mate extends AspectRatio with Mate {
  /// AspectRatio AspectRatio({Key? key, required double aspectRatio, Widget? child})
  AspectRatio$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required double aspectRatio} , defaultValue:none
    required double aspectRatio,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          aspectRatio: aspectRatio,
          child: child,
        ) {
    mateBuilder = (p) => AspectRatio$Mate(
          key: p.get('key').build(),
          aspectRatio: p.get('aspectRatio').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('aspectRatio', aspectRatio);
    mateDeclare('child', child);
  }
}

/// class IntrinsicWidth extends SingleChildRenderObjectWidget
class IntrinsicWidth$Mate extends IntrinsicWidth with Mate {
  /// IntrinsicWidth IntrinsicWidth({Key? key, double? stepWidth, double? stepHeight, Widget? child})
  IntrinsicWidth$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double? stepWidth} , defaultValue:none
    double? stepWidth,

    /// optionalParameters: {double? stepHeight} , defaultValue:none
    double? stepHeight,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {
    mateBuilder = (p) => IntrinsicWidth$Mate(
          key: p.get('key').build(),
          stepWidth: p.get('stepWidth').build(),
          stepHeight: p.get('stepHeight').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('stepWidth', stepWidth);
    mateDeclare('stepHeight', stepHeight);
    mateDeclare('child', child);
  }
}

/// class IntrinsicHeight extends SingleChildRenderObjectWidget
class IntrinsicHeight$Mate extends IntrinsicHeight with Mate {
  /// IntrinsicHeight IntrinsicHeight({Key? key, Widget? child})
  IntrinsicHeight$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilder = (p) => IntrinsicHeight$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
  }
}

/// class Baseline extends SingleChildRenderObjectWidget
class Baseline$Mate extends Baseline with Mate {
  /// Baseline Baseline({Key? key, required double baseline, required TextBaseline baselineType, Widget? child})
  Baseline$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required double baseline} , defaultValue:none
    required double baseline,

    /// optionalParameters: {required TextBaseline baselineType} , defaultValue:none
    required TextBaseline baselineType,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          baseline: baseline,
          baselineType: baselineType,
          child: child,
        ) {
    mateBuilder = (p) => Baseline$Mate(
          key: p.get('key').build(),
          baseline: p.get('baseline').build(),
          baselineType: p.get('baselineType').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('baseline', baseline);
    mateDeclare('baselineType', baselineType);
    mateDeclare('child', child);
  }
}

/// class SliverToBoxAdapter extends SingleChildRenderObjectWidget
class SliverToBoxAdapter$Mate extends SliverToBoxAdapter with Mate {
  /// SliverToBoxAdapter SliverToBoxAdapter({Key? key, Widget? child})
  SliverToBoxAdapter$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilder = (p) => SliverToBoxAdapter$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
  }
}

/// class SliverPadding extends SingleChildRenderObjectWidget
class SliverPadding$Mate extends SliverPadding with Mate {
  /// SliverPadding SliverPadding({Key? key, required EdgeInsetsGeometry padding, Widget? sliver})
  SliverPadding$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required EdgeInsetsGeometry padding} , defaultValue:none
    required EdgeInsetsGeometry padding,

    /// optionalParameters: {Widget? sliver} , defaultValue:none
    Widget? sliver,
  }) : super(
          key: key,
          padding: padding,
          sliver: sliver,
        ) {
    mateBuilder = (p) => SliverPadding$Mate(
          key: p.get('key').build(),
          padding: p.get('padding').build(),
          sliver: p.get('sliver').build(),
        );
    mateDeclare('key', key);
    mateDeclare('padding', padding);
    mateDeclare('sliver', sliver);
  }
}

/// class ListBody extends MultiChildRenderObjectWidget
class ListBody$Mate extends ListBody with Mate {
  /// ListBody ListBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false, List<Widget> children = const <Widget>[]})
  ListBody$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Axis mainAxis = Axis.vertical} , defaultValue:unprocessed
    required Axis mainAxis,

    /// optionalParameters: {bool reverse = false} , defaultValue:Literal
    bool reverse = false,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxis: mainAxis,
          reverse: reverse,
          children: children,
        ) {
    mateBuilder = (p) => ListBody$Mate(
          key: p.get('key').build(),
          mainAxis: p.get('mainAxis').build(),
          reverse: p.get('reverse').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('mainAxis', mainAxis);
    mateDeclare('reverse', reverse);
    mateDeclare('children', children);
  }
}

/// class Stack extends MultiChildRenderObjectWidget
class Stack$Mate extends Stack with Mate {
  /// Stack Stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]})
  Stack$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {StackFit fit = StackFit.loose} , defaultValue:unprocessed
    required StackFit fit,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          fit: fit,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateBuilder = (p) => Stack$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          textDirection: p.get('textDirection').build(),
          fit: p.get('fit').build(),
          clipBehavior: p.get('clipBehavior').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('alignment', alignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('fit', fit);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('children', children);
  }
}

/// class IndexedStack extends Stack
class IndexedStack$Mate extends IndexedStack with Mate {
  /// IndexedStack IndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})
  IndexedStack$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {StackFit sizing = StackFit.loose} , defaultValue:unprocessed
    required StackFit sizing,

    /// optionalParameters: {int? index = 0} , defaultValue:Literal
    int? index = 0,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          clipBehavior: clipBehavior,
          sizing: sizing,
          index: index,
          children: children,
        ) {
    mateBuilder = (p) => IndexedStack$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          textDirection: p.get('textDirection').build(),
          clipBehavior: p.get('clipBehavior').build(),
          sizing: p.get('sizing').build(),
          index: p.get('index').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('alignment', alignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('sizing', sizing);
    mateDeclare('index', index);
    mateDeclare('children', children);
  }
}

/// class Positioned extends ParentDataWidget<StackParentData>
class Positioned$Mate extends Positioned with Mate {
  /// Positioned Positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, required Widget child})
  Positioned$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double? left} , defaultValue:none
    double? left,

    /// optionalParameters: {double? top} , defaultValue:none
    double? top,

    /// optionalParameters: {double? right} , defaultValue:none
    double? right,

    /// optionalParameters: {double? bottom} , defaultValue:none
    double? bottom,

    /// optionalParameters: {double? width} , defaultValue:none
    double? width,

    /// optionalParameters: {double? height} , defaultValue:none
    double? height,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateBuilder = (p) => Positioned$Mate(
          key: p.get('key').build(),
          left: p.get('left').build(),
          top: p.get('top').build(),
          right: p.get('right').build(),
          bottom: p.get('bottom').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('left', left);
    mateDeclare('top', top);
    mateDeclare('right', right);
    mateDeclare('bottom', bottom);
    mateDeclare('width', width);
    mateDeclare('height', height);
    mateDeclare('child', child);
  }

  /// Positioned Positioned.fromRect({Key? key, required Rect rect, required Widget child})
  Positioned$Mate.fromRect({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Rect rect} , defaultValue:none
    required Rect rect,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super.fromRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateBuilder = (p) => Positioned$Mate.fromRect(
          key: p.get('key').build(),
          rect: p.get('rect').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('rect', rect);
    mateDeclare('child', child);
  }

  /// Positioned Positioned.fromRelativeRect({Key? key, required RelativeRect rect, required Widget child})
  Positioned$Mate.fromRelativeRect({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required RelativeRect rect} , defaultValue:none
    required RelativeRect rect,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super.fromRelativeRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateBuilder = (p) => Positioned$Mate.fromRelativeRect(
          key: p.get('key').build(),
          rect: p.get('rect').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('rect', rect);
    mateDeclare('child', child);
  }

  /// Positioned Positioned.fill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0, required Widget child})
  Positioned$Mate.fill({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double? left = 0.0} , defaultValue:Literal
    double? left = 0.0,

    /// optionalParameters: {double? top = 0.0} , defaultValue:Literal
    double? top = 0.0,

    /// optionalParameters: {double? right = 0.0} , defaultValue:Literal
    double? right = 0.0,

    /// optionalParameters: {double? bottom = 0.0} , defaultValue:Literal
    double? bottom = 0.0,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super.fill(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          child: child,
        ) {
    mateBuilder = (p) => Positioned$Mate.fill(
          key: p.get('key').build(),
          left: p.get('left').build(),
          top: p.get('top').build(),
          right: p.get('right').build(),
          bottom: p.get('bottom').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('left', left);
    mateDeclare('top', top);
    mateDeclare('right', right);
    mateDeclare('bottom', bottom);
    mateDeclare('child', child);
  }
}

/// class PositionedDirectional extends StatelessWidget
class PositionedDirectional$Mate extends PositionedDirectional with Mate {
  /// PositionedDirectional PositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child})
  PositionedDirectional$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {double? start} , defaultValue:none
    double? start,

    /// optionalParameters: {double? top} , defaultValue:none
    double? top,

    /// optionalParameters: {double? end} , defaultValue:none
    double? end,

    /// optionalParameters: {double? bottom} , defaultValue:none
    double? bottom,

    /// optionalParameters: {double? width} , defaultValue:none
    double? width,

    /// optionalParameters: {double? height} , defaultValue:none
    double? height,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateBuilder = (p) => PositionedDirectional$Mate(
          key: p.get('key').build(),
          start: p.get('start').build(),
          top: p.get('top').build(),
          end: p.get('end').build(),
          bottom: p.get('bottom').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('start', start);
    mateDeclare('top', top);
    mateDeclare('end', end);
    mateDeclare('bottom', bottom);
    mateDeclare('width', width);
    mateDeclare('height', height);
    mateDeclare('child', child);
  }
}

/// class Flex extends MultiChildRenderObjectWidget
class Flex$Mate extends Flex with Mate {
  /// Flex Flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Flex$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Axis direction} , defaultValue:none
    required Axis direction,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , defaultValue:unprocessed
    required MainAxisAlignment mainAxisAlignment,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , defaultValue:unprocessed
    required MainAxisSize mainAxisSize,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , defaultValue:unprocessed
    required CrossAxisAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , defaultValue:unprocessed
    required VerticalDirection verticalDirection,

    /// optionalParameters: {TextBaseline? textBaseline} , defaultValue:none
    TextBaseline? textBaseline,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateBuilder = (p) => Flex$Mate(
          key: p.get('key').build(),
          direction: p.get('direction').build(),
          mainAxisAlignment: p.get('mainAxisAlignment').build(),
          mainAxisSize: p.get('mainAxisSize').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          textBaseline: p.get('textBaseline').build(),
          clipBehavior: p.get('clipBehavior').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('direction', direction);
    mateDeclare('mainAxisAlignment', mainAxisAlignment);
    mateDeclare('mainAxisSize', mainAxisSize);
    mateDeclare('crossAxisAlignment', crossAxisAlignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('verticalDirection', verticalDirection);
    mateDeclare('textBaseline', textBaseline);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('children', children);
  }
}

/// class Row extends Flex
class Row$Mate extends Row with Mate {
  /// Row Row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Row$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , defaultValue:unprocessed
    required MainAxisAlignment mainAxisAlignment,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , defaultValue:unprocessed
    required MainAxisSize mainAxisSize,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , defaultValue:unprocessed
    required CrossAxisAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , defaultValue:unprocessed
    required VerticalDirection verticalDirection,

    /// optionalParameters: {TextBaseline? textBaseline} , defaultValue:none
    TextBaseline? textBaseline,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateBuilder = (p) => Row$Mate(
          key: p.get('key').build(),
          mainAxisAlignment: p.get('mainAxisAlignment').build(),
          mainAxisSize: p.get('mainAxisSize').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          textBaseline: p.get('textBaseline').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('mainAxisAlignment', mainAxisAlignment);
    mateDeclare('mainAxisSize', mainAxisSize);
    mateDeclare('crossAxisAlignment', crossAxisAlignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('verticalDirection', verticalDirection);
    mateDeclare('textBaseline', textBaseline);
    mateDeclare('children', children);
  }
}

/// class Column extends Flex
class Column$Mate extends Column with Mate {
  /// Column Column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Column$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , defaultValue:unprocessed
    required MainAxisAlignment mainAxisAlignment,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , defaultValue:unprocessed
    required MainAxisSize mainAxisSize,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , defaultValue:unprocessed
    required CrossAxisAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , defaultValue:unprocessed
    required VerticalDirection verticalDirection,

    /// optionalParameters: {TextBaseline? textBaseline} , defaultValue:none
    TextBaseline? textBaseline,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateBuilder = (p) => Column$Mate(
          key: p.get('key').build(),
          mainAxisAlignment: p.get('mainAxisAlignment').build(),
          mainAxisSize: p.get('mainAxisSize').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          textBaseline: p.get('textBaseline').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('mainAxisAlignment', mainAxisAlignment);
    mateDeclare('mainAxisSize', mainAxisSize);
    mateDeclare('crossAxisAlignment', crossAxisAlignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('verticalDirection', verticalDirection);
    mateDeclare('textBaseline', textBaseline);
    mateDeclare('children', children);
  }
}

/// class Flexible extends ParentDataWidget<FlexParentData>
class Flexible$Mate extends Flexible with Mate {
  /// Flexible Flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose, required Widget child})
  Flexible$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {int flex = 1} , defaultValue:Literal
    int flex = 1,

    /// optionalParameters: {FlexFit fit = FlexFit.loose} , defaultValue:unprocessed
    required FlexFit fit,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          fit: fit,
          child: child,
        ) {
    mateBuilder = (p) => Flexible$Mate(
          key: p.get('key').build(),
          flex: p.get('flex').build(),
          fit: p.get('fit').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('flex', flex);
    mateDeclare('fit', fit);
    mateDeclare('child', child);
  }
}

/// class Expanded extends Flexible
class Expanded$Mate extends Expanded with Mate {
  /// Expanded Expanded({Key? key, int flex = 1, required Widget child})
  Expanded$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {int flex = 1} , defaultValue:Literal
    int flex = 1,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          child: child,
        ) {
    mateBuilder = (p) => Expanded$Mate(
          key: p.get('key').build(),
          flex: p.get('flex').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('flex', flex);
    mateDeclare('child', child);
  }
}

/// class Wrap extends MultiChildRenderObjectWidget
class Wrap$Mate extends Wrap with Mate {
  /// Wrap Wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Wrap$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Axis direction = Axis.horizontal} , defaultValue:unprocessed
    required Axis direction,

    /// optionalParameters: {WrapAlignment alignment = WrapAlignment.start} , defaultValue:unprocessed
    required WrapAlignment alignment,

    /// optionalParameters: {double spacing = 0.0} , defaultValue:Literal
    double spacing = 0.0,

    /// optionalParameters: {WrapAlignment runAlignment = WrapAlignment.start} , defaultValue:unprocessed
    required WrapAlignment runAlignment,

    /// optionalParameters: {double runSpacing = 0.0} , defaultValue:Literal
    double runSpacing = 0.0,

    /// optionalParameters: {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start} , defaultValue:unprocessed
    required WrapCrossAlignment crossAxisAlignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , defaultValue:unprocessed
    required VerticalDirection verticalDirection,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          alignment: alignment,
          spacing: spacing,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateBuilder = (p) => Wrap$Mate(
          key: p.get('key').build(),
          direction: p.get('direction').build(),
          alignment: p.get('alignment').build(),
          spacing: p.get('spacing').build(),
          runAlignment: p.get('runAlignment').build(),
          runSpacing: p.get('runSpacing').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          clipBehavior: p.get('clipBehavior').build(),
          children: p.get('children').build(),
        );
    mateDeclare('key', key);
    mateDeclare('direction', direction);
    mateDeclare('alignment', alignment);
    mateDeclare('spacing', spacing);
    mateDeclare('runAlignment', runAlignment);
    mateDeclare('runSpacing', runSpacing);
    mateDeclare('crossAxisAlignment', crossAxisAlignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('verticalDirection', verticalDirection);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('children', children);
  }
}

/// class Flow extends MultiChildRenderObjectWidget
class Flow$Mate extends Flow with Mate {
  /// Flow Flow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required FlowDelegate delegate} , defaultValue:none
    required FlowDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , defaultValue:unprocessed
    required Clip clipBehavior,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateBuilder = (p) => Flow$Mate(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          children: p.get('children').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateDeclare('key', key);
    mateDeclare('delegate', delegate);
    mateDeclare('children', children);
    mateDeclare('clipBehavior', clipBehavior);
  }

  /// Flow Flow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate.unwrapped({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required FlowDelegate delegate} , defaultValue:none
    required FlowDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , defaultValue:unprocessed
    required List<Widget> children,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , defaultValue:unprocessed
    required Clip clipBehavior,
  }) : super.unwrapped(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateBuilder = (p) => Flow$Mate.unwrapped(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          children: p.get('children').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateDeclare('key', key);
    mateDeclare('delegate', delegate);
    mateDeclare('children', children);
    mateDeclare('clipBehavior', clipBehavior);
  }
}

/// class RichText extends MultiChildRenderObjectWidget
class RichText$Mate extends RichText with Mate {
  /// RichText RichText({Key? key, required InlineSpan text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, SelectionRegistrar? selectionRegistrar, Color? selectionColor})
  RichText$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required InlineSpan text} , defaultValue:none
    required InlineSpan text,

    /// optionalParameters: {TextAlign textAlign = TextAlign.start} , defaultValue:unprocessed
    required TextAlign textAlign,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {bool softWrap = true} , defaultValue:Literal
    bool softWrap = true,

    /// optionalParameters: {TextOverflow overflow = TextOverflow.clip} , defaultValue:unprocessed
    required TextOverflow overflow,

    /// optionalParameters: {double textScaleFactor = 1.0} , defaultValue:Literal
    double textScaleFactor = 1.0,

    /// optionalParameters: {int? maxLines} , defaultValue:none
    int? maxLines,

    /// optionalParameters: {Locale? locale} , defaultValue:none
    Locale? locale,

    /// optionalParameters: {StrutStyle? strutStyle} , defaultValue:none
    StrutStyle? strutStyle,

    /// optionalParameters: {TextWidthBasis textWidthBasis = TextWidthBasis.parent} , defaultValue:unprocessed
    required TextWidthBasis textWidthBasis,

    /// optionalParameters: {TextHeightBehavior? textHeightBehavior} , defaultValue:none
    TextHeightBehavior? textHeightBehavior,

    /// optionalParameters: {SelectionRegistrar? selectionRegistrar} , defaultValue:none
    SelectionRegistrar? selectionRegistrar,

    /// optionalParameters: {Color? selectionColor} , defaultValue:none
    Color? selectionColor,
  }) : super(
          key: key,
          text: text,
          textAlign: textAlign,
          textDirection: textDirection,
          softWrap: softWrap,
          overflow: overflow,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionRegistrar: selectionRegistrar,
          selectionColor: selectionColor,
        ) {
    mateBuilder = (p) => RichText$Mate(
          key: p.get('key').build(),
          text: p.get('text').build(),
          textAlign: p.get('textAlign').build(),
          textDirection: p.get('textDirection').build(),
          softWrap: p.get('softWrap').build(),
          overflow: p.get('overflow').build(),
          textScaleFactor: p.get('textScaleFactor').build(),
          maxLines: p.get('maxLines').build(),
          locale: p.get('locale').build(),
          strutStyle: p.get('strutStyle').build(),
          textWidthBasis: p.get('textWidthBasis').build(),
          textHeightBehavior: p.get('textHeightBehavior').build(),
          selectionRegistrar: p.get('selectionRegistrar').build(),
          selectionColor: p.get('selectionColor').build(),
        );
    mateDeclare('key', key);
    mateDeclare('text', text);
    mateDeclare('textAlign', textAlign);
    mateDeclare('textDirection', textDirection);
    mateDeclare('softWrap', softWrap);
    mateDeclare('overflow', overflow);
    mateDeclare('textScaleFactor', textScaleFactor);
    mateDeclare('maxLines', maxLines);
    mateDeclare('locale', locale);
    mateDeclare('strutStyle', strutStyle);
    mateDeclare('textWidthBasis', textWidthBasis);
    mateDeclare('textHeightBehavior', textHeightBehavior);
    mateDeclare('selectionRegistrar', selectionRegistrar);
    mateDeclare('selectionColor', selectionColor);
  }
}

/// class RawImage extends LeafRenderObjectWidget
class RawImage$Mate extends RawImage with Mate {
  /// RawImage RawImage({Key? key, Image? image, String? debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool invertColors = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false})
  RawImage$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Image? image} , defaultValue:none
    Image? image,

    /// optionalParameters: {String? debugImageLabel} , defaultValue:none
    String? debugImageLabel,

    /// optionalParameters: {double? width} , defaultValue:none
    double? width,

    /// optionalParameters: {double? height} , defaultValue:none
    double? height,

    /// optionalParameters: {double scale = 1.0} , defaultValue:Literal
    double scale = 1.0,

    /// optionalParameters: {Color? color} , defaultValue:none
    Color? color,

    /// optionalParameters: {Animation<double>? opacity} , defaultValue:none
    Animation<double>? opacity,

    /// optionalParameters: {BlendMode? colorBlendMode} , defaultValue:none
    BlendMode? colorBlendMode,

    /// optionalParameters: {BoxFit? fit} , defaultValue:none
    BoxFit? fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , defaultValue:unprocessed
    required ImageRepeat repeat,

    /// optionalParameters: {Rect? centerSlice} , defaultValue:none
    Rect? centerSlice,

    /// optionalParameters: {bool matchTextDirection = false} , defaultValue:Literal
    bool matchTextDirection = false,

    /// optionalParameters: {bool invertColors = false} , defaultValue:Literal
    bool invertColors = false,

    /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , defaultValue:unprocessed
    required FilterQuality filterQuality,

    /// optionalParameters: {bool isAntiAlias = false} , defaultValue:Literal
    bool isAntiAlias = false,
  }) : super(
          key: key,
          image: image,
          debugImageLabel: debugImageLabel,
          width: width,
          height: height,
          scale: scale,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment,
          repeat: repeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection,
          invertColors: invertColors,
          filterQuality: filterQuality,
          isAntiAlias: isAntiAlias,
        ) {
    mateBuilder = (p) => RawImage$Mate(
          key: p.get('key').build(),
          image: p.get('image').build(),
          debugImageLabel: p.get('debugImageLabel').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          scale: p.get('scale').build(),
          color: p.get('color').build(),
          opacity: p.get('opacity').build(),
          colorBlendMode: p.get('colorBlendMode').build(),
          fit: p.get('fit').build(),
          alignment: p.get('alignment').build(),
          repeat: p.get('repeat').build(),
          centerSlice: p.get('centerSlice').build(),
          matchTextDirection: p.get('matchTextDirection').build(),
          invertColors: p.get('invertColors').build(),
          filterQuality: p.get('filterQuality').build(),
          isAntiAlias: p.get('isAntiAlias').build(),
        );
    mateDeclare('key', key);
    mateDeclare('image', image);
    mateDeclare('debugImageLabel', debugImageLabel);
    mateDeclare('width', width);
    mateDeclare('height', height);
    mateDeclare('scale', scale);
    mateDeclare('color', color);
    mateDeclare('opacity', opacity);
    mateDeclare('colorBlendMode', colorBlendMode);
    mateDeclare('fit', fit);
    mateDeclare('alignment', alignment);
    mateDeclare('repeat', repeat);
    mateDeclare('centerSlice', centerSlice);
    mateDeclare('matchTextDirection', matchTextDirection);
    mateDeclare('invertColors', invertColors);
    mateDeclare('filterQuality', filterQuality);
    mateDeclare('isAntiAlias', isAntiAlias);
  }
}

/// class DefaultAssetBundle extends InheritedWidget
class DefaultAssetBundle$Mate extends DefaultAssetBundle with Mate {
  /// DefaultAssetBundle DefaultAssetBundle({Key? key, required AssetBundle bundle, required Widget child})
  DefaultAssetBundle$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required AssetBundle bundle} , defaultValue:none
    required AssetBundle bundle,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          bundle: bundle,
          child: child,
        ) {
    mateBuilder = (p) => DefaultAssetBundle$Mate(
          key: p.get('key').build(),
          bundle: p.get('bundle').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('bundle', bundle);
    mateDeclare('child', child);
  }
}

/// class WidgetToRenderBoxAdapter extends LeafRenderObjectWidget
class WidgetToRenderBoxAdapter$Mate extends WidgetToRenderBoxAdapter with Mate {
  /// WidgetToRenderBoxAdapter WidgetToRenderBoxAdapter({required RenderBox renderBox, void Function()? onBuild, void Function()? onUnmount})
  WidgetToRenderBoxAdapter$Mate({
    /// optionalParameters: {required RenderBox renderBox} , defaultValue:none
    required RenderBox renderBox,

    /// optionalParameters: {void Function()? onBuild} , defaultValue:none
    VoidCallback? onBuild,

    /// optionalParameters: {void Function()? onUnmount} , defaultValue:none
    VoidCallback? onUnmount,
  }) : super(
          renderBox: renderBox,
          onBuild: onBuild,
          onUnmount: onUnmount,
        ) {
    mateBuilder = (p) => WidgetToRenderBoxAdapter$Mate(
          renderBox: p.get('renderBox').build(),
          onBuild: p.get('onBuild').build(),
          onUnmount: p.get('onUnmount').build(),
        );
    mateDeclare('renderBox', renderBox);
    mateDeclare('onBuild', onBuild);
    mateDeclare('onUnmount', onUnmount);
  }
}

/// class Listener extends SingleChildRenderObjectWidget
class Listener$Mate extends Listener with Mate {
  /// Listener Listener({Key? key, void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  Listener$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {void Function(PointerDownEvent)? onPointerDown} , defaultValue:none
    PointerDownEventListener? onPointerDown,

    /// optionalParameters: {void Function(PointerMoveEvent)? onPointerMove} , defaultValue:none
    PointerMoveEventListener? onPointerMove,

    /// optionalParameters: {void Function(PointerUpEvent)? onPointerUp} , defaultValue:none
    PointerUpEventListener? onPointerUp,

    /// optionalParameters: {void Function(PointerHoverEvent)? onPointerHover} , defaultValue:none
    PointerHoverEventListener? onPointerHover,

    /// optionalParameters: {void Function(PointerCancelEvent)? onPointerCancel} , defaultValue:none
    PointerCancelEventListener? onPointerCancel,

    /// optionalParameters: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart} , defaultValue:none
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// optionalParameters: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate} , defaultValue:none
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// optionalParameters: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd} , defaultValue:none
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// optionalParameters: {void Function(PointerSignalEvent)? onPointerSignal} , defaultValue:none
    PointerSignalEventListener? onPointerSignal,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , defaultValue:unprocessed
    required HitTestBehavior behavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {
    mateBuilder = (p) => Listener$Mate(
          key: p.get('key').build(),
          onPointerDown: p.get('onPointerDown').build(),
          onPointerMove: p.get('onPointerMove').build(),
          onPointerUp: p.get('onPointerUp').build(),
          onPointerHover: p.get('onPointerHover').build(),
          onPointerCancel: p.get('onPointerCancel').build(),
          onPointerPanZoomStart: p.get('onPointerPanZoomStart').build(),
          onPointerPanZoomUpdate: p.get('onPointerPanZoomUpdate').build(),
          onPointerPanZoomEnd: p.get('onPointerPanZoomEnd').build(),
          onPointerSignal: p.get('onPointerSignal').build(),
          behavior: p.get('behavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('onPointerDown', onPointerDown);
    mateDeclare('onPointerMove', onPointerMove);
    mateDeclare('onPointerUp', onPointerUp);
    mateDeclare('onPointerHover', onPointerHover);
    mateDeclare('onPointerCancel', onPointerCancel);
    mateDeclare('onPointerPanZoomStart', onPointerPanZoomStart);
    mateDeclare('onPointerPanZoomUpdate', onPointerPanZoomUpdate);
    mateDeclare('onPointerPanZoomEnd', onPointerPanZoomEnd);
    mateDeclare('onPointerSignal', onPointerSignal);
    mateDeclare('behavior', behavior);
    mateDeclare('child', child);
  }
}

/// class MouseRegion extends SingleChildRenderObjectWidget
class MouseRegion$Mate extends MouseRegion with Mate {
  /// MouseRegion MouseRegion({Key? key, void Function(PointerEnterEvent)? onEnter, void Function(PointerExitEvent)? onExit, void Function(PointerHoverEvent)? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})
  MouseRegion$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {void Function(PointerEnterEvent)? onEnter} , defaultValue:none
    PointerEnterEventListener? onEnter,

    /// optionalParameters: {void Function(PointerExitEvent)? onExit} , defaultValue:none
    PointerExitEventListener? onExit,

    /// optionalParameters: {void Function(PointerHoverEvent)? onHover} , defaultValue:none
    PointerHoverEventListener? onHover,

    /// optionalParameters: {MouseCursor cursor = MouseCursor.defer} , defaultValue:unprocessed
    required MouseCursor cursor,

    /// optionalParameters: {bool opaque = true} , defaultValue:Literal
    bool opaque = true,

    /// optionalParameters: {HitTestBehavior? hitTestBehavior} , defaultValue:none
    HitTestBehavior? hitTestBehavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          onEnter: onEnter,
          onExit: onExit,
          onHover: onHover,
          cursor: cursor,
          opaque: opaque,
          hitTestBehavior: hitTestBehavior,
          child: child,
        ) {
    mateBuilder = (p) => MouseRegion$Mate(
          key: p.get('key').build(),
          onEnter: p.get('onEnter').build(),
          onExit: p.get('onExit').build(),
          onHover: p.get('onHover').build(),
          cursor: p.get('cursor').build(),
          opaque: p.get('opaque').build(),
          hitTestBehavior: p.get('hitTestBehavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('onEnter', onEnter);
    mateDeclare('onExit', onExit);
    mateDeclare('onHover', onHover);
    mateDeclare('cursor', cursor);
    mateDeclare('opaque', opaque);
    mateDeclare('hitTestBehavior', hitTestBehavior);
    mateDeclare('child', child);
  }
}

/// class RepaintBoundary extends SingleChildRenderObjectWidget
class RepaintBoundary$Mate extends RepaintBoundary with Mate {
  /// RepaintBoundary RepaintBoundary({Key? key, Widget? child})
  RepaintBoundary$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilder = (p) => RepaintBoundary$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
  }
}

/// class IgnorePointer extends SingleChildRenderObjectWidget
class IgnorePointer$Mate extends IgnorePointer with Mate {
  /// IgnorePointer IgnorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics, Widget? child})
  IgnorePointer$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {bool ignoring = true} , defaultValue:Literal
    bool ignoring = true,

    /// optionalParameters: {bool? ignoringSemantics} , defaultValue:none
    bool? ignoringSemantics,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
          child: child,
        ) {
    mateBuilder = (p) => IgnorePointer$Mate(
          key: p.get('key').build(),
          ignoring: p.get('ignoring').build(),
          ignoringSemantics: p.get('ignoringSemantics').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('ignoring', ignoring);
    mateDeclare('ignoringSemantics', ignoringSemantics);
    mateDeclare('child', child);
  }
}

/// class AbsorbPointer extends SingleChildRenderObjectWidget
class AbsorbPointer$Mate extends AbsorbPointer with Mate {
  /// AbsorbPointer AbsorbPointer({Key? key, bool absorbing = true, Widget? child, bool? ignoringSemantics})
  AbsorbPointer$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {bool absorbing = true} , defaultValue:Literal
    bool absorbing = true,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {bool? ignoringSemantics} , defaultValue:none
    bool? ignoringSemantics,
  }) : super(
          key: key,
          absorbing: absorbing,
          child: child,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateBuilder = (p) => AbsorbPointer$Mate(
          key: p.get('key').build(),
          absorbing: p.get('absorbing').build(),
          child: p.get('child').build(),
          ignoringSemantics: p.get('ignoringSemantics').build(),
        );
    mateDeclare('key', key);
    mateDeclare('absorbing', absorbing);
    mateDeclare('child', child);
    mateDeclare('ignoringSemantics', ignoringSemantics);
  }
}

/// class MetaData extends SingleChildRenderObjectWidget
class MetaData$Mate extends MetaData with Mate {
  /// MetaData MetaData({Key? key, dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  MetaData$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {dynamic metaData} , defaultValue:none
    dynamic metaData,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , defaultValue:unprocessed
    required HitTestBehavior behavior,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {
    mateBuilder = (p) => MetaData$Mate(
          key: p.get('key').build(),
          metaData: p.get('metaData').build(),
          behavior: p.get('behavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('metaData', metaData);
    mateDeclare('behavior', behavior);
    mateDeclare('child', child);
  }
}

/// class Semantics extends SingleChildRenderObjectWidget
class Semantics$Mate extends Semantics with Mate {
  /// Semantics Semantics({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, void Function()? onTap, void Function()? onLongPress, void Function()? onScrollLeft, void Function()? onScrollRight, void Function()? onScrollUp, void Function()? onScrollDown, void Function()? onIncrease, void Function()? onDecrease, void Function()? onCopy, void Function()? onCut, void Function()? onPaste, void Function()? onDismiss, void Function(bool)? onMoveCursorForwardByCharacter, void Function(bool)? onMoveCursorBackwardByCharacter, void Function(TextSelection)? onSetSelection, void Function(String)? onSetText, void Function()? onDidGainAccessibilityFocus, void Function()? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, void Function()>? customSemanticsActions})
  Semantics$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {bool container = false} , defaultValue:Literal
    bool container = false,

    /// optionalParameters: {bool explicitChildNodes = false} , defaultValue:Literal
    bool explicitChildNodes = false,

    /// optionalParameters: {bool excludeSemantics = false} , defaultValue:Literal
    bool excludeSemantics = false,

    /// optionalParameters: {bool? enabled} , defaultValue:none
    bool? enabled,

    /// optionalParameters: {bool? checked} , defaultValue:none
    bool? checked,

    /// optionalParameters: {bool? mixed} , defaultValue:none
    bool? mixed,

    /// optionalParameters: {bool? selected} , defaultValue:none
    bool? selected,

    /// optionalParameters: {bool? toggled} , defaultValue:none
    bool? toggled,

    /// optionalParameters: {bool? button} , defaultValue:none
    bool? button,

    /// optionalParameters: {bool? slider} , defaultValue:none
    bool? slider,

    /// optionalParameters: {bool? keyboardKey} , defaultValue:none
    bool? keyboardKey,

    /// optionalParameters: {bool? link} , defaultValue:none
    bool? link,

    /// optionalParameters: {bool? header} , defaultValue:none
    bool? header,

    /// optionalParameters: {bool? textField} , defaultValue:none
    bool? textField,

    /// optionalParameters: {bool? readOnly} , defaultValue:none
    bool? readOnly,

    /// optionalParameters: {bool? focusable} , defaultValue:none
    bool? focusable,

    /// optionalParameters: {bool? focused} , defaultValue:none
    bool? focused,

    /// optionalParameters: {bool? inMutuallyExclusiveGroup} , defaultValue:none
    bool? inMutuallyExclusiveGroup,

    /// optionalParameters: {bool? obscured} , defaultValue:none
    bool? obscured,

    /// optionalParameters: {bool? multiline} , defaultValue:none
    bool? multiline,

    /// optionalParameters: {bool? scopesRoute} , defaultValue:none
    bool? scopesRoute,

    /// optionalParameters: {bool? namesRoute} , defaultValue:none
    bool? namesRoute,

    /// optionalParameters: {bool? hidden} , defaultValue:none
    bool? hidden,

    /// optionalParameters: {bool? image} , defaultValue:none
    bool? image,

    /// optionalParameters: {bool? liveRegion} , defaultValue:none
    bool? liveRegion,

    /// optionalParameters: {int? maxValueLength} , defaultValue:none
    int? maxValueLength,

    /// optionalParameters: {int? currentValueLength} , defaultValue:none
    int? currentValueLength,

    /// optionalParameters: {String? label} , defaultValue:none
    String? label,

    /// optionalParameters: {AttributedString? attributedLabel} , defaultValue:none
    AttributedString? attributedLabel,

    /// optionalParameters: {String? value} , defaultValue:none
    String? value,

    /// optionalParameters: {AttributedString? attributedValue} , defaultValue:none
    AttributedString? attributedValue,

    /// optionalParameters: {String? increasedValue} , defaultValue:none
    String? increasedValue,

    /// optionalParameters: {AttributedString? attributedIncreasedValue} , defaultValue:none
    AttributedString? attributedIncreasedValue,

    /// optionalParameters: {String? decreasedValue} , defaultValue:none
    String? decreasedValue,

    /// optionalParameters: {AttributedString? attributedDecreasedValue} , defaultValue:none
    AttributedString? attributedDecreasedValue,

    /// optionalParameters: {String? hint} , defaultValue:none
    String? hint,

    /// optionalParameters: {AttributedString? attributedHint} , defaultValue:none
    AttributedString? attributedHint,

    /// optionalParameters: {String? tooltip} , defaultValue:none
    String? tooltip,

    /// optionalParameters: {String? onTapHint} , defaultValue:none
    String? onTapHint,

    /// optionalParameters: {String? onLongPressHint} , defaultValue:none
    String? onLongPressHint,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {SemanticsSortKey? sortKey} , defaultValue:none
    SemanticsSortKey? sortKey,

    /// optionalParameters: {SemanticsTag? tagForChildren} , defaultValue:none
    SemanticsTag? tagForChildren,

    /// optionalParameters: {void Function()? onTap} , defaultValue:none
    VoidCallback? onTap,

    /// optionalParameters: {void Function()? onLongPress} , defaultValue:none
    VoidCallback? onLongPress,

    /// optionalParameters: {void Function()? onScrollLeft} , defaultValue:none
    VoidCallback? onScrollLeft,

    /// optionalParameters: {void Function()? onScrollRight} , defaultValue:none
    VoidCallback? onScrollRight,

    /// optionalParameters: {void Function()? onScrollUp} , defaultValue:none
    VoidCallback? onScrollUp,

    /// optionalParameters: {void Function()? onScrollDown} , defaultValue:none
    VoidCallback? onScrollDown,

    /// optionalParameters: {void Function()? onIncrease} , defaultValue:none
    VoidCallback? onIncrease,

    /// optionalParameters: {void Function()? onDecrease} , defaultValue:none
    VoidCallback? onDecrease,

    /// optionalParameters: {void Function()? onCopy} , defaultValue:none
    VoidCallback? onCopy,

    /// optionalParameters: {void Function()? onCut} , defaultValue:none
    VoidCallback? onCut,

    /// optionalParameters: {void Function()? onPaste} , defaultValue:none
    VoidCallback? onPaste,

    /// optionalParameters: {void Function()? onDismiss} , defaultValue:none
    VoidCallback? onDismiss,

    /// optionalParameters: {void Function(bool)? onMoveCursorForwardByCharacter} , defaultValue:none
    MoveCursorHandler? onMoveCursorForwardByCharacter,

    /// optionalParameters: {void Function(bool)? onMoveCursorBackwardByCharacter} , defaultValue:none
    MoveCursorHandler? onMoveCursorBackwardByCharacter,

    /// optionalParameters: {void Function(TextSelection)? onSetSelection} , defaultValue:none
    SetSelectionHandler? onSetSelection,

    /// optionalParameters: {void Function(String)? onSetText} , defaultValue:none
    SetTextHandler? onSetText,

    /// optionalParameters: {void Function()? onDidGainAccessibilityFocus} , defaultValue:none
    VoidCallback? onDidGainAccessibilityFocus,

    /// optionalParameters: {void Function()? onDidLoseAccessibilityFocus} , defaultValue:none
    VoidCallback? onDidLoseAccessibilityFocus,

    /// optionalParameters: {Map<CustomSemanticsAction, void Function()>? customSemanticsActions} , defaultValue:none
    Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions,
  }) : super(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          enabled: enabled,
          checked: checked,
          mixed: mixed,
          selected: selected,
          toggled: toggled,
          button: button,
          slider: slider,
          keyboardKey: keyboardKey,
          link: link,
          header: header,
          textField: textField,
          readOnly: readOnly,
          focusable: focusable,
          focused: focused,
          inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
          obscured: obscured,
          multiline: multiline,
          scopesRoute: scopesRoute,
          namesRoute: namesRoute,
          hidden: hidden,
          image: image,
          liveRegion: liveRegion,
          maxValueLength: maxValueLength,
          currentValueLength: currentValueLength,
          label: label,
          attributedLabel: attributedLabel,
          value: value,
          attributedValue: attributedValue,
          increasedValue: increasedValue,
          attributedIncreasedValue: attributedIncreasedValue,
          decreasedValue: decreasedValue,
          attributedDecreasedValue: attributedDecreasedValue,
          hint: hint,
          attributedHint: attributedHint,
          tooltip: tooltip,
          onTapHint: onTapHint,
          onLongPressHint: onLongPressHint,
          textDirection: textDirection,
          sortKey: sortKey,
          tagForChildren: tagForChildren,
          onTap: onTap,
          onLongPress: onLongPress,
          onScrollLeft: onScrollLeft,
          onScrollRight: onScrollRight,
          onScrollUp: onScrollUp,
          onScrollDown: onScrollDown,
          onIncrease: onIncrease,
          onDecrease: onDecrease,
          onCopy: onCopy,
          onCut: onCut,
          onPaste: onPaste,
          onDismiss: onDismiss,
          onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter,
          onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter,
          onSetSelection: onSetSelection,
          onSetText: onSetText,
          onDidGainAccessibilityFocus: onDidGainAccessibilityFocus,
          onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus,
          customSemanticsActions: customSemanticsActions,
        ) {
    mateBuilder = (p) => Semantics$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
          container: p.get('container').build(),
          explicitChildNodes: p.get('explicitChildNodes').build(),
          excludeSemantics: p.get('excludeSemantics').build(),
          enabled: p.get('enabled').build(),
          checked: p.get('checked').build(),
          mixed: p.get('mixed').build(),
          selected: p.get('selected').build(),
          toggled: p.get('toggled').build(),
          button: p.get('button').build(),
          slider: p.get('slider').build(),
          keyboardKey: p.get('keyboardKey').build(),
          link: p.get('link').build(),
          header: p.get('header').build(),
          textField: p.get('textField').build(),
          readOnly: p.get('readOnly').build(),
          focusable: p.get('focusable').build(),
          focused: p.get('focused').build(),
          inMutuallyExclusiveGroup: p.get('inMutuallyExclusiveGroup').build(),
          obscured: p.get('obscured').build(),
          multiline: p.get('multiline').build(),
          scopesRoute: p.get('scopesRoute').build(),
          namesRoute: p.get('namesRoute').build(),
          hidden: p.get('hidden').build(),
          image: p.get('image').build(),
          liveRegion: p.get('liveRegion').build(),
          maxValueLength: p.get('maxValueLength').build(),
          currentValueLength: p.get('currentValueLength').build(),
          label: p.get('label').build(),
          attributedLabel: p.get('attributedLabel').build(),
          value: p.get('value').build(),
          attributedValue: p.get('attributedValue').build(),
          increasedValue: p.get('increasedValue').build(),
          attributedIncreasedValue: p.get('attributedIncreasedValue').build(),
          decreasedValue: p.get('decreasedValue').build(),
          attributedDecreasedValue: p.get('attributedDecreasedValue').build(),
          hint: p.get('hint').build(),
          attributedHint: p.get('attributedHint').build(),
          tooltip: p.get('tooltip').build(),
          onTapHint: p.get('onTapHint').build(),
          onLongPressHint: p.get('onLongPressHint').build(),
          textDirection: p.get('textDirection').build(),
          sortKey: p.get('sortKey').build(),
          tagForChildren: p.get('tagForChildren').build(),
          onTap: p.get('onTap').build(),
          onLongPress: p.get('onLongPress').build(),
          onScrollLeft: p.get('onScrollLeft').build(),
          onScrollRight: p.get('onScrollRight').build(),
          onScrollUp: p.get('onScrollUp').build(),
          onScrollDown: p.get('onScrollDown').build(),
          onIncrease: p.get('onIncrease').build(),
          onDecrease: p.get('onDecrease').build(),
          onCopy: p.get('onCopy').build(),
          onCut: p.get('onCut').build(),
          onPaste: p.get('onPaste').build(),
          onDismiss: p.get('onDismiss').build(),
          onMoveCursorForwardByCharacter: p.get('onMoveCursorForwardByCharacter').build(),
          onMoveCursorBackwardByCharacter: p.get('onMoveCursorBackwardByCharacter').build(),
          onSetSelection: p.get('onSetSelection').build(),
          onSetText: p.get('onSetText').build(),
          onDidGainAccessibilityFocus: p.get('onDidGainAccessibilityFocus').build(),
          onDidLoseAccessibilityFocus: p.get('onDidLoseAccessibilityFocus').build(),
          customSemanticsActions: p.get('customSemanticsActions').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
    mateDeclare('container', container);
    mateDeclare('explicitChildNodes', explicitChildNodes);
    mateDeclare('excludeSemantics', excludeSemantics);
    mateDeclare('enabled', enabled);
    mateDeclare('checked', checked);
    mateDeclare('mixed', mixed);
    mateDeclare('selected', selected);
    mateDeclare('toggled', toggled);
    mateDeclare('button', button);
    mateDeclare('slider', slider);
    mateDeclare('keyboardKey', keyboardKey);
    mateDeclare('link', link);
    mateDeclare('header', header);
    mateDeclare('textField', textField);
    mateDeclare('readOnly', readOnly);
    mateDeclare('focusable', focusable);
    mateDeclare('focused', focused);
    mateDeclare('inMutuallyExclusiveGroup', inMutuallyExclusiveGroup);
    mateDeclare('obscured', obscured);
    mateDeclare('multiline', multiline);
    mateDeclare('scopesRoute', scopesRoute);
    mateDeclare('namesRoute', namesRoute);
    mateDeclare('hidden', hidden);
    mateDeclare('image', image);
    mateDeclare('liveRegion', liveRegion);
    mateDeclare('maxValueLength', maxValueLength);
    mateDeclare('currentValueLength', currentValueLength);
    mateDeclare('label', label);
    mateDeclare('attributedLabel', attributedLabel);
    mateDeclare('value', value);
    mateDeclare('attributedValue', attributedValue);
    mateDeclare('increasedValue', increasedValue);
    mateDeclare('attributedIncreasedValue', attributedIncreasedValue);
    mateDeclare('decreasedValue', decreasedValue);
    mateDeclare('attributedDecreasedValue', attributedDecreasedValue);
    mateDeclare('hint', hint);
    mateDeclare('attributedHint', attributedHint);
    mateDeclare('tooltip', tooltip);
    mateDeclare('onTapHint', onTapHint);
    mateDeclare('onLongPressHint', onLongPressHint);
    mateDeclare('textDirection', textDirection);
    mateDeclare('sortKey', sortKey);
    mateDeclare('tagForChildren', tagForChildren);
    mateDeclare('onTap', onTap);
    mateDeclare('onLongPress', onLongPress);
    mateDeclare('onScrollLeft', onScrollLeft);
    mateDeclare('onScrollRight', onScrollRight);
    mateDeclare('onScrollUp', onScrollUp);
    mateDeclare('onScrollDown', onScrollDown);
    mateDeclare('onIncrease', onIncrease);
    mateDeclare('onDecrease', onDecrease);
    mateDeclare('onCopy', onCopy);
    mateDeclare('onCut', onCut);
    mateDeclare('onPaste', onPaste);
    mateDeclare('onDismiss', onDismiss);
    mateDeclare('onMoveCursorForwardByCharacter', onMoveCursorForwardByCharacter);
    mateDeclare('onMoveCursorBackwardByCharacter', onMoveCursorBackwardByCharacter);
    mateDeclare('onSetSelection', onSetSelection);
    mateDeclare('onSetText', onSetText);
    mateDeclare('onDidGainAccessibilityFocus', onDidGainAccessibilityFocus);
    mateDeclare('onDidLoseAccessibilityFocus', onDidLoseAccessibilityFocus);
    mateDeclare('customSemanticsActions', customSemanticsActions);
  }

  /// Semantics Semantics.fromProperties({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, required SemanticsProperties properties})
  Semantics$Mate.fromProperties({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {bool container = false} , defaultValue:Literal
    bool container = false,

    /// optionalParameters: {bool explicitChildNodes = false} , defaultValue:Literal
    bool explicitChildNodes = false,

    /// optionalParameters: {bool excludeSemantics = false} , defaultValue:Literal
    bool excludeSemantics = false,

    /// optionalParameters: {required SemanticsProperties properties} , defaultValue:none
    required SemanticsProperties properties,
  }) : super.fromProperties(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          properties: properties,
        ) {
    mateBuilder = (p) => Semantics$Mate.fromProperties(
          key: p.get('key').build(),
          child: p.get('child').build(),
          container: p.get('container').build(),
          explicitChildNodes: p.get('explicitChildNodes').build(),
          excludeSemantics: p.get('excludeSemantics').build(),
          properties: p.get('properties').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
    mateDeclare('container', container);
    mateDeclare('explicitChildNodes', explicitChildNodes);
    mateDeclare('excludeSemantics', excludeSemantics);
    mateDeclare('properties', properties);
  }
}

/// class MergeSemantics extends SingleChildRenderObjectWidget
class MergeSemantics$Mate extends MergeSemantics with Mate {
  /// MergeSemantics MergeSemantics({Key? key, Widget? child})
  MergeSemantics$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilder = (p) => MergeSemantics$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
  }
}

/// class BlockSemantics extends SingleChildRenderObjectWidget
class BlockSemantics$Mate extends BlockSemantics with Mate {
  /// BlockSemantics BlockSemantics({Key? key, bool blocking = true, Widget? child})
  BlockSemantics$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {bool blocking = true} , defaultValue:Literal
    bool blocking = true,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          blocking: blocking,
          child: child,
        ) {
    mateBuilder = (p) => BlockSemantics$Mate(
          key: p.get('key').build(),
          blocking: p.get('blocking').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('blocking', blocking);
    mateDeclare('child', child);
  }
}

/// class ExcludeSemantics extends SingleChildRenderObjectWidget
class ExcludeSemantics$Mate extends ExcludeSemantics with Mate {
  /// ExcludeSemantics ExcludeSemantics({Key? key, bool excluding = true, Widget? child})
  ExcludeSemantics$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {bool excluding = true} , defaultValue:Literal
    bool excluding = true,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          excluding: excluding,
          child: child,
        ) {
    mateBuilder = (p) => ExcludeSemantics$Mate(
          key: p.get('key').build(),
          excluding: p.get('excluding').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('excluding', excluding);
    mateDeclare('child', child);
  }
}

/// class IndexedSemantics extends SingleChildRenderObjectWidget
class IndexedSemantics$Mate extends IndexedSemantics with Mate {
  /// IndexedSemantics IndexedSemantics({Key? key, required int index, Widget? child})
  IndexedSemantics$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required int index} , defaultValue:none
    required int index,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,
  }) : super(
          key: key,
          index: index,
          child: child,
        ) {
    mateBuilder = (p) => IndexedSemantics$Mate(
          key: p.get('key').build(),
          index: p.get('index').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('index', index);
    mateDeclare('child', child);
  }
}

/// class KeyedSubtree extends StatelessWidget
class KeyedSubtree$Mate extends KeyedSubtree with Mate {
  /// KeyedSubtree KeyedSubtree({Key? key, required Widget child})
  KeyedSubtree$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Widget child} , defaultValue:none
    required Widget child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilder = (p) => KeyedSubtree$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateDeclare('key', key);
    mateDeclare('child', child);
  }
}

/// class Builder extends StatelessWidget
class Builder$Mate extends Builder with Mate {
  /// Builder Builder({Key? key, required Widget Function(BuildContext) builder})
  Builder$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Widget Function(BuildContext) builder} , defaultValue:none
    required WidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateBuilder = (p) => Builder$Mate(
          key: p.get('key').build(),
          builder: p.get('builder').build(),
        );
    mateDeclare('key', key);
    mateDeclare('builder', builder);
  }
}

/// class StatefulBuilder extends StatefulWidget
class StatefulBuilder$Mate extends StatefulBuilder with Mate {
  /// StatefulBuilder StatefulBuilder({Key? key, required Widget Function(BuildContext, void Function(void Function())) builder})
  StatefulBuilder$Mate({
    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,

    /// optionalParameters: {required Widget Function(BuildContext, void Function(void Function())) builder} , defaultValue:none
    required StatefulWidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateBuilder = (p) => StatefulBuilder$Mate(
          key: p.get('key').build(),
          builder: p.get('builder').build(),
        );
    mateDeclare('key', key);
    mateDeclare('builder', builder);
  }
}

/// class ColoredBox extends SingleChildRenderObjectWidget
class ColoredBox$Mate extends ColoredBox with Mate {
  /// ColoredBox ColoredBox({required Color color, Widget? child, Key? key})
  ColoredBox$Mate({
    /// optionalParameters: {required Color color} , defaultValue:none
    required Color color,

    /// optionalParameters: {Widget? child} , defaultValue:none
    Widget? child,

    /// optionalParameters: {Key? key} , defaultValue:none
    Key? key,
  }) : super(
          color: color,
          child: child,
          key: key,
        ) {
    mateBuilder = (p) => ColoredBox$Mate(
          color: p.get('color').build(),
          child: p.get('child').build(),
          key: p.get('key').build(),
        );
    mateDeclare('color', color);
    mateDeclare('child', child);
    mateDeclare('key', key);
  }
}
