// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/widgets/basic.dart';
import 'package:note/mate.dart';
import 'package:flutter/src/foundation/key.dart';
import 'dart:ui';
import 'package:flutter/src/widgets/framework.dart';
import 'dart:core';
import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/rendering/custom_paint.dart';
import 'package:flutter/animation.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/painting.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/rendering/layer.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/painting/edge_insets.dart';
import 'package:flutter/src/rendering/shifted_box.dart';
import 'package:flutter/src/rendering/custom_layout.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:flutter/src/painting/basic_types.dart';
import 'package:flutter/src/rendering/stack.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/src/rendering/flex.dart';
import 'package:flutter/src/rendering/wrap.dart';
import 'package:flutter/src/rendering/flow.dart';
import 'package:flutter/src/painting/inline_span.dart';
import 'package:flutter/src/painting/text_painter.dart';
import 'package:flutter/src/painting/strut_style.dart';
import 'package:flutter/src/rendering/selection.dart';
import 'package:flutter/src/animation/animation.dart';
import 'package:flutter/src/painting/decoration_image.dart';
import 'package:flutter/src/services/asset_bundle.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/services.dart';
import 'package:flutter/src/semantics/semantics.dart';
export 'package:flutter/animation.dart';
export 'package:flutter/painting.dart';

/// class Directionality extends _UbiquitousInheritedWidget
class Directionality$Mate extends Directionality with Mate {
  /// Directionality Directionality({Key? key, required TextDirection textDirection, required Widget child})
  Directionality$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required TextDirection textDirection} , default:none
    required TextDirection textDirection,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          textDirection: textDirection,
          child: child,
        ) {
    mateBuilderName = 'Directionality';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Directionality$Mate(
          key: p.get('key').build(),
          textDirection: p.get('textDirection').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Opacity extends SingleChildRenderObjectWidget
class Opacity$Mate extends Opacity with Mate {
  /// Opacity Opacity({Key? key, required double opacity, bool alwaysIncludeSemantics = false, Widget? child})
  Opacity$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required double opacity} , default:none
    required double opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , default:processed=BooleanLiteralImpl
    bool alwaysIncludeSemantics = false,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateBuilderName = 'Opacity';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Opacity$Mate(
          key: p.get('key').build(),
          opacity: p.get('opacity').build(),
          alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'opacity',
      opacity,
      isNamed: true,
    );
    mateUse(
      'alwaysIncludeSemantics',
      alwaysIncludeSemantics,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class ShaderMask extends SingleChildRenderObjectWidget
class ShaderMask$Mate extends ShaderMask with Mate {
  /// ShaderMask ShaderMask({Key? key, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate, Widget? child})
  ShaderMask$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Shader Function(Rect) shaderCallback} , default:none
    required ShaderCallback shaderCallback,

    /// optionalParameters: {BlendMode blendMode = BlendMode.modulate} , default:processed=PrefixedIdentifierImpl
    BlendMode blendMode = BlendMode.modulate,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
          child: child,
        ) {
    mateBuilderName = 'ShaderMask';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ShaderMask$Mate(
          key: p.get('key').build(),
          shaderCallback: p.get('shaderCallback').build(),
          blendMode: p.get('blendMode').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'shaderCallback',
      shaderCallback,
      isNamed: true,
    );
    mateUse(
      'blendMode',
      blendMode,
      isNamed: true,
      defaultValue: BlendMode.modulate,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class BackdropFilter extends SingleChildRenderObjectWidget
class BackdropFilter$Mate extends BackdropFilter with Mate {
  /// BackdropFilter BackdropFilter({Key? key, required ImageFilter filter, Widget? child, BlendMode blendMode = BlendMode.srcOver})
  BackdropFilter$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required ImageFilter filter} , default:none
    required ImageFilter filter,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {BlendMode blendMode = BlendMode.srcOver} , default:processed=PrefixedIdentifierImpl
    BlendMode blendMode = BlendMode.srcOver,
  }) : super(
          key: key,
          filter: filter,
          child: child,
          blendMode: blendMode,
        ) {
    mateBuilderName = 'BackdropFilter';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => BackdropFilter$Mate(
          key: p.get('key').build(),
          filter: p.get('filter').build(),
          child: p.get('child').build(),
          blendMode: p.get('blendMode').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'filter',
      filter,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'blendMode',
      blendMode,
      isNamed: true,
      defaultValue: BlendMode.srcOver,
    );
  }
}

/// class CustomPaint extends SingleChildRenderObjectWidget
class CustomPaint$Mate extends CustomPaint with Mate {
  /// CustomPaint CustomPaint({Key? key, CustomPainter? painter, CustomPainter? foregroundPainter, Size size = Size.zero, bool isComplex = false, bool willChange = false, Widget? child})
  CustomPaint$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {CustomPainter? painter} , default:none
    CustomPainter? painter,

    /// optionalParameters: {CustomPainter? foregroundPainter} , default:none
    CustomPainter? foregroundPainter,

    /// optionalParameters: {Size size = Size.zero} , default:processed=PrefixedIdentifierImpl
    Size size = Size.zero,

    /// optionalParameters: {bool isComplex = false} , default:processed=BooleanLiteralImpl
    bool isComplex = false,

    /// optionalParameters: {bool willChange = false} , default:processed=BooleanLiteralImpl
    bool willChange = false,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          painter: painter,
          foregroundPainter: foregroundPainter,
          size: size,
          isComplex: isComplex,
          willChange: willChange,
          child: child,
        ) {
    mateBuilderName = 'CustomPaint';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => CustomPaint$Mate(
          key: p.get('key').build(),
          painter: p.get('painter').build(),
          foregroundPainter: p.get('foregroundPainter').build(),
          size: p.get('size').build(),
          isComplex: p.get('isComplex').build(),
          willChange: p.get('willChange').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'painter',
      painter,
      isNamed: true,
    );
    mateUse(
      'foregroundPainter',
      foregroundPainter,
      isNamed: true,
    );
    mateUse(
      'size',
      size,
      isNamed: true,
      defaultValue: Size.zero,
    );
    mateUse(
      'isComplex',
      isComplex,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'willChange',
      willChange,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class ClipRect extends SingleChildRenderObjectWidget
class ClipRect$Mate extends ClipRect with Mate {
  /// ClipRect ClipRect({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.hardEdge, Widget? child})
  ClipRect$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , default:none
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.hardEdge,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilderName = 'ClipRect';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ClipRect$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'clipper',
      clipper,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.hardEdge,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class ClipRRect extends SingleChildRenderObjectWidget
class ClipRRect$Mate extends ClipRRect with Mate {
  /// ClipRRect ClipRRect({Key? key, BorderRadiusGeometry? borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipRRect$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {BorderRadiusGeometry? borderRadius = BorderRadius.zero} , default:processed=PrefixedIdentifierImpl
    BorderRadiusGeometry? borderRadius = BorderRadius.zero,

    /// optionalParameters: {CustomClipper<RRect>? clipper} , default:none
    CustomClipper<RRect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.antiAlias,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilderName = 'ClipRRect';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ClipRRect$Mate(
          key: p.get('key').build(),
          borderRadius: p.get('borderRadius').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'borderRadius',
      borderRadius,
      isNamed: true,
      defaultValue: BorderRadius.zero,
    );
    mateUse(
      'clipper',
      clipper,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.antiAlias,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class ClipOval extends SingleChildRenderObjectWidget
class ClipOval$Mate extends ClipOval with Mate {
  /// ClipOval ClipOval({Key? key, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipOval$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , default:none
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.antiAlias,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilderName = 'ClipOval';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ClipOval$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'clipper',
      clipper,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.antiAlias,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class ClipPath extends SingleChildRenderObjectWidget
class ClipPath$Mate extends ClipPath with Mate {
  /// ClipPath ClipPath({Key? key, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias, Widget? child})
  ClipPath$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {CustomClipper<Path>? clipper} , default:none
    CustomClipper<Path>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.antiAlias,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilderName = 'ClipPath';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ClipPath$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'clipper',
      clipper,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.antiAlias,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class PhysicalModel extends SingleChildRenderObjectWidget
class PhysicalModel$Mate extends PhysicalModel with Mate {
  /// PhysicalModel PhysicalModel({Key? key, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalModel$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {BoxShape shape = BoxShape.rectangle} , default:processed=PrefixedIdentifierImpl
    BoxShape shape = BoxShape.rectangle,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.none,

    /// optionalParameters: {BorderRadius? borderRadius} , default:none
    BorderRadius? borderRadius,

    /// optionalParameters: {double elevation = 0.0} , default:processed=DoubleLiteralImpl
    double elevation = 0.0,

    /// optionalParameters: {required Color color} , default:none
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , default:unprocessed=InstanceCreationExpressionImpl
    required Color shadowColor,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateBuilderName = 'PhysicalModel';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => PhysicalModel$Mate(
          key: p.get('key').build(),
          shape: p.get('shape').build(),
          clipBehavior: p.get('clipBehavior').build(),
          borderRadius: p.get('borderRadius').build(),
          elevation: p.get('elevation').build(),
          color: p.get('color').build(),
          shadowColor: p.get('shadowColor').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'shape',
      shape,
      isNamed: true,
      defaultValue: BoxShape.rectangle,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.none,
    );
    mateUse(
      'borderRadius',
      borderRadius,
      isNamed: true,
    );
    mateUse(
      'elevation',
      elevation,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'color',
      color,
      isNamed: true,
    );
    mateUse(
      'shadowColor',
      shadowColor,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class PhysicalShape extends SingleChildRenderObjectWidget
class PhysicalShape$Mate extends PhysicalShape with Mate {
  /// PhysicalShape PhysicalShape({Key? key, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000), Widget? child})
  PhysicalShape$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required CustomClipper<Path> clipper} , default:none
    required CustomClipper<Path> clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.none,

    /// optionalParameters: {double elevation = 0.0} , default:processed=DoubleLiteralImpl
    double elevation = 0.0,

    /// optionalParameters: {required Color color} , default:none
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , default:unprocessed=InstanceCreationExpressionImpl
    required Color shadowColor,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
          child: child,
        ) {
    mateBuilderName = 'PhysicalShape';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => PhysicalShape$Mate(
          key: p.get('key').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          elevation: p.get('elevation').build(),
          color: p.get('color').build(),
          shadowColor: p.get('shadowColor').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'clipper',
      clipper,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.none,
    );
    mateUse(
      'elevation',
      elevation,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'color',
      color,
      isNamed: true,
    );
    mateUse(
      'shadowColor',
      shadowColor,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Transform extends SingleChildRenderObjectWidget
class Transform$Mate extends Transform with Mate {
  /// Transform Transform({Key? key, required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Matrix4 transform} , default:none
    required Matrix4 transform,

    /// optionalParameters: {Offset? origin} , default:none
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment} , default:none
    AlignmentGeometry? alignment,

    /// optionalParameters: {bool transformHitTests = true} , default:processed=BooleanLiteralImpl
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , default:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          transform: transform,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilderName = 'Transform';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Transform$Mate(
          key: p.get('key').build(),
          transform: p.get('transform').build(),
          origin: p.get('origin').build(),
          alignment: p.get('alignment').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'transform',
      transform,
      isNamed: true,
    );
    mateUse(
      'origin',
      origin,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
    );
    mateUse(
      'transformHitTests',
      transformHitTests,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'filterQuality',
      filterQuality,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// Transform Transform.rotate({Key? key, required double angle, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.rotate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required double angle} , default:none
    required double angle,

    /// optionalParameters: {Offset? origin} , default:none
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry? alignment = Alignment.center,

    /// optionalParameters: {bool transformHitTests = true} , default:processed=BooleanLiteralImpl
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , default:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super.rotate(
          key: key,
          angle: angle,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilderName = 'Transform.rotate';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Transform$Mate.rotate(
          key: p.get('key').build(),
          angle: p.get('angle').build(),
          origin: p.get('origin').build(),
          alignment: p.get('alignment').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'angle',
      angle,
      isNamed: true,
    );
    mateUse(
      'origin',
      origin,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'transformHitTests',
      transformHitTests,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'filterQuality',
      filterQuality,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// Transform Transform.translate({Key? key, required Offset offset, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.translate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Offset offset} , default:none
    required Offset offset,

    /// optionalParameters: {bool transformHitTests = true} , default:processed=BooleanLiteralImpl
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , default:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super.translate(
          key: key,
          offset: offset,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilderName = 'Transform.translate';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Transform$Mate.translate(
          key: p.get('key').build(),
          offset: p.get('offset').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'offset',
      offset,
      isNamed: true,
    );
    mateUse(
      'transformHitTests',
      transformHitTests,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'filterQuality',
      filterQuality,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// Transform Transform.scale({Key? key, double? scale, double? scaleX, double? scaleY, Offset? origin, AlignmentGeometry? alignment = Alignment.center, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.scale({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double? scale} , default:none
    double? scale,

    /// optionalParameters: {double? scaleX} , default:none
    double? scaleX,

    /// optionalParameters: {double? scaleY} , default:none
    double? scaleY,

    /// optionalParameters: {Offset? origin} , default:none
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry? alignment = Alignment.center,

    /// optionalParameters: {bool transformHitTests = true} , default:processed=BooleanLiteralImpl
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , default:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super.scale(
          key: key,
          scale: scale,
          scaleX: scaleX,
          scaleY: scaleY,
          origin: origin,
          alignment: alignment,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilderName = 'Transform.scale';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Transform$Mate.scale(
          key: p.get('key').build(),
          scale: p.get('scale').build(),
          scaleX: p.get('scaleX').build(),
          scaleY: p.get('scaleY').build(),
          origin: p.get('origin').build(),
          alignment: p.get('alignment').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'scale',
      scale,
      isNamed: true,
    );
    mateUse(
      'scaleX',
      scaleX,
      isNamed: true,
    );
    mateUse(
      'scaleY',
      scaleY,
      isNamed: true,
    );
    mateUse(
      'origin',
      origin,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'transformHitTests',
      transformHitTests,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'filterQuality',
      filterQuality,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// Transform Transform.flip({Key? key, bool flipX = false, bool flipY = false, Offset? origin, bool transformHitTests = true, FilterQuality? filterQuality, Widget? child})
  Transform$Mate.flip({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {bool flipX = false} , default:processed=BooleanLiteralImpl
    bool flipX = false,

    /// optionalParameters: {bool flipY = false} , default:processed=BooleanLiteralImpl
    bool flipY = false,

    /// optionalParameters: {Offset? origin} , default:none
    Offset? origin,

    /// optionalParameters: {bool transformHitTests = true} , default:processed=BooleanLiteralImpl
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , default:none
    FilterQuality? filterQuality,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super.flip(
          key: key,
          flipX: flipX,
          flipY: flipY,
          origin: origin,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilderName = 'Transform.flip';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Transform$Mate.flip(
          key: p.get('key').build(),
          flipX: p.get('flipX').build(),
          flipY: p.get('flipY').build(),
          origin: p.get('origin').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'flipX',
      flipX,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'flipY',
      flipY,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'origin',
      origin,
      isNamed: true,
    );
    mateUse(
      'transformHitTests',
      transformHitTests,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'filterQuality',
      filterQuality,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class CompositedTransformTarget extends SingleChildRenderObjectWidget
class CompositedTransformTarget$Mate extends CompositedTransformTarget
    with Mate {
  /// CompositedTransformTarget CompositedTransformTarget({Key? key, required LayerLink link, Widget? child})
  CompositedTransformTarget$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required LayerLink link} , default:none
    required LayerLink link,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          link: link,
          child: child,
        ) {
    mateBuilderName = 'CompositedTransformTarget';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => CompositedTransformTarget$Mate(
          key: p.get('key').build(),
          link: p.get('link').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'link',
      link,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class CompositedTransformFollower extends SingleChildRenderObjectWidget
class CompositedTransformFollower$Mate extends CompositedTransformFollower
    with Mate {
  /// CompositedTransformFollower CompositedTransformFollower({Key? key, required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment targetAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, Widget? child})
  CompositedTransformFollower$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required LayerLink link} , default:none
    required LayerLink link,

    /// optionalParameters: {bool showWhenUnlinked = true} , default:processed=BooleanLiteralImpl
    bool showWhenUnlinked = true,

    /// optionalParameters: {Offset offset = Offset.zero} , default:processed=PrefixedIdentifierImpl
    Offset offset = Offset.zero,

    /// optionalParameters: {Alignment targetAnchor = Alignment.topLeft} , default:processed=PrefixedIdentifierImpl
    Alignment targetAnchor = Alignment.topLeft,

    /// optionalParameters: {Alignment followerAnchor = Alignment.topLeft} , default:processed=PrefixedIdentifierImpl
    Alignment followerAnchor = Alignment.topLeft,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          targetAnchor: targetAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {
    mateBuilderName = 'CompositedTransformFollower';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => CompositedTransformFollower$Mate(
          key: p.get('key').build(),
          link: p.get('link').build(),
          showWhenUnlinked: p.get('showWhenUnlinked').build(),
          offset: p.get('offset').build(),
          targetAnchor: p.get('targetAnchor').build(),
          followerAnchor: p.get('followerAnchor').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'link',
      link,
      isNamed: true,
    );
    mateUse(
      'showWhenUnlinked',
      showWhenUnlinked,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'offset',
      offset,
      isNamed: true,
      defaultValue: Offset.zero,
    );
    mateUse(
      'targetAnchor',
      targetAnchor,
      isNamed: true,
      defaultValue: Alignment.topLeft,
    );
    mateUse(
      'followerAnchor',
      followerAnchor,
      isNamed: true,
      defaultValue: Alignment.topLeft,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class FittedBox extends SingleChildRenderObjectWidget
class FittedBox$Mate extends FittedBox with Mate {
  /// FittedBox FittedBox({Key? key, BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, Clip clipBehavior = Clip.none, Widget? child})
  FittedBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {BoxFit fit = BoxFit.contain} , default:processed=PrefixedIdentifierImpl
    BoxFit fit = BoxFit.contain,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.none,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          fit: fit,
          alignment: alignment,
          clipBehavior: clipBehavior,
          child: child,
        ) {
    mateBuilderName = 'FittedBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => FittedBox$Mate(
          key: p.get('key').build(),
          fit: p.get('fit').build(),
          alignment: p.get('alignment').build(),
          clipBehavior: p.get('clipBehavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'fit',
      fit,
      isNamed: true,
      defaultValue: BoxFit.contain,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.none,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class FractionalTranslation extends SingleChildRenderObjectWidget
class FractionalTranslation$Mate extends FractionalTranslation with Mate {
  /// FractionalTranslation FractionalTranslation({Key? key, required Offset translation, bool transformHitTests = true, Widget? child})
  FractionalTranslation$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Offset translation} , default:none
    required Offset translation,

    /// optionalParameters: {bool transformHitTests = true} , default:processed=BooleanLiteralImpl
    bool transformHitTests = true,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {
    mateBuilderName = 'FractionalTranslation';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => FractionalTranslation$Mate(
          key: p.get('key').build(),
          translation: p.get('translation').build(),
          transformHitTests: p.get('transformHitTests').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'translation',
      translation,
      isNamed: true,
    );
    mateUse(
      'transformHitTests',
      transformHitTests,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class RotatedBox extends SingleChildRenderObjectWidget
class RotatedBox$Mate extends RotatedBox with Mate {
  /// RotatedBox RotatedBox({Key? key, required int quarterTurns, Widget? child})
  RotatedBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required int quarterTurns} , default:none
    required int quarterTurns,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          quarterTurns: quarterTurns,
          child: child,
        ) {
    mateBuilderName = 'RotatedBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => RotatedBox$Mate(
          key: p.get('key').build(),
          quarterTurns: p.get('quarterTurns').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'quarterTurns',
      quarterTurns,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Padding extends SingleChildRenderObjectWidget
class Padding$Mate extends Padding with Mate {
  /// Padding Padding({Key? key, required EdgeInsetsGeometry padding, Widget? child})
  Padding$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required EdgeInsetsGeometry padding} , default:none
    required EdgeInsetsGeometry padding,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          padding: padding,
          child: child,
        ) {
    mateBuilderName = 'Padding';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Padding$Mate(
          key: p.get('key').build(),
          padding: p.get('padding').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'padding',
      padding,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Align extends SingleChildRenderObjectWidget
class Align$Mate extends Align with Mate {
  /// Align Align({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  Align$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {double? widthFactor} , default:none
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , default:none
    double? heightFactor,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateBuilderName = 'Align';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Align$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          widthFactor: p.get('widthFactor').build(),
          heightFactor: p.get('heightFactor').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'widthFactor',
      widthFactor,
      isNamed: true,
    );
    mateUse(
      'heightFactor',
      heightFactor,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Center extends Align
class Center$Mate extends Center with Mate {
  /// Center Center({Key? key, double? widthFactor, double? heightFactor, Widget? child})
  Center$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double? widthFactor} , default:none
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , default:none
    double? heightFactor,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateBuilderName = 'Center';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Center$Mate(
          key: p.get('key').build(),
          widthFactor: p.get('widthFactor').build(),
          heightFactor: p.get('heightFactor').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'widthFactor',
      widthFactor,
      isNamed: true,
    );
    mateUse(
      'heightFactor',
      heightFactor,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class CustomSingleChildLayout extends SingleChildRenderObjectWidget
class CustomSingleChildLayout$Mate extends CustomSingleChildLayout with Mate {
  /// CustomSingleChildLayout CustomSingleChildLayout({Key? key, required SingleChildLayoutDelegate delegate, Widget? child})
  CustomSingleChildLayout$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required SingleChildLayoutDelegate delegate} , default:none
    required SingleChildLayoutDelegate delegate,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          delegate: delegate,
          child: child,
        ) {
    mateBuilderName = 'CustomSingleChildLayout';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => CustomSingleChildLayout$Mate(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'delegate',
      delegate,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class LayoutId extends ParentDataWidget<MultiChildLayoutParentData>
class LayoutId$Mate extends LayoutId with Mate {
  /// LayoutId LayoutId({Key? key, required Object id, required Widget child})
  LayoutId$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Object id} , default:none
    required Object id,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          id: id,
          child: child,
        ) {
    mateBuilderName = 'LayoutId';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => LayoutId$Mate(
          key: p.get('key').build(),
          id: p.get('id').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'id',
      id,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class CustomMultiChildLayout extends MultiChildRenderObjectWidget
class CustomMultiChildLayout$Mate extends CustomMultiChildLayout with Mate {
  /// CustomMultiChildLayout CustomMultiChildLayout({Key? key, required MultiChildLayoutDelegate delegate, List<Widget> children = const <Widget>[]})
  CustomMultiChildLayout$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required MultiChildLayoutDelegate delegate} , default:none
    required MultiChildLayoutDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
        ) {
    mateBuilderName = 'CustomMultiChildLayout';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => CustomMultiChildLayout$Mate(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'delegate',
      delegate,
      isNamed: true,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class SizedBox extends SingleChildRenderObjectWidget
class SizedBox$Mate extends SizedBox with Mate {
  /// SizedBox SizedBox({Key? key, double? width, double? height, Widget? child})
  SizedBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double? width} , default:none
    double? width,

    /// optionalParameters: {double? height} , default:none
    double? height,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          width: width,
          height: height,
          child: child,
        ) {
    mateBuilderName = 'SizedBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SizedBox$Mate(
          key: p.get('key').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'width',
      width,
      isNamed: true,
    );
    mateUse(
      'height',
      height,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// SizedBox SizedBox.expand({Key? key, Widget? child})
  SizedBox$Mate.expand({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super.expand(
          key: key,
          child: child,
        ) {
    mateBuilderName = 'SizedBox.expand';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SizedBox$Mate.expand(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// SizedBox SizedBox.shrink({Key? key, Widget? child})
  SizedBox$Mate.shrink({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super.shrink(
          key: key,
          child: child,
        ) {
    mateBuilderName = 'SizedBox.shrink';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SizedBox$Mate.shrink(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// SizedBox SizedBox.fromSize({Key? key, Widget? child, Size? size})
  SizedBox$Mate.fromSize({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {Size? size} , default:none
    Size? size,
  }) : super.fromSize(
          key: key,
          child: child,
          size: size,
        ) {
    mateBuilderName = 'SizedBox.fromSize';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SizedBox$Mate.fromSize(
          key: p.get('key').build(),
          child: p.get('child').build(),
          size: p.get('size').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'size',
      size,
      isNamed: true,
    );
  }

  /// SizedBox SizedBox.square({Key? key, Widget? child, double? dimension})
  SizedBox$Mate.square({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {double? dimension} , default:none
    double? dimension,
  }) : super.square(
          key: key,
          child: child,
          dimension: dimension,
        ) {
    mateBuilderName = 'SizedBox.square';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SizedBox$Mate.square(
          key: p.get('key').build(),
          child: p.get('child').build(),
          dimension: p.get('dimension').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'dimension',
      dimension,
      isNamed: true,
    );
  }
}

/// class ConstrainedBox extends SingleChildRenderObjectWidget
class ConstrainedBox$Mate extends ConstrainedBox with Mate {
  /// ConstrainedBox ConstrainedBox({Key? key, required BoxConstraints constraints, Widget? child})
  ConstrainedBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required BoxConstraints constraints} , default:none
    required BoxConstraints constraints,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          constraints: constraints,
          child: child,
        ) {
    mateBuilderName = 'ConstrainedBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ConstrainedBox$Mate(
          key: p.get('key').build(),
          constraints: p.get('constraints').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'constraints',
      constraints,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class ConstraintsTransformBox extends SingleChildRenderObjectWidget
class ConstraintsTransformBox$Mate extends ConstraintsTransformBox with Mate {
  /// ConstraintsTransformBox ConstraintsTransformBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, required BoxConstraints Function(BoxConstraints) constraintsTransform, Clip clipBehavior = Clip.none, String debugTransformType = ''})
  ConstraintsTransformBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {required BoxConstraints Function(BoxConstraints) constraintsTransform} , default:none
    required BoxConstraintsTransform constraintsTransform,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.none,

    /// optionalParameters: {String debugTransformType = ''} , default:processed=SimpleStringLiteralImpl
    String debugTransformType = '',
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constraintsTransform: constraintsTransform,
          clipBehavior: clipBehavior,
          debugTransformType: debugTransformType,
        ) {
    mateBuilderName = 'ConstraintsTransformBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ConstraintsTransformBox$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
          textDirection: p.get('textDirection').build(),
          alignment: p.get('alignment').build(),
          constraintsTransform: p.get('constraintsTransform').build(),
          clipBehavior: p.get('clipBehavior').build(),
          debugTransformType: p.get('debugTransformType').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'constraintsTransform',
      constraintsTransform,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.none,
    );
    mateUse(
      'debugTransformType',
      debugTransformType,
      isNamed: true,
      defaultValue: '',
    );
  }
}

/// class UnconstrainedBox extends StatelessWidget
class UnconstrainedBox$Mate extends UnconstrainedBox with Mate {
  /// UnconstrainedBox UnconstrainedBox({Key? key, Widget? child, TextDirection? textDirection, AlignmentGeometry alignment = Alignment.center, Axis? constrainedAxis, Clip clipBehavior = Clip.none})
  UnconstrainedBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {Axis? constrainedAxis} , default:none
    Axis? constrainedAxis,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.none,
  }) : super(
          key: key,
          child: child,
          textDirection: textDirection,
          alignment: alignment,
          constrainedAxis: constrainedAxis,
          clipBehavior: clipBehavior,
        ) {
    mateBuilderName = 'UnconstrainedBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => UnconstrainedBox$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
          textDirection: p.get('textDirection').build(),
          alignment: p.get('alignment').build(),
          constrainedAxis: p.get('constrainedAxis').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'constrainedAxis',
      constrainedAxis,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.none,
    );
  }
}

/// class FractionallySizedBox extends SingleChildRenderObjectWidget
class FractionallySizedBox$Mate extends FractionallySizedBox with Mate {
  /// FractionallySizedBox FractionallySizedBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? widthFactor, double? heightFactor, Widget? child})
  FractionallySizedBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {double? widthFactor} , default:none
    double? widthFactor,

    /// optionalParameters: {double? heightFactor} , default:none
    double? heightFactor,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          widthFactor: widthFactor,
          heightFactor: heightFactor,
          child: child,
        ) {
    mateBuilderName = 'FractionallySizedBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => FractionallySizedBox$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          widthFactor: p.get('widthFactor').build(),
          heightFactor: p.get('heightFactor').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'widthFactor',
      widthFactor,
      isNamed: true,
    );
    mateUse(
      'heightFactor',
      heightFactor,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class LimitedBox extends SingleChildRenderObjectWidget
class LimitedBox$Mate extends LimitedBox with Mate {
  /// LimitedBox LimitedBox({Key? key, double maxWidth = double.infinity, double maxHeight = double.infinity, Widget? child})
  LimitedBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double maxWidth = double.infinity} , default:processed=PrefixedIdentifierImpl
    double maxWidth = double.infinity,

    /// optionalParameters: {double maxHeight = double.infinity} , default:processed=PrefixedIdentifierImpl
    double maxHeight = double.infinity,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateBuilderName = 'LimitedBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => LimitedBox$Mate(
          key: p.get('key').build(),
          maxWidth: p.get('maxWidth').build(),
          maxHeight: p.get('maxHeight').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'maxWidth',
      maxWidth,
      isNamed: true,
      defaultValue: double.infinity,
    );
    mateUse(
      'maxHeight',
      maxHeight,
      isNamed: true,
      defaultValue: double.infinity,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class OverflowBox extends SingleChildRenderObjectWidget
class OverflowBox$Mate extends OverflowBox with Mate {
  /// OverflowBox OverflowBox({Key? key, AlignmentGeometry alignment = Alignment.center, double? minWidth, double? maxWidth, double? minHeight, double? maxHeight, Widget? child})
  OverflowBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {double? minWidth} , default:none
    double? minWidth,

    /// optionalParameters: {double? maxWidth} , default:none
    double? maxWidth,

    /// optionalParameters: {double? minHeight} , default:none
    double? minHeight,

    /// optionalParameters: {double? maxHeight} , default:none
    double? maxHeight,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          alignment: alignment,
          minWidth: minWidth,
          maxWidth: maxWidth,
          minHeight: minHeight,
          maxHeight: maxHeight,
          child: child,
        ) {
    mateBuilderName = 'OverflowBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => OverflowBox$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          minWidth: p.get('minWidth').build(),
          maxWidth: p.get('maxWidth').build(),
          minHeight: p.get('minHeight').build(),
          maxHeight: p.get('maxHeight').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'minWidth',
      minWidth,
      isNamed: true,
    );
    mateUse(
      'maxWidth',
      maxWidth,
      isNamed: true,
    );
    mateUse(
      'minHeight',
      minHeight,
      isNamed: true,
    );
    mateUse(
      'maxHeight',
      maxHeight,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class SizedOverflowBox extends SingleChildRenderObjectWidget
class SizedOverflowBox$Mate extends SizedOverflowBox with Mate {
  /// SizedOverflowBox SizedOverflowBox({Key? key, required Size size, AlignmentGeometry alignment = Alignment.center, Widget? child})
  SizedOverflowBox$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Size size} , default:none
    required Size size,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          size: size,
          alignment: alignment,
          child: child,
        ) {
    mateBuilderName = 'SizedOverflowBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SizedOverflowBox$Mate(
          key: p.get('key').build(),
          size: p.get('size').build(),
          alignment: p.get('alignment').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'size',
      size,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Offstage extends SingleChildRenderObjectWidget
class Offstage$Mate extends Offstage with Mate {
  /// Offstage Offstage({Key? key, bool offstage = true, Widget? child})
  Offstage$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {bool offstage = true} , default:processed=BooleanLiteralImpl
    bool offstage = true,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          offstage: offstage,
          child: child,
        ) {
    mateBuilderName = 'Offstage';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Offstage$Mate(
          key: p.get('key').build(),
          offstage: p.get('offstage').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'offstage',
      offstage,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class AspectRatio extends SingleChildRenderObjectWidget
class AspectRatio$Mate extends AspectRatio with Mate {
  /// AspectRatio AspectRatio({Key? key, required double aspectRatio, Widget? child})
  AspectRatio$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required double aspectRatio} , default:none
    required double aspectRatio,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          aspectRatio: aspectRatio,
          child: child,
        ) {
    mateBuilderName = 'AspectRatio';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => AspectRatio$Mate(
          key: p.get('key').build(),
          aspectRatio: p.get('aspectRatio').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'aspectRatio',
      aspectRatio,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class IntrinsicWidth extends SingleChildRenderObjectWidget
class IntrinsicWidth$Mate extends IntrinsicWidth with Mate {
  /// IntrinsicWidth IntrinsicWidth({Key? key, double? stepWidth, double? stepHeight, Widget? child})
  IntrinsicWidth$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double? stepWidth} , default:none
    double? stepWidth,

    /// optionalParameters: {double? stepHeight} , default:none
    double? stepHeight,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {
    mateBuilderName = 'IntrinsicWidth';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => IntrinsicWidth$Mate(
          key: p.get('key').build(),
          stepWidth: p.get('stepWidth').build(),
          stepHeight: p.get('stepHeight').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'stepWidth',
      stepWidth,
      isNamed: true,
    );
    mateUse(
      'stepHeight',
      stepHeight,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class IntrinsicHeight extends SingleChildRenderObjectWidget
class IntrinsicHeight$Mate extends IntrinsicHeight with Mate {
  /// IntrinsicHeight IntrinsicHeight({Key? key, Widget? child})
  IntrinsicHeight$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilderName = 'IntrinsicHeight';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => IntrinsicHeight$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Baseline extends SingleChildRenderObjectWidget
class Baseline$Mate extends Baseline with Mate {
  /// Baseline Baseline({Key? key, required double baseline, required TextBaseline baselineType, Widget? child})
  Baseline$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required double baseline} , default:none
    required double baseline,

    /// optionalParameters: {required TextBaseline baselineType} , default:none
    required TextBaseline baselineType,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          baseline: baseline,
          baselineType: baselineType,
          child: child,
        ) {
    mateBuilderName = 'Baseline';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Baseline$Mate(
          key: p.get('key').build(),
          baseline: p.get('baseline').build(),
          baselineType: p.get('baselineType').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'baseline',
      baseline,
      isNamed: true,
    );
    mateUse(
      'baselineType',
      baselineType,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class SliverToBoxAdapter extends SingleChildRenderObjectWidget
class SliverToBoxAdapter$Mate extends SliverToBoxAdapter with Mate {
  /// SliverToBoxAdapter SliverToBoxAdapter({Key? key, Widget? child})
  SliverToBoxAdapter$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilderName = 'SliverToBoxAdapter';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SliverToBoxAdapter$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class SliverPadding extends SingleChildRenderObjectWidget
class SliverPadding$Mate extends SliverPadding with Mate {
  /// SliverPadding SliverPadding({Key? key, required EdgeInsetsGeometry padding, Widget? sliver})
  SliverPadding$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required EdgeInsetsGeometry padding} , default:none
    required EdgeInsetsGeometry padding,

    /// optionalParameters: {Widget? sliver} , default:none
    Widget? sliver,
  }) : super(
          key: key,
          padding: padding,
          sliver: sliver,
        ) {
    mateBuilderName = 'SliverPadding';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => SliverPadding$Mate(
          key: p.get('key').build(),
          padding: p.get('padding').build(),
          sliver: p.get('sliver').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'padding',
      padding,
      isNamed: true,
    );
    mateUse(
      'sliver',
      sliver,
      isNamed: true,
    );
  }
}

/// class ListBody extends MultiChildRenderObjectWidget
class ListBody$Mate extends ListBody with Mate {
  /// ListBody ListBody({Key? key, Axis mainAxis = Axis.vertical, bool reverse = false, List<Widget> children = const <Widget>[]})
  ListBody$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Axis mainAxis = Axis.vertical} , default:processed=PrefixedIdentifierImpl
    Axis mainAxis = Axis.vertical,

    /// optionalParameters: {bool reverse = false} , default:processed=BooleanLiteralImpl
    bool reverse = false,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxis: mainAxis,
          reverse: reverse,
          children: children,
        ) {
    mateBuilderName = 'ListBody';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ListBody$Mate(
          key: p.get('key').build(),
          mainAxis: p.get('mainAxis').build(),
          reverse: p.get('reverse').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'mainAxis',
      mainAxis,
      isNamed: true,
      defaultValue: Axis.vertical,
    );
    mateUse(
      'reverse',
      reverse,
      isNamed: true,
      defaultValue: false,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class Stack extends MultiChildRenderObjectWidget
class Stack$Mate extends Stack with Mate {
  /// Stack Stack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, StackFit fit = StackFit.loose, Clip clipBehavior = Clip.hardEdge, List<Widget> children = const <Widget>[]})
  Stack$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = AlignmentDirectional.topStart,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {StackFit fit = StackFit.loose} , default:processed=PrefixedIdentifierImpl
    StackFit fit = StackFit.loose,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.hardEdge,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          fit: fit,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateBuilderName = 'Stack';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Stack$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          textDirection: p.get('textDirection').build(),
          fit: p.get('fit').build(),
          clipBehavior: p.get('clipBehavior').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: AlignmentDirectional.topStart,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'fit',
      fit,
      isNamed: true,
      defaultValue: StackFit.loose,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.hardEdge,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class IndexedStack extends Stack
class IndexedStack$Mate extends IndexedStack with Mate {
  /// IndexedStack IndexedStack({Key? key, AlignmentGeometry alignment = AlignmentDirectional.topStart, TextDirection? textDirection, Clip clipBehavior = Clip.hardEdge, StackFit sizing = StackFit.loose, int? index = 0, List<Widget> children = const <Widget>[]})
  IndexedStack$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {AlignmentGeometry alignment = AlignmentDirectional.topStart} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = AlignmentDirectional.topStart,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.hardEdge,

    /// optionalParameters: {StackFit sizing = StackFit.loose} , default:processed=PrefixedIdentifierImpl
    StackFit sizing = StackFit.loose,

    /// optionalParameters: {int? index = 0} , default:processed=IntegerLiteralImpl
    int? index = 0,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          alignment: alignment,
          textDirection: textDirection,
          clipBehavior: clipBehavior,
          sizing: sizing,
          index: index,
          children: children,
        ) {
    mateBuilderName = 'IndexedStack';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => IndexedStack$Mate(
          key: p.get('key').build(),
          alignment: p.get('alignment').build(),
          textDirection: p.get('textDirection').build(),
          clipBehavior: p.get('clipBehavior').build(),
          sizing: p.get('sizing').build(),
          index: p.get('index').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: AlignmentDirectional.topStart,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.hardEdge,
    );
    mateUse(
      'sizing',
      sizing,
      isNamed: true,
      defaultValue: StackFit.loose,
    );
    mateUse(
      'index',
      index,
      isNamed: true,
      defaultValue: 0,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class Positioned extends ParentDataWidget<StackParentData>
class Positioned$Mate extends Positioned with Mate {
  /// Positioned Positioned({Key? key, double? left, double? top, double? right, double? bottom, double? width, double? height, required Widget child})
  Positioned$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double? left} , default:none
    double? left,

    /// optionalParameters: {double? top} , default:none
    double? top,

    /// optionalParameters: {double? right} , default:none
    double? right,

    /// optionalParameters: {double? bottom} , default:none
    double? bottom,

    /// optionalParameters: {double? width} , default:none
    double? width,

    /// optionalParameters: {double? height} , default:none
    double? height,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateBuilderName = 'Positioned';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Positioned$Mate(
          key: p.get('key').build(),
          left: p.get('left').build(),
          top: p.get('top').build(),
          right: p.get('right').build(),
          bottom: p.get('bottom').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'left',
      left,
      isNamed: true,
    );
    mateUse(
      'top',
      top,
      isNamed: true,
    );
    mateUse(
      'right',
      right,
      isNamed: true,
    );
    mateUse(
      'bottom',
      bottom,
      isNamed: true,
    );
    mateUse(
      'width',
      width,
      isNamed: true,
    );
    mateUse(
      'height',
      height,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// Positioned Positioned.fromRect({Key? key, required Rect rect, required Widget child})
  Positioned$Mate.fromRect({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Rect rect} , default:none
    required Rect rect,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super.fromRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateBuilderName = 'Positioned.fromRect';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Positioned$Mate.fromRect(
          key: p.get('key').build(),
          rect: p.get('rect').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'rect',
      rect,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// Positioned Positioned.fromRelativeRect({Key? key, required RelativeRect rect, required Widget child})
  Positioned$Mate.fromRelativeRect({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required RelativeRect rect} , default:none
    required RelativeRect rect,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super.fromRelativeRect(
          key: key,
          rect: rect,
          child: child,
        ) {
    mateBuilderName = 'Positioned.fromRelativeRect';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Positioned$Mate.fromRelativeRect(
          key: p.get('key').build(),
          rect: p.get('rect').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'rect',
      rect,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }

  /// Positioned Positioned.fill({Key? key, double? left = 0.0, double? top = 0.0, double? right = 0.0, double? bottom = 0.0, required Widget child})
  Positioned$Mate.fill({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double? left = 0.0} , default:processed=DoubleLiteralImpl
    double? left = 0.0,

    /// optionalParameters: {double? top = 0.0} , default:processed=DoubleLiteralImpl
    double? top = 0.0,

    /// optionalParameters: {double? right = 0.0} , default:processed=DoubleLiteralImpl
    double? right = 0.0,

    /// optionalParameters: {double? bottom = 0.0} , default:processed=DoubleLiteralImpl
    double? bottom = 0.0,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super.fill(
          key: key,
          left: left,
          top: top,
          right: right,
          bottom: bottom,
          child: child,
        ) {
    mateBuilderName = 'Positioned.fill';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Positioned$Mate.fill(
          key: p.get('key').build(),
          left: p.get('left').build(),
          top: p.get('top').build(),
          right: p.get('right').build(),
          bottom: p.get('bottom').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'left',
      left,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'top',
      top,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'right',
      right,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'bottom',
      bottom,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class PositionedDirectional extends StatelessWidget
class PositionedDirectional$Mate extends PositionedDirectional with Mate {
  /// PositionedDirectional PositionedDirectional({Key? key, double? start, double? top, double? end, double? bottom, double? width, double? height, required Widget child})
  PositionedDirectional$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {double? start} , default:none
    double? start,

    /// optionalParameters: {double? top} , default:none
    double? top,

    /// optionalParameters: {double? end} , default:none
    double? end,

    /// optionalParameters: {double? bottom} , default:none
    double? bottom,

    /// optionalParameters: {double? width} , default:none
    double? width,

    /// optionalParameters: {double? height} , default:none
    double? height,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          start: start,
          top: top,
          end: end,
          bottom: bottom,
          width: width,
          height: height,
          child: child,
        ) {
    mateBuilderName = 'PositionedDirectional';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => PositionedDirectional$Mate(
          key: p.get('key').build(),
          start: p.get('start').build(),
          top: p.get('top').build(),
          end: p.get('end').build(),
          bottom: p.get('bottom').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'start',
      start,
      isNamed: true,
    );
    mateUse(
      'top',
      top,
      isNamed: true,
    );
    mateUse(
      'end',
      end,
      isNamed: true,
    );
    mateUse(
      'bottom',
      bottom,
      isNamed: true,
    );
    mateUse(
      'width',
      width,
      isNamed: true,
    );
    mateUse(
      'height',
      height,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Flex extends MultiChildRenderObjectWidget
class Flex$Mate extends Flex with Mate {
  /// Flex Flex({Key? key, required Axis direction, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Flex$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Axis direction} , default:none
    required Axis direction,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , default:processed=PrefixedIdentifierImpl
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , default:processed=PrefixedIdentifierImpl
    MainAxisSize mainAxisSize = MainAxisSize.max,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , default:processed=PrefixedIdentifierImpl
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , default:processed=PrefixedIdentifierImpl
    VerticalDirection verticalDirection = VerticalDirection.down,

    /// optionalParameters: {TextBaseline? textBaseline} , default:none
    TextBaseline? textBaseline,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.none,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateBuilderName = 'Flex';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Flex$Mate(
          key: p.get('key').build(),
          direction: p.get('direction').build(),
          mainAxisAlignment: p.get('mainAxisAlignment').build(),
          mainAxisSize: p.get('mainAxisSize').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          textBaseline: p.get('textBaseline').build(),
          clipBehavior: p.get('clipBehavior').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'direction',
      direction,
      isNamed: true,
    );
    mateUse(
      'mainAxisAlignment',
      mainAxisAlignment,
      isNamed: true,
      defaultValue: MainAxisAlignment.start,
    );
    mateUse(
      'mainAxisSize',
      mainAxisSize,
      isNamed: true,
      defaultValue: MainAxisSize.max,
    );
    mateUse(
      'crossAxisAlignment',
      crossAxisAlignment,
      isNamed: true,
      defaultValue: CrossAxisAlignment.center,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'verticalDirection',
      verticalDirection,
      isNamed: true,
      defaultValue: VerticalDirection.down,
    );
    mateUse(
      'textBaseline',
      textBaseline,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.none,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class Row extends Flex
class Row$Mate extends Row with Mate {
  /// Row Row({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Row$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , default:processed=PrefixedIdentifierImpl
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , default:processed=PrefixedIdentifierImpl
    MainAxisSize mainAxisSize = MainAxisSize.max,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , default:processed=PrefixedIdentifierImpl
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , default:processed=PrefixedIdentifierImpl
    VerticalDirection verticalDirection = VerticalDirection.down,

    /// optionalParameters: {TextBaseline? textBaseline} , default:none
    TextBaseline? textBaseline,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateBuilderName = 'Row';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Row$Mate(
          key: p.get('key').build(),
          mainAxisAlignment: p.get('mainAxisAlignment').build(),
          mainAxisSize: p.get('mainAxisSize').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          textBaseline: p.get('textBaseline').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'mainAxisAlignment',
      mainAxisAlignment,
      isNamed: true,
      defaultValue: MainAxisAlignment.start,
    );
    mateUse(
      'mainAxisSize',
      mainAxisSize,
      isNamed: true,
      defaultValue: MainAxisSize.max,
    );
    mateUse(
      'crossAxisAlignment',
      crossAxisAlignment,
      isNamed: true,
      defaultValue: CrossAxisAlignment.center,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'verticalDirection',
      verticalDirection,
      isNamed: true,
      defaultValue: VerticalDirection.down,
    );
    mateUse(
      'textBaseline',
      textBaseline,
      isNamed: true,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class Column extends Flex
class Column$Mate extends Column with Mate {
  /// Column Column({Key? key, MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start, MainAxisSize mainAxisSize = MainAxisSize.max, CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, TextBaseline? textBaseline, List<Widget> children = const <Widget>[]})
  Column$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start} , default:processed=PrefixedIdentifierImpl
    MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,

    /// optionalParameters: {MainAxisSize mainAxisSize = MainAxisSize.max} , default:processed=PrefixedIdentifierImpl
    MainAxisSize mainAxisSize = MainAxisSize.max,

    /// optionalParameters: {CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center} , default:processed=PrefixedIdentifierImpl
    CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , default:processed=PrefixedIdentifierImpl
    VerticalDirection verticalDirection = VerticalDirection.down,

    /// optionalParameters: {TextBaseline? textBaseline} , default:none
    TextBaseline? textBaseline,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          mainAxisAlignment: mainAxisAlignment,
          mainAxisSize: mainAxisSize,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          textBaseline: textBaseline,
          children: children,
        ) {
    mateBuilderName = 'Column';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Column$Mate(
          key: p.get('key').build(),
          mainAxisAlignment: p.get('mainAxisAlignment').build(),
          mainAxisSize: p.get('mainAxisSize').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          textBaseline: p.get('textBaseline').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'mainAxisAlignment',
      mainAxisAlignment,
      isNamed: true,
      defaultValue: MainAxisAlignment.start,
    );
    mateUse(
      'mainAxisSize',
      mainAxisSize,
      isNamed: true,
      defaultValue: MainAxisSize.max,
    );
    mateUse(
      'crossAxisAlignment',
      crossAxisAlignment,
      isNamed: true,
      defaultValue: CrossAxisAlignment.center,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'verticalDirection',
      verticalDirection,
      isNamed: true,
      defaultValue: VerticalDirection.down,
    );
    mateUse(
      'textBaseline',
      textBaseline,
      isNamed: true,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class Flexible extends ParentDataWidget<FlexParentData>
class Flexible$Mate extends Flexible with Mate {
  /// Flexible Flexible({Key? key, int flex = 1, FlexFit fit = FlexFit.loose, required Widget child})
  Flexible$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {int flex = 1} , default:processed=IntegerLiteralImpl
    int flex = 1,

    /// optionalParameters: {FlexFit fit = FlexFit.loose} , default:processed=PrefixedIdentifierImpl
    FlexFit fit = FlexFit.loose,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          fit: fit,
          child: child,
        ) {
    mateBuilderName = 'Flexible';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Flexible$Mate(
          key: p.get('key').build(),
          flex: p.get('flex').build(),
          fit: p.get('fit').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'flex',
      flex,
      isNamed: true,
      defaultValue: 1,
    );
    mateUse(
      'fit',
      fit,
      isNamed: true,
      defaultValue: FlexFit.loose,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Expanded extends Flexible
class Expanded$Mate extends Expanded with Mate {
  /// Expanded Expanded({Key? key, int flex = 1, required Widget child})
  Expanded$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {int flex = 1} , default:processed=IntegerLiteralImpl
    int flex = 1,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          flex: flex,
          child: child,
        ) {
    mateBuilderName = 'Expanded';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Expanded$Mate(
          key: p.get('key').build(),
          flex: p.get('flex').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'flex',
      flex,
      isNamed: true,
      defaultValue: 1,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Wrap extends MultiChildRenderObjectWidget
class Wrap$Mate extends Wrap with Mate {
  /// Wrap Wrap({Key? key, Axis direction = Axis.horizontal, WrapAlignment alignment = WrapAlignment.start, double spacing = 0.0, WrapAlignment runAlignment = WrapAlignment.start, double runSpacing = 0.0, WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start, TextDirection? textDirection, VerticalDirection verticalDirection = VerticalDirection.down, Clip clipBehavior = Clip.none, List<Widget> children = const <Widget>[]})
  Wrap$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Axis direction = Axis.horizontal} , default:processed=PrefixedIdentifierImpl
    Axis direction = Axis.horizontal,

    /// optionalParameters: {WrapAlignment alignment = WrapAlignment.start} , default:processed=PrefixedIdentifierImpl
    WrapAlignment alignment = WrapAlignment.start,

    /// optionalParameters: {double spacing = 0.0} , default:processed=DoubleLiteralImpl
    double spacing = 0.0,

    /// optionalParameters: {WrapAlignment runAlignment = WrapAlignment.start} , default:processed=PrefixedIdentifierImpl
    WrapAlignment runAlignment = WrapAlignment.start,

    /// optionalParameters: {double runSpacing = 0.0} , default:processed=DoubleLiteralImpl
    double runSpacing = 0.0,

    /// optionalParameters: {WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start} , default:processed=PrefixedIdentifierImpl
    WrapCrossAlignment crossAxisAlignment = WrapCrossAlignment.start,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {VerticalDirection verticalDirection = VerticalDirection.down} , default:processed=PrefixedIdentifierImpl
    VerticalDirection verticalDirection = VerticalDirection.down,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.none,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,
  }) : super(
          key: key,
          direction: direction,
          alignment: alignment,
          spacing: spacing,
          runAlignment: runAlignment,
          runSpacing: runSpacing,
          crossAxisAlignment: crossAxisAlignment,
          textDirection: textDirection,
          verticalDirection: verticalDirection,
          clipBehavior: clipBehavior,
          children: children,
        ) {
    mateBuilderName = 'Wrap';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Wrap$Mate(
          key: p.get('key').build(),
          direction: p.get('direction').build(),
          alignment: p.get('alignment').build(),
          spacing: p.get('spacing').build(),
          runAlignment: p.get('runAlignment').build(),
          runSpacing: p.get('runSpacing').build(),
          crossAxisAlignment: p.get('crossAxisAlignment').build(),
          textDirection: p.get('textDirection').build(),
          verticalDirection: p.get('verticalDirection').build(),
          clipBehavior: p.get('clipBehavior').build(),
          children: p.get('children').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'direction',
      direction,
      isNamed: true,
      defaultValue: Axis.horizontal,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: WrapAlignment.start,
    );
    mateUse(
      'spacing',
      spacing,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'runAlignment',
      runAlignment,
      isNamed: true,
      defaultValue: WrapAlignment.start,
    );
    mateUse(
      'runSpacing',
      runSpacing,
      isNamed: true,
      defaultValue: 0.0,
    );
    mateUse(
      'crossAxisAlignment',
      crossAxisAlignment,
      isNamed: true,
      defaultValue: WrapCrossAlignment.start,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'verticalDirection',
      verticalDirection,
      isNamed: true,
      defaultValue: VerticalDirection.down,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.none,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
  }
}

/// class Flow extends MultiChildRenderObjectWidget
class Flow$Mate extends Flow with Mate {
  /// Flow Flow({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required FlowDelegate delegate} , default:none
    required FlowDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.hardEdge,
  }) : super(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateBuilderName = 'Flow';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Flow$Mate(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          children: p.get('children').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'delegate',
      delegate,
      isNamed: true,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.hardEdge,
    );
  }

  /// Flow Flow.unwrapped({Key? key, required FlowDelegate delegate, List<Widget> children = const <Widget>[], Clip clipBehavior = Clip.hardEdge})
  Flow$Mate.unwrapped({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required FlowDelegate delegate} , default:none
    required FlowDelegate delegate,

    /// optionalParameters: {List<Widget> children = const <Widget>[]} , default:unprocessed=ListLiteralImpl
    required List<Widget> children,

    /// optionalParameters: {Clip clipBehavior = Clip.hardEdge} , default:processed=PrefixedIdentifierImpl
    Clip clipBehavior = Clip.hardEdge,
  }) : super.unwrapped(
          key: key,
          delegate: delegate,
          children: children,
          clipBehavior: clipBehavior,
        ) {
    mateBuilderName = 'Flow.unwrapped';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Flow$Mate.unwrapped(
          key: p.get('key').build(),
          delegate: p.get('delegate').build(),
          children: p.get('children').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'delegate',
      delegate,
      isNamed: true,
    );
    mateUseList(
      'children',
      children,
      isNamed: true,
    );
    mateUse(
      'clipBehavior',
      clipBehavior,
      isNamed: true,
      defaultValue: Clip.hardEdge,
    );
  }
}

/// class RichText extends MultiChildRenderObjectWidget
class RichText$Mate extends RichText with Mate {
  /// RichText RichText({Key? key, required InlineSpan text, TextAlign textAlign = TextAlign.start, TextDirection? textDirection, bool softWrap = true, TextOverflow overflow = TextOverflow.clip, double textScaleFactor = 1.0, int? maxLines, Locale? locale, StrutStyle? strutStyle, TextWidthBasis textWidthBasis = TextWidthBasis.parent, TextHeightBehavior? textHeightBehavior, SelectionRegistrar? selectionRegistrar, Color? selectionColor})
  RichText$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required InlineSpan text} , default:none
    required InlineSpan text,

    /// optionalParameters: {TextAlign textAlign = TextAlign.start} , default:processed=PrefixedIdentifierImpl
    TextAlign textAlign = TextAlign.start,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {bool softWrap = true} , default:processed=BooleanLiteralImpl
    bool softWrap = true,

    /// optionalParameters: {TextOverflow overflow = TextOverflow.clip} , default:processed=PrefixedIdentifierImpl
    TextOverflow overflow = TextOverflow.clip,

    /// optionalParameters: {double textScaleFactor = 1.0} , default:processed=DoubleLiteralImpl
    double textScaleFactor = 1.0,

    /// optionalParameters: {int? maxLines} , default:none
    int? maxLines,

    /// optionalParameters: {Locale? locale} , default:none
    Locale? locale,

    /// optionalParameters: {StrutStyle? strutStyle} , default:none
    StrutStyle? strutStyle,

    /// optionalParameters: {TextWidthBasis textWidthBasis = TextWidthBasis.parent} , default:processed=PrefixedIdentifierImpl
    TextWidthBasis textWidthBasis = TextWidthBasis.parent,

    /// optionalParameters: {TextHeightBehavior? textHeightBehavior} , default:none
    TextHeightBehavior? textHeightBehavior,

    /// optionalParameters: {SelectionRegistrar? selectionRegistrar} , default:none
    SelectionRegistrar? selectionRegistrar,

    /// optionalParameters: {Color? selectionColor} , default:none
    Color? selectionColor,
  }) : super(
          key: key,
          text: text,
          textAlign: textAlign,
          textDirection: textDirection,
          softWrap: softWrap,
          overflow: overflow,
          textScaleFactor: textScaleFactor,
          maxLines: maxLines,
          locale: locale,
          strutStyle: strutStyle,
          textWidthBasis: textWidthBasis,
          textHeightBehavior: textHeightBehavior,
          selectionRegistrar: selectionRegistrar,
          selectionColor: selectionColor,
        ) {
    mateBuilderName = 'RichText';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => RichText$Mate(
          key: p.get('key').build(),
          text: p.get('text').build(),
          textAlign: p.get('textAlign').build(),
          textDirection: p.get('textDirection').build(),
          softWrap: p.get('softWrap').build(),
          overflow: p.get('overflow').build(),
          textScaleFactor: p.get('textScaleFactor').build(),
          maxLines: p.get('maxLines').build(),
          locale: p.get('locale').build(),
          strutStyle: p.get('strutStyle').build(),
          textWidthBasis: p.get('textWidthBasis').build(),
          textHeightBehavior: p.get('textHeightBehavior').build(),
          selectionRegistrar: p.get('selectionRegistrar').build(),
          selectionColor: p.get('selectionColor').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'text',
      text,
      isNamed: true,
    );
    mateUse(
      'textAlign',
      textAlign,
      isNamed: true,
      defaultValue: TextAlign.start,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'softWrap',
      softWrap,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'overflow',
      overflow,
      isNamed: true,
      defaultValue: TextOverflow.clip,
    );
    mateUse(
      'textScaleFactor',
      textScaleFactor,
      isNamed: true,
      defaultValue: 1.0,
    );
    mateUse(
      'maxLines',
      maxLines,
      isNamed: true,
    );
    mateUse(
      'locale',
      locale,
      isNamed: true,
    );
    mateUse(
      'strutStyle',
      strutStyle,
      isNamed: true,
    );
    mateUse(
      'textWidthBasis',
      textWidthBasis,
      isNamed: true,
      defaultValue: TextWidthBasis.parent,
    );
    mateUse(
      'textHeightBehavior',
      textHeightBehavior,
      isNamed: true,
    );
    mateUse(
      'selectionRegistrar',
      selectionRegistrar,
      isNamed: true,
    );
    mateUse(
      'selectionColor',
      selectionColor,
      isNamed: true,
    );
  }
}

/// class RawImage extends LeafRenderObjectWidget
class RawImage$Mate extends RawImage with Mate {
  /// RawImage RawImage({Key? key, Image? image, String? debugImageLabel, double? width, double? height, double scale = 1.0, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool invertColors = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false})
  RawImage$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Image? image} , default:none
    Image? image,

    /// optionalParameters: {String? debugImageLabel} , default:none
    String? debugImageLabel,

    /// optionalParameters: {double? width} , default:none
    double? width,

    /// optionalParameters: {double? height} , default:none
    double? height,

    /// optionalParameters: {double scale = 1.0} , default:processed=DoubleLiteralImpl
    double scale = 1.0,

    /// optionalParameters: {Color? color} , default:none
    Color? color,

    /// optionalParameters: {Animation<double>? opacity} , default:none
    Animation<double>? opacity,

    /// optionalParameters: {BlendMode? colorBlendMode} , default:none
    BlendMode? colorBlendMode,

    /// optionalParameters: {BoxFit? fit} , default:none
    BoxFit? fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , default:processed=PrefixedIdentifierImpl
    AlignmentGeometry alignment = Alignment.center,

    /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , default:processed=PrefixedIdentifierImpl
    ImageRepeat repeat = ImageRepeat.noRepeat,

    /// optionalParameters: {Rect? centerSlice} , default:none
    Rect? centerSlice,

    /// optionalParameters: {bool matchTextDirection = false} , default:processed=BooleanLiteralImpl
    bool matchTextDirection = false,

    /// optionalParameters: {bool invertColors = false} , default:processed=BooleanLiteralImpl
    bool invertColors = false,

    /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , default:processed=PrefixedIdentifierImpl
    FilterQuality filterQuality = FilterQuality.low,

    /// optionalParameters: {bool isAntiAlias = false} , default:processed=BooleanLiteralImpl
    bool isAntiAlias = false,
  }) : super(
          key: key,
          image: image,
          debugImageLabel: debugImageLabel,
          width: width,
          height: height,
          scale: scale,
          color: color,
          opacity: opacity,
          colorBlendMode: colorBlendMode,
          fit: fit,
          alignment: alignment,
          repeat: repeat,
          centerSlice: centerSlice,
          matchTextDirection: matchTextDirection,
          invertColors: invertColors,
          filterQuality: filterQuality,
          isAntiAlias: isAntiAlias,
        ) {
    mateBuilderName = 'RawImage';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => RawImage$Mate(
          key: p.get('key').build(),
          image: p.get('image').build(),
          debugImageLabel: p.get('debugImageLabel').build(),
          width: p.get('width').build(),
          height: p.get('height').build(),
          scale: p.get('scale').build(),
          color: p.get('color').build(),
          opacity: p.get('opacity').build(),
          colorBlendMode: p.get('colorBlendMode').build(),
          fit: p.get('fit').build(),
          alignment: p.get('alignment').build(),
          repeat: p.get('repeat').build(),
          centerSlice: p.get('centerSlice').build(),
          matchTextDirection: p.get('matchTextDirection').build(),
          invertColors: p.get('invertColors').build(),
          filterQuality: p.get('filterQuality').build(),
          isAntiAlias: p.get('isAntiAlias').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'image',
      image,
      isNamed: true,
    );
    mateUse(
      'debugImageLabel',
      debugImageLabel,
      isNamed: true,
    );
    mateUse(
      'width',
      width,
      isNamed: true,
    );
    mateUse(
      'height',
      height,
      isNamed: true,
    );
    mateUse(
      'scale',
      scale,
      isNamed: true,
      defaultValue: 1.0,
    );
    mateUse(
      'color',
      color,
      isNamed: true,
    );
    mateUse(
      'opacity',
      opacity,
      isNamed: true,
    );
    mateUse(
      'colorBlendMode',
      colorBlendMode,
      isNamed: true,
    );
    mateUse(
      'fit',
      fit,
      isNamed: true,
    );
    mateUse(
      'alignment',
      alignment,
      isNamed: true,
      defaultValue: Alignment.center,
    );
    mateUse(
      'repeat',
      repeat,
      isNamed: true,
      defaultValue: ImageRepeat.noRepeat,
    );
    mateUse(
      'centerSlice',
      centerSlice,
      isNamed: true,
    );
    mateUse(
      'matchTextDirection',
      matchTextDirection,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'invertColors',
      invertColors,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'filterQuality',
      filterQuality,
      isNamed: true,
      defaultValue: FilterQuality.low,
    );
    mateUse(
      'isAntiAlias',
      isAntiAlias,
      isNamed: true,
      defaultValue: false,
    );
  }
}

/// class DefaultAssetBundle extends InheritedWidget
class DefaultAssetBundle$Mate extends DefaultAssetBundle with Mate {
  /// DefaultAssetBundle DefaultAssetBundle({Key? key, required AssetBundle bundle, required Widget child})
  DefaultAssetBundle$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required AssetBundle bundle} , default:none
    required AssetBundle bundle,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          bundle: bundle,
          child: child,
        ) {
    mateBuilderName = 'DefaultAssetBundle';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => DefaultAssetBundle$Mate(
          key: p.get('key').build(),
          bundle: p.get('bundle').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'bundle',
      bundle,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class WidgetToRenderBoxAdapter extends LeafRenderObjectWidget
class WidgetToRenderBoxAdapter$Mate extends WidgetToRenderBoxAdapter with Mate {
  /// WidgetToRenderBoxAdapter WidgetToRenderBoxAdapter({required RenderBox renderBox, void Function()? onBuild, void Function()? onUnmount})
  WidgetToRenderBoxAdapter$Mate({
    /// optionalParameters: {required RenderBox renderBox} , default:none
    required RenderBox renderBox,

    /// optionalParameters: {void Function()? onBuild} , default:none
    VoidCallback? onBuild,

    /// optionalParameters: {void Function()? onUnmount} , default:none
    VoidCallback? onUnmount,
  }) : super(
          renderBox: renderBox,
          onBuild: onBuild,
          onUnmount: onUnmount,
        ) {
    mateBuilderName = 'WidgetToRenderBoxAdapter';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => WidgetToRenderBoxAdapter$Mate(
          renderBox: p.get('renderBox').build(),
          onBuild: p.get('onBuild').build(),
          onUnmount: p.get('onUnmount').build(),
        );
    mateUse(
      'renderBox',
      renderBox,
      isNamed: true,
    );
    mateUse(
      'onBuild',
      onBuild,
      isNamed: true,
    );
    mateUse(
      'onUnmount',
      onUnmount,
      isNamed: true,
    );
  }
}

/// class Listener extends SingleChildRenderObjectWidget
class Listener$Mate extends Listener with Mate {
  /// Listener Listener({Key? key, void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  Listener$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {void Function(PointerDownEvent)? onPointerDown} , default:none
    PointerDownEventListener? onPointerDown,

    /// optionalParameters: {void Function(PointerMoveEvent)? onPointerMove} , default:none
    PointerMoveEventListener? onPointerMove,

    /// optionalParameters: {void Function(PointerUpEvent)? onPointerUp} , default:none
    PointerUpEventListener? onPointerUp,

    /// optionalParameters: {void Function(PointerHoverEvent)? onPointerHover} , default:none
    PointerHoverEventListener? onPointerHover,

    /// optionalParameters: {void Function(PointerCancelEvent)? onPointerCancel} , default:none
    PointerCancelEventListener? onPointerCancel,

    /// optionalParameters: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart} , default:none
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// optionalParameters: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate} , default:none
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// optionalParameters: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd} , default:none
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// optionalParameters: {void Function(PointerSignalEvent)? onPointerSignal} , default:none
    PointerSignalEventListener? onPointerSignal,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , default:processed=PrefixedIdentifierImpl
    HitTestBehavior behavior = HitTestBehavior.deferToChild,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {
    mateBuilderName = 'Listener';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Listener$Mate(
          key: p.get('key').build(),
          onPointerDown: p.get('onPointerDown').build(),
          onPointerMove: p.get('onPointerMove').build(),
          onPointerUp: p.get('onPointerUp').build(),
          onPointerHover: p.get('onPointerHover').build(),
          onPointerCancel: p.get('onPointerCancel').build(),
          onPointerPanZoomStart: p.get('onPointerPanZoomStart').build(),
          onPointerPanZoomUpdate: p.get('onPointerPanZoomUpdate').build(),
          onPointerPanZoomEnd: p.get('onPointerPanZoomEnd').build(),
          onPointerSignal: p.get('onPointerSignal').build(),
          behavior: p.get('behavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'onPointerDown',
      onPointerDown,
      isNamed: true,
    );
    mateUse(
      'onPointerMove',
      onPointerMove,
      isNamed: true,
    );
    mateUse(
      'onPointerUp',
      onPointerUp,
      isNamed: true,
    );
    mateUse(
      'onPointerHover',
      onPointerHover,
      isNamed: true,
    );
    mateUse(
      'onPointerCancel',
      onPointerCancel,
      isNamed: true,
    );
    mateUse(
      'onPointerPanZoomStart',
      onPointerPanZoomStart,
      isNamed: true,
    );
    mateUse(
      'onPointerPanZoomUpdate',
      onPointerPanZoomUpdate,
      isNamed: true,
    );
    mateUse(
      'onPointerPanZoomEnd',
      onPointerPanZoomEnd,
      isNamed: true,
    );
    mateUse(
      'onPointerSignal',
      onPointerSignal,
      isNamed: true,
    );
    mateUse(
      'behavior',
      behavior,
      isNamed: true,
      defaultValue: HitTestBehavior.deferToChild,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class MouseRegion extends SingleChildRenderObjectWidget
class MouseRegion$Mate extends MouseRegion with Mate {
  /// MouseRegion MouseRegion({Key? key, void Function(PointerEnterEvent)? onEnter, void Function(PointerExitEvent)? onExit, void Function(PointerHoverEvent)? onHover, MouseCursor cursor = MouseCursor.defer, bool opaque = true, HitTestBehavior? hitTestBehavior, Widget? child})
  MouseRegion$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {void Function(PointerEnterEvent)? onEnter} , default:none
    PointerEnterEventListener? onEnter,

    /// optionalParameters: {void Function(PointerExitEvent)? onExit} , default:none
    PointerExitEventListener? onExit,

    /// optionalParameters: {void Function(PointerHoverEvent)? onHover} , default:none
    PointerHoverEventListener? onHover,

    /// optionalParameters: {MouseCursor cursor = MouseCursor.defer} , default:processed=PrefixedIdentifierImpl
    MouseCursor cursor = MouseCursor.defer,

    /// optionalParameters: {bool opaque = true} , default:processed=BooleanLiteralImpl
    bool opaque = true,

    /// optionalParameters: {HitTestBehavior? hitTestBehavior} , default:none
    HitTestBehavior? hitTestBehavior,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          onEnter: onEnter,
          onExit: onExit,
          onHover: onHover,
          cursor: cursor,
          opaque: opaque,
          hitTestBehavior: hitTestBehavior,
          child: child,
        ) {
    mateBuilderName = 'MouseRegion';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => MouseRegion$Mate(
          key: p.get('key').build(),
          onEnter: p.get('onEnter').build(),
          onExit: p.get('onExit').build(),
          onHover: p.get('onHover').build(),
          cursor: p.get('cursor').build(),
          opaque: p.get('opaque').build(),
          hitTestBehavior: p.get('hitTestBehavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'onEnter',
      onEnter,
      isNamed: true,
    );
    mateUse(
      'onExit',
      onExit,
      isNamed: true,
    );
    mateUse(
      'onHover',
      onHover,
      isNamed: true,
    );
    mateUse(
      'cursor',
      cursor,
      isNamed: true,
      defaultValue: MouseCursor.defer,
    );
    mateUse(
      'opaque',
      opaque,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'hitTestBehavior',
      hitTestBehavior,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class RepaintBoundary extends SingleChildRenderObjectWidget
class RepaintBoundary$Mate extends RepaintBoundary with Mate {
  /// RepaintBoundary RepaintBoundary({Key? key, Widget? child})
  RepaintBoundary$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilderName = 'RepaintBoundary';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => RepaintBoundary$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class IgnorePointer extends SingleChildRenderObjectWidget
class IgnorePointer$Mate extends IgnorePointer with Mate {
  /// IgnorePointer IgnorePointer({Key? key, bool ignoring = true, bool? ignoringSemantics, Widget? child})
  IgnorePointer$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {bool ignoring = true} , default:processed=BooleanLiteralImpl
    bool ignoring = true,

    /// optionalParameters: {bool? ignoringSemantics} , default:none
    bool? ignoringSemantics,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
          child: child,
        ) {
    mateBuilderName = 'IgnorePointer';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => IgnorePointer$Mate(
          key: p.get('key').build(),
          ignoring: p.get('ignoring').build(),
          ignoringSemantics: p.get('ignoringSemantics').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'ignoring',
      ignoring,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'ignoringSemantics',
      ignoringSemantics,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class AbsorbPointer extends SingleChildRenderObjectWidget
class AbsorbPointer$Mate extends AbsorbPointer with Mate {
  /// AbsorbPointer AbsorbPointer({Key? key, bool absorbing = true, Widget? child, bool? ignoringSemantics})
  AbsorbPointer$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {bool absorbing = true} , default:processed=BooleanLiteralImpl
    bool absorbing = true,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {bool? ignoringSemantics} , default:none
    bool? ignoringSemantics,
  }) : super(
          key: key,
          absorbing: absorbing,
          child: child,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateBuilderName = 'AbsorbPointer';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => AbsorbPointer$Mate(
          key: p.get('key').build(),
          absorbing: p.get('absorbing').build(),
          child: p.get('child').build(),
          ignoringSemantics: p.get('ignoringSemantics').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'absorbing',
      absorbing,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'ignoringSemantics',
      ignoringSemantics,
      isNamed: true,
    );
  }
}

/// class MetaData extends SingleChildRenderObjectWidget
class MetaData$Mate extends MetaData with Mate {
  /// MetaData MetaData({Key? key, dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, Widget? child})
  MetaData$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {dynamic metaData} , default:none
    dynamic metaData,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , default:processed=PrefixedIdentifierImpl
    HitTestBehavior behavior = HitTestBehavior.deferToChild,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {
    mateBuilderName = 'MetaData';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => MetaData$Mate(
          key: p.get('key').build(),
          metaData: p.get('metaData').build(),
          behavior: p.get('behavior').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'metaData',
      metaData,
      isNamed: true,
    );
    mateUse(
      'behavior',
      behavior,
      isNamed: true,
      defaultValue: HitTestBehavior.deferToChild,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Semantics extends SingleChildRenderObjectWidget
class Semantics$Mate extends Semantics with Mate {
  /// Semantics Semantics({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, bool? enabled, bool? checked, bool? mixed, bool? selected, bool? toggled, bool? button, bool? slider, bool? keyboardKey, bool? link, bool? header, bool? textField, bool? readOnly, bool? focusable, bool? focused, bool? inMutuallyExclusiveGroup, bool? obscured, bool? multiline, bool? scopesRoute, bool? namesRoute, bool? hidden, bool? image, bool? liveRegion, int? maxValueLength, int? currentValueLength, String? label, AttributedString? attributedLabel, String? value, AttributedString? attributedValue, String? increasedValue, AttributedString? attributedIncreasedValue, String? decreasedValue, AttributedString? attributedDecreasedValue, String? hint, AttributedString? attributedHint, String? tooltip, String? onTapHint, String? onLongPressHint, TextDirection? textDirection, SemanticsSortKey? sortKey, SemanticsTag? tagForChildren, void Function()? onTap, void Function()? onLongPress, void Function()? onScrollLeft, void Function()? onScrollRight, void Function()? onScrollUp, void Function()? onScrollDown, void Function()? onIncrease, void Function()? onDecrease, void Function()? onCopy, void Function()? onCut, void Function()? onPaste, void Function()? onDismiss, void Function(bool)? onMoveCursorForwardByCharacter, void Function(bool)? onMoveCursorBackwardByCharacter, void Function(TextSelection)? onSetSelection, void Function(String)? onSetText, void Function()? onDidGainAccessibilityFocus, void Function()? onDidLoseAccessibilityFocus, Map<CustomSemanticsAction, void Function()>? customSemanticsActions})
  Semantics$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {bool container = false} , default:processed=BooleanLiteralImpl
    bool container = false,

    /// optionalParameters: {bool explicitChildNodes = false} , default:processed=BooleanLiteralImpl
    bool explicitChildNodes = false,

    /// optionalParameters: {bool excludeSemantics = false} , default:processed=BooleanLiteralImpl
    bool excludeSemantics = false,

    /// optionalParameters: {bool? enabled} , default:none
    bool? enabled,

    /// optionalParameters: {bool? checked} , default:none
    bool? checked,

    /// optionalParameters: {bool? mixed} , default:none
    bool? mixed,

    /// optionalParameters: {bool? selected} , default:none
    bool? selected,

    /// optionalParameters: {bool? toggled} , default:none
    bool? toggled,

    /// optionalParameters: {bool? button} , default:none
    bool? button,

    /// optionalParameters: {bool? slider} , default:none
    bool? slider,

    /// optionalParameters: {bool? keyboardKey} , default:none
    bool? keyboardKey,

    /// optionalParameters: {bool? link} , default:none
    bool? link,

    /// optionalParameters: {bool? header} , default:none
    bool? header,

    /// optionalParameters: {bool? textField} , default:none
    bool? textField,

    /// optionalParameters: {bool? readOnly} , default:none
    bool? readOnly,

    /// optionalParameters: {bool? focusable} , default:none
    bool? focusable,

    /// optionalParameters: {bool? focused} , default:none
    bool? focused,

    /// optionalParameters: {bool? inMutuallyExclusiveGroup} , default:none
    bool? inMutuallyExclusiveGroup,

    /// optionalParameters: {bool? obscured} , default:none
    bool? obscured,

    /// optionalParameters: {bool? multiline} , default:none
    bool? multiline,

    /// optionalParameters: {bool? scopesRoute} , default:none
    bool? scopesRoute,

    /// optionalParameters: {bool? namesRoute} , default:none
    bool? namesRoute,

    /// optionalParameters: {bool? hidden} , default:none
    bool? hidden,

    /// optionalParameters: {bool? image} , default:none
    bool? image,

    /// optionalParameters: {bool? liveRegion} , default:none
    bool? liveRegion,

    /// optionalParameters: {int? maxValueLength} , default:none
    int? maxValueLength,

    /// optionalParameters: {int? currentValueLength} , default:none
    int? currentValueLength,

    /// optionalParameters: {String? label} , default:none
    String? label,

    /// optionalParameters: {AttributedString? attributedLabel} , default:none
    AttributedString? attributedLabel,

    /// optionalParameters: {String? value} , default:none
    String? value,

    /// optionalParameters: {AttributedString? attributedValue} , default:none
    AttributedString? attributedValue,

    /// optionalParameters: {String? increasedValue} , default:none
    String? increasedValue,

    /// optionalParameters: {AttributedString? attributedIncreasedValue} , default:none
    AttributedString? attributedIncreasedValue,

    /// optionalParameters: {String? decreasedValue} , default:none
    String? decreasedValue,

    /// optionalParameters: {AttributedString? attributedDecreasedValue} , default:none
    AttributedString? attributedDecreasedValue,

    /// optionalParameters: {String? hint} , default:none
    String? hint,

    /// optionalParameters: {AttributedString? attributedHint} , default:none
    AttributedString? attributedHint,

    /// optionalParameters: {String? tooltip} , default:none
    String? tooltip,

    /// optionalParameters: {String? onTapHint} , default:none
    String? onTapHint,

    /// optionalParameters: {String? onLongPressHint} , default:none
    String? onLongPressHint,

    /// optionalParameters: {TextDirection? textDirection} , default:none
    TextDirection? textDirection,

    /// optionalParameters: {SemanticsSortKey? sortKey} , default:none
    SemanticsSortKey? sortKey,

    /// optionalParameters: {SemanticsTag? tagForChildren} , default:none
    SemanticsTag? tagForChildren,

    /// optionalParameters: {void Function()? onTap} , default:none
    VoidCallback? onTap,

    /// optionalParameters: {void Function()? onLongPress} , default:none
    VoidCallback? onLongPress,

    /// optionalParameters: {void Function()? onScrollLeft} , default:none
    VoidCallback? onScrollLeft,

    /// optionalParameters: {void Function()? onScrollRight} , default:none
    VoidCallback? onScrollRight,

    /// optionalParameters: {void Function()? onScrollUp} , default:none
    VoidCallback? onScrollUp,

    /// optionalParameters: {void Function()? onScrollDown} , default:none
    VoidCallback? onScrollDown,

    /// optionalParameters: {void Function()? onIncrease} , default:none
    VoidCallback? onIncrease,

    /// optionalParameters: {void Function()? onDecrease} , default:none
    VoidCallback? onDecrease,

    /// optionalParameters: {void Function()? onCopy} , default:none
    VoidCallback? onCopy,

    /// optionalParameters: {void Function()? onCut} , default:none
    VoidCallback? onCut,

    /// optionalParameters: {void Function()? onPaste} , default:none
    VoidCallback? onPaste,

    /// optionalParameters: {void Function()? onDismiss} , default:none
    VoidCallback? onDismiss,

    /// optionalParameters: {void Function(bool)? onMoveCursorForwardByCharacter} , default:none
    MoveCursorHandler? onMoveCursorForwardByCharacter,

    /// optionalParameters: {void Function(bool)? onMoveCursorBackwardByCharacter} , default:none
    MoveCursorHandler? onMoveCursorBackwardByCharacter,

    /// optionalParameters: {void Function(TextSelection)? onSetSelection} , default:none
    SetSelectionHandler? onSetSelection,

    /// optionalParameters: {void Function(String)? onSetText} , default:none
    SetTextHandler? onSetText,

    /// optionalParameters: {void Function()? onDidGainAccessibilityFocus} , default:none
    VoidCallback? onDidGainAccessibilityFocus,

    /// optionalParameters: {void Function()? onDidLoseAccessibilityFocus} , default:none
    VoidCallback? onDidLoseAccessibilityFocus,

    /// optionalParameters: {Map<CustomSemanticsAction, void Function()>? customSemanticsActions} , default:none
    Map<CustomSemanticsAction, VoidCallback>? customSemanticsActions,
  }) : super(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          enabled: enabled,
          checked: checked,
          mixed: mixed,
          selected: selected,
          toggled: toggled,
          button: button,
          slider: slider,
          keyboardKey: keyboardKey,
          link: link,
          header: header,
          textField: textField,
          readOnly: readOnly,
          focusable: focusable,
          focused: focused,
          inMutuallyExclusiveGroup: inMutuallyExclusiveGroup,
          obscured: obscured,
          multiline: multiline,
          scopesRoute: scopesRoute,
          namesRoute: namesRoute,
          hidden: hidden,
          image: image,
          liveRegion: liveRegion,
          maxValueLength: maxValueLength,
          currentValueLength: currentValueLength,
          label: label,
          attributedLabel: attributedLabel,
          value: value,
          attributedValue: attributedValue,
          increasedValue: increasedValue,
          attributedIncreasedValue: attributedIncreasedValue,
          decreasedValue: decreasedValue,
          attributedDecreasedValue: attributedDecreasedValue,
          hint: hint,
          attributedHint: attributedHint,
          tooltip: tooltip,
          onTapHint: onTapHint,
          onLongPressHint: onLongPressHint,
          textDirection: textDirection,
          sortKey: sortKey,
          tagForChildren: tagForChildren,
          onTap: onTap,
          onLongPress: onLongPress,
          onScrollLeft: onScrollLeft,
          onScrollRight: onScrollRight,
          onScrollUp: onScrollUp,
          onScrollDown: onScrollDown,
          onIncrease: onIncrease,
          onDecrease: onDecrease,
          onCopy: onCopy,
          onCut: onCut,
          onPaste: onPaste,
          onDismiss: onDismiss,
          onMoveCursorForwardByCharacter: onMoveCursorForwardByCharacter,
          onMoveCursorBackwardByCharacter: onMoveCursorBackwardByCharacter,
          onSetSelection: onSetSelection,
          onSetText: onSetText,
          onDidGainAccessibilityFocus: onDidGainAccessibilityFocus,
          onDidLoseAccessibilityFocus: onDidLoseAccessibilityFocus,
          customSemanticsActions: customSemanticsActions,
        ) {
    mateBuilderName = 'Semantics';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Semantics$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
          container: p.get('container').build(),
          explicitChildNodes: p.get('explicitChildNodes').build(),
          excludeSemantics: p.get('excludeSemantics').build(),
          enabled: p.get('enabled').build(),
          checked: p.get('checked').build(),
          mixed: p.get('mixed').build(),
          selected: p.get('selected').build(),
          toggled: p.get('toggled').build(),
          button: p.get('button').build(),
          slider: p.get('slider').build(),
          keyboardKey: p.get('keyboardKey').build(),
          link: p.get('link').build(),
          header: p.get('header').build(),
          textField: p.get('textField').build(),
          readOnly: p.get('readOnly').build(),
          focusable: p.get('focusable').build(),
          focused: p.get('focused').build(),
          inMutuallyExclusiveGroup: p.get('inMutuallyExclusiveGroup').build(),
          obscured: p.get('obscured').build(),
          multiline: p.get('multiline').build(),
          scopesRoute: p.get('scopesRoute').build(),
          namesRoute: p.get('namesRoute').build(),
          hidden: p.get('hidden').build(),
          image: p.get('image').build(),
          liveRegion: p.get('liveRegion').build(),
          maxValueLength: p.get('maxValueLength').build(),
          currentValueLength: p.get('currentValueLength').build(),
          label: p.get('label').build(),
          attributedLabel: p.get('attributedLabel').build(),
          value: p.get('value').build(),
          attributedValue: p.get('attributedValue').build(),
          increasedValue: p.get('increasedValue').build(),
          attributedIncreasedValue: p.get('attributedIncreasedValue').build(),
          decreasedValue: p.get('decreasedValue').build(),
          attributedDecreasedValue: p.get('attributedDecreasedValue').build(),
          hint: p.get('hint').build(),
          attributedHint: p.get('attributedHint').build(),
          tooltip: p.get('tooltip').build(),
          onTapHint: p.get('onTapHint').build(),
          onLongPressHint: p.get('onLongPressHint').build(),
          textDirection: p.get('textDirection').build(),
          sortKey: p.get('sortKey').build(),
          tagForChildren: p.get('tagForChildren').build(),
          onTap: p.get('onTap').build(),
          onLongPress: p.get('onLongPress').build(),
          onScrollLeft: p.get('onScrollLeft').build(),
          onScrollRight: p.get('onScrollRight').build(),
          onScrollUp: p.get('onScrollUp').build(),
          onScrollDown: p.get('onScrollDown').build(),
          onIncrease: p.get('onIncrease').build(),
          onDecrease: p.get('onDecrease').build(),
          onCopy: p.get('onCopy').build(),
          onCut: p.get('onCut').build(),
          onPaste: p.get('onPaste').build(),
          onDismiss: p.get('onDismiss').build(),
          onMoveCursorForwardByCharacter:
              p.get('onMoveCursorForwardByCharacter').build(),
          onMoveCursorBackwardByCharacter:
              p.get('onMoveCursorBackwardByCharacter').build(),
          onSetSelection: p.get('onSetSelection').build(),
          onSetText: p.get('onSetText').build(),
          onDidGainAccessibilityFocus:
              p.get('onDidGainAccessibilityFocus').build(),
          onDidLoseAccessibilityFocus:
              p.get('onDidLoseAccessibilityFocus').build(),
          customSemanticsActions: p.get('customSemanticsActions').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'container',
      container,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'explicitChildNodes',
      explicitChildNodes,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'excludeSemantics',
      excludeSemantics,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'enabled',
      enabled,
      isNamed: true,
    );
    mateUse(
      'checked',
      checked,
      isNamed: true,
    );
    mateUse(
      'mixed',
      mixed,
      isNamed: true,
    );
    mateUse(
      'selected',
      selected,
      isNamed: true,
    );
    mateUse(
      'toggled',
      toggled,
      isNamed: true,
    );
    mateUse(
      'button',
      button,
      isNamed: true,
    );
    mateUse(
      'slider',
      slider,
      isNamed: true,
    );
    mateUse(
      'keyboardKey',
      keyboardKey,
      isNamed: true,
    );
    mateUse(
      'link',
      link,
      isNamed: true,
    );
    mateUse(
      'header',
      header,
      isNamed: true,
    );
    mateUse(
      'textField',
      textField,
      isNamed: true,
    );
    mateUse(
      'readOnly',
      readOnly,
      isNamed: true,
    );
    mateUse(
      'focusable',
      focusable,
      isNamed: true,
    );
    mateUse(
      'focused',
      focused,
      isNamed: true,
    );
    mateUse(
      'inMutuallyExclusiveGroup',
      inMutuallyExclusiveGroup,
      isNamed: true,
    );
    mateUse(
      'obscured',
      obscured,
      isNamed: true,
    );
    mateUse(
      'multiline',
      multiline,
      isNamed: true,
    );
    mateUse(
      'scopesRoute',
      scopesRoute,
      isNamed: true,
    );
    mateUse(
      'namesRoute',
      namesRoute,
      isNamed: true,
    );
    mateUse(
      'hidden',
      hidden,
      isNamed: true,
    );
    mateUse(
      'image',
      image,
      isNamed: true,
    );
    mateUse(
      'liveRegion',
      liveRegion,
      isNamed: true,
    );
    mateUse(
      'maxValueLength',
      maxValueLength,
      isNamed: true,
    );
    mateUse(
      'currentValueLength',
      currentValueLength,
      isNamed: true,
    );
    mateUse(
      'label',
      label,
      isNamed: true,
    );
    mateUse(
      'attributedLabel',
      attributedLabel,
      isNamed: true,
    );
    mateUse(
      'value',
      value,
      isNamed: true,
    );
    mateUse(
      'attributedValue',
      attributedValue,
      isNamed: true,
    );
    mateUse(
      'increasedValue',
      increasedValue,
      isNamed: true,
    );
    mateUse(
      'attributedIncreasedValue',
      attributedIncreasedValue,
      isNamed: true,
    );
    mateUse(
      'decreasedValue',
      decreasedValue,
      isNamed: true,
    );
    mateUse(
      'attributedDecreasedValue',
      attributedDecreasedValue,
      isNamed: true,
    );
    mateUse(
      'hint',
      hint,
      isNamed: true,
    );
    mateUse(
      'attributedHint',
      attributedHint,
      isNamed: true,
    );
    mateUse(
      'tooltip',
      tooltip,
      isNamed: true,
    );
    mateUse(
      'onTapHint',
      onTapHint,
      isNamed: true,
    );
    mateUse(
      'onLongPressHint',
      onLongPressHint,
      isNamed: true,
    );
    mateUse(
      'textDirection',
      textDirection,
      isNamed: true,
    );
    mateUse(
      'sortKey',
      sortKey,
      isNamed: true,
    );
    mateUse(
      'tagForChildren',
      tagForChildren,
      isNamed: true,
    );
    mateUse(
      'onTap',
      onTap,
      isNamed: true,
    );
    mateUse(
      'onLongPress',
      onLongPress,
      isNamed: true,
    );
    mateUse(
      'onScrollLeft',
      onScrollLeft,
      isNamed: true,
    );
    mateUse(
      'onScrollRight',
      onScrollRight,
      isNamed: true,
    );
    mateUse(
      'onScrollUp',
      onScrollUp,
      isNamed: true,
    );
    mateUse(
      'onScrollDown',
      onScrollDown,
      isNamed: true,
    );
    mateUse(
      'onIncrease',
      onIncrease,
      isNamed: true,
    );
    mateUse(
      'onDecrease',
      onDecrease,
      isNamed: true,
    );
    mateUse(
      'onCopy',
      onCopy,
      isNamed: true,
    );
    mateUse(
      'onCut',
      onCut,
      isNamed: true,
    );
    mateUse(
      'onPaste',
      onPaste,
      isNamed: true,
    );
    mateUse(
      'onDismiss',
      onDismiss,
      isNamed: true,
    );
    mateUse(
      'onMoveCursorForwardByCharacter',
      onMoveCursorForwardByCharacter,
      isNamed: true,
    );
    mateUse(
      'onMoveCursorBackwardByCharacter',
      onMoveCursorBackwardByCharacter,
      isNamed: true,
    );
    mateUse(
      'onSetSelection',
      onSetSelection,
      isNamed: true,
    );
    mateUse(
      'onSetText',
      onSetText,
      isNamed: true,
    );
    mateUse(
      'onDidGainAccessibilityFocus',
      onDidGainAccessibilityFocus,
      isNamed: true,
    );
    mateUse(
      'onDidLoseAccessibilityFocus',
      onDidLoseAccessibilityFocus,
      isNamed: true,
    );
    mateUse(
      'customSemanticsActions',
      customSemanticsActions,
      isNamed: true,
    );
  }

  /// Semantics Semantics.fromProperties({Key? key, Widget? child, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, required SemanticsProperties properties})
  Semantics$Mate.fromProperties({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {bool container = false} , default:processed=BooleanLiteralImpl
    bool container = false,

    /// optionalParameters: {bool explicitChildNodes = false} , default:processed=BooleanLiteralImpl
    bool explicitChildNodes = false,

    /// optionalParameters: {bool excludeSemantics = false} , default:processed=BooleanLiteralImpl
    bool excludeSemantics = false,

    /// optionalParameters: {required SemanticsProperties properties} , default:none
    required SemanticsProperties properties,
  }) : super.fromProperties(
          key: key,
          child: child,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          properties: properties,
        ) {
    mateBuilderName = 'Semantics.fromProperties';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Semantics$Mate.fromProperties(
          key: p.get('key').build(),
          child: p.get('child').build(),
          container: p.get('container').build(),
          explicitChildNodes: p.get('explicitChildNodes').build(),
          excludeSemantics: p.get('excludeSemantics').build(),
          properties: p.get('properties').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'container',
      container,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'explicitChildNodes',
      explicitChildNodes,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'excludeSemantics',
      excludeSemantics,
      isNamed: true,
      defaultValue: false,
    );
    mateUse(
      'properties',
      properties,
      isNamed: true,
    );
  }
}

/// class MergeSemantics extends SingleChildRenderObjectWidget
class MergeSemantics$Mate extends MergeSemantics with Mate {
  /// MergeSemantics MergeSemantics({Key? key, Widget? child})
  MergeSemantics$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilderName = 'MergeSemantics';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => MergeSemantics$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class BlockSemantics extends SingleChildRenderObjectWidget
class BlockSemantics$Mate extends BlockSemantics with Mate {
  /// BlockSemantics BlockSemantics({Key? key, bool blocking = true, Widget? child})
  BlockSemantics$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {bool blocking = true} , default:processed=BooleanLiteralImpl
    bool blocking = true,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          blocking: blocking,
          child: child,
        ) {
    mateBuilderName = 'BlockSemantics';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => BlockSemantics$Mate(
          key: p.get('key').build(),
          blocking: p.get('blocking').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'blocking',
      blocking,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class ExcludeSemantics extends SingleChildRenderObjectWidget
class ExcludeSemantics$Mate extends ExcludeSemantics with Mate {
  /// ExcludeSemantics ExcludeSemantics({Key? key, bool excluding = true, Widget? child})
  ExcludeSemantics$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {bool excluding = true} , default:processed=BooleanLiteralImpl
    bool excluding = true,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          excluding: excluding,
          child: child,
        ) {
    mateBuilderName = 'ExcludeSemantics';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ExcludeSemantics$Mate(
          key: p.get('key').build(),
          excluding: p.get('excluding').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'excluding',
      excluding,
      isNamed: true,
      defaultValue: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class IndexedSemantics extends SingleChildRenderObjectWidget
class IndexedSemantics$Mate extends IndexedSemantics with Mate {
  /// IndexedSemantics IndexedSemantics({Key? key, required int index, Widget? child})
  IndexedSemantics$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required int index} , default:none
    required int index,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,
  }) : super(
          key: key,
          index: index,
          child: child,
        ) {
    mateBuilderName = 'IndexedSemantics';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => IndexedSemantics$Mate(
          key: p.get('key').build(),
          index: p.get('index').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'index',
      index,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class KeyedSubtree extends StatelessWidget
class KeyedSubtree$Mate extends KeyedSubtree with Mate {
  /// KeyedSubtree KeyedSubtree({Key? key, required Widget child})
  KeyedSubtree$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Widget child} , default:none
    required Widget child,
  }) : super(
          key: key,
          child: child,
        ) {
    mateBuilderName = 'KeyedSubtree';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => KeyedSubtree$Mate(
          key: p.get('key').build(),
          child: p.get('child').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
  }
}

/// class Builder extends StatelessWidget
class Builder$Mate extends Builder with Mate {
  /// Builder Builder({Key? key, required Widget Function(BuildContext) builder})
  Builder$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Widget Function(BuildContext) builder} , default:none
    required WidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateBuilderName = 'Builder';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => Builder$Mate(
          key: p.get('key').build(),
          builder: p.get('builder').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'builder',
      builder,
      isNamed: true,
    );
  }
}

/// class StatefulBuilder extends StatefulWidget
class StatefulBuilder$Mate extends StatefulBuilder with Mate {
  /// StatefulBuilder StatefulBuilder({Key? key, required Widget Function(BuildContext, void Function(void Function())) builder})
  StatefulBuilder$Mate({
    /// optionalParameters: {Key? key} , default:none
    Key? key,

    /// optionalParameters: {required Widget Function(BuildContext, void Function(void Function())) builder} , default:none
    required StatefulWidgetBuilder builder,
  }) : super(
          key: key,
          builder: builder,
        ) {
    mateBuilderName = 'StatefulBuilder';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => StatefulBuilder$Mate(
          key: p.get('key').build(),
          builder: p.get('builder').build(),
        );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
    mateUse(
      'builder',
      builder,
      isNamed: true,
    );
  }
}

/// class ColoredBox extends SingleChildRenderObjectWidget
class ColoredBox$Mate extends ColoredBox with Mate {
  /// ColoredBox ColoredBox({required Color color, Widget? child, Key? key})
  ColoredBox$Mate({
    /// optionalParameters: {required Color color} , default:none
    required Color color,

    /// optionalParameters: {Widget? child} , default:none
    Widget? child,

    /// optionalParameters: {Key? key} , default:none
    Key? key,
  }) : super(
          color: color,
          child: child,
          key: key,
        ) {
    mateBuilderName = 'ColoredBox';
    matePackageUrl = 'package:flutter/widgets.dart';
    mateBuilder = (p) => ColoredBox$Mate(
          color: p.get('color').build(),
          child: p.get('child').build(),
          key: p.get('key').build(),
        );
    mateUse(
      'color',
      color,
      isNamed: true,
    );
    mateUse(
      'child',
      child,
      isNamed: true,
    );
    mateUse(
      'key',
      key,
      isNamed: true,
    );
  }
}
