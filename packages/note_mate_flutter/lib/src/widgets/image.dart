// /// Generated by gen_maters.dart, please don't edit! 

import 'package:flutter/src/widgets/image.dart';import 'package:flutter/src/foundation/key.dart';import 'package:flutter/src/painting/image_provider.dart';import 'dart:core';import 'dart:ui';import 'package:flutter/src/animation/animation.dart';import 'package:flutter/src/painting/box_fit.dart';import 'package:flutter/src/painting/alignment.dart';import 'package:flutter/src/painting/decoration_image.dart';import 'dart:io';import 'package:flutter/src/services/asset_bundle.dart';import 'dart:typed_data';import 'package:note/mate.dart' show Mate;/// class Image extends StatefulWidget
class Image$Mate extends Image with Mate {/// Image Image({Key? key, required ImageProvider<Object> image, Widget Function(BuildContext, Widget, int?, bool)? frameBuilder, Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder, Widget Function(BuildContext, Object, StackTrace?)? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, FilterQuality filterQuality = FilterQuality.low})
Image$Mate({/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {required ImageProvider<Object> image} , hasDefaultValue:false, defaultValueCode:null
required ImageProvider<Object> image, /// optionalParameters: {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageFrameBuilder? frameBuilder, /// optionalParameters: {Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageLoadingBuilder? loadingBuilder, /// optionalParameters: {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageErrorWidgetBuilder? errorBuilder, /// optionalParameters: {String? semanticLabel} , hasDefaultValue:false, defaultValueCode:null
String? semanticLabel, /// optionalParameters: {bool excludeFromSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool excludeFromSemantics, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
Color? color, /// optionalParameters: {Animation<double>? opacity} , hasDefaultValue:false, defaultValueCode:null
Animation<double>? opacity, /// optionalParameters: {BlendMode? colorBlendMode} , hasDefaultValue:false, defaultValueCode:null
BlendMode? colorBlendMode, /// optionalParameters: {BoxFit? fit} , hasDefaultValue:false, defaultValueCode:null
BoxFit? fit, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , hasDefaultValue:true, defaultValueCode:ImageRepeat.noRepeat
required ImageRepeat repeat, /// optionalParameters: {Rect? centerSlice} , hasDefaultValue:false, defaultValueCode:null
Rect? centerSlice, /// optionalParameters: {bool matchTextDirection = false} , hasDefaultValue:true, defaultValueCode:false
required bool matchTextDirection, /// optionalParameters: {bool gaplessPlayback = false} , hasDefaultValue:true, defaultValueCode:false
required bool gaplessPlayback, /// optionalParameters: {bool isAntiAlias = false} , hasDefaultValue:true, defaultValueCode:false
required bool isAntiAlias, /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , hasDefaultValue:true, defaultValueCode:FilterQuality.low
required FilterQuality filterQuality, }) : super(key: key, image: image, frameBuilder: frameBuilder, loadingBuilder: loadingBuilder, errorBuilder: errorBuilder, semanticLabel: semanticLabel, excludeFromSemantics: excludeFromSemantics, width: width, height: height, color: color, opacity: opacity, colorBlendMode: colorBlendMode, fit: fit, alignment: alignment, repeat: repeat, centerSlice: centerSlice, matchTextDirection: matchTextDirection, gaplessPlayback: gaplessPlayback, isAntiAlias: isAntiAlias, filterQuality: filterQuality, ) { mateBuilder = (p) => Image$Mate(key: p.get('key').build(), image: p.get('image').build(), frameBuilder: p.get('frameBuilder').build(), loadingBuilder: p.get('loadingBuilder').build(), errorBuilder: p.get('errorBuilder').build(), semanticLabel: p.get('semanticLabel').build(), excludeFromSemantics: p.get('excludeFromSemantics').build(), width: p.get('width').build(), height: p.get('height').build(), color: p.get('color').build(), opacity: p.get('opacity').build(), colorBlendMode: p.get('colorBlendMode').build(), fit: p.get('fit').build(), alignment: p.get('alignment').build(), repeat: p.get('repeat').build(), centerSlice: p.get('centerSlice').build(), matchTextDirection: p.get('matchTextDirection').build(), gaplessPlayback: p.get('gaplessPlayback').build(), isAntiAlias: p.get('isAntiAlias').build(), filterQuality: p.get('filterQuality').build(), );
matePut('key', key);
matePut('image', image);
matePut('frameBuilder', frameBuilder);
matePut('loadingBuilder', loadingBuilder);
matePut('errorBuilder', errorBuilder);
matePut('semanticLabel', semanticLabel);
matePut('excludeFromSemantics', excludeFromSemantics);
matePut('width', width);
matePut('height', height);
matePut('color', color);
matePut('opacity', opacity);
matePut('colorBlendMode', colorBlendMode);
matePut('fit', fit);
matePut('alignment', alignment);
matePut('repeat', repeat);
matePut('centerSlice', centerSlice);
matePut('matchTextDirection', matchTextDirection);
matePut('gaplessPlayback', gaplessPlayback);
matePut('isAntiAlias', isAntiAlias);
matePut('filterQuality', filterQuality); }

/// Image Image.network(String src, {Key? key, double scale = 1.0, Widget Function(BuildContext, Widget, int?, bool)? frameBuilder, Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder, Widget Function(BuildContext, Object, StackTrace?)? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, FilterQuality filterQuality = FilterQuality.low, bool isAntiAlias = false, Map<String, String>? headers, int? cacheWidth, int? cacheHeight})
Image$Mate.network(/// requiredParameters: String src 
String src, {/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double scale = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
required double scale, /// optionalParameters: {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageFrameBuilder? frameBuilder, /// optionalParameters: {Widget Function(BuildContext, Widget, ImageChunkEvent?)? loadingBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageLoadingBuilder? loadingBuilder, /// optionalParameters: {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageErrorWidgetBuilder? errorBuilder, /// optionalParameters: {String? semanticLabel} , hasDefaultValue:false, defaultValueCode:null
String? semanticLabel, /// optionalParameters: {bool excludeFromSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool excludeFromSemantics, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
Color? color, /// optionalParameters: {Animation<double>? opacity} , hasDefaultValue:false, defaultValueCode:null
Animation<double>? opacity, /// optionalParameters: {BlendMode? colorBlendMode} , hasDefaultValue:false, defaultValueCode:null
BlendMode? colorBlendMode, /// optionalParameters: {BoxFit? fit} , hasDefaultValue:false, defaultValueCode:null
BoxFit? fit, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , hasDefaultValue:true, defaultValueCode:ImageRepeat.noRepeat
required ImageRepeat repeat, /// optionalParameters: {Rect? centerSlice} , hasDefaultValue:false, defaultValueCode:null
Rect? centerSlice, /// optionalParameters: {bool matchTextDirection = false} , hasDefaultValue:true, defaultValueCode:false
required bool matchTextDirection, /// optionalParameters: {bool gaplessPlayback = false} , hasDefaultValue:true, defaultValueCode:false
required bool gaplessPlayback, /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , hasDefaultValue:true, defaultValueCode:FilterQuality.low
required FilterQuality filterQuality, /// optionalParameters: {bool isAntiAlias = false} , hasDefaultValue:true, defaultValueCode:false
required bool isAntiAlias, /// optionalParameters: {Map<String, String>? headers} , hasDefaultValue:false, defaultValueCode:null
Map<String,String>? headers, /// optionalParameters: {int? cacheWidth} , hasDefaultValue:false, defaultValueCode:null
int? cacheWidth, /// optionalParameters: {int? cacheHeight} , hasDefaultValue:false, defaultValueCode:null
int? cacheHeight, }) : super.network(src, key: key, scale: scale, frameBuilder: frameBuilder, loadingBuilder: loadingBuilder, errorBuilder: errorBuilder, semanticLabel: semanticLabel, excludeFromSemantics: excludeFromSemantics, width: width, height: height, color: color, opacity: opacity, colorBlendMode: colorBlendMode, fit: fit, alignment: alignment, repeat: repeat, centerSlice: centerSlice, matchTextDirection: matchTextDirection, gaplessPlayback: gaplessPlayback, filterQuality: filterQuality, isAntiAlias: isAntiAlias, headers: headers, cacheWidth: cacheWidth, cacheHeight: cacheHeight, ) { mateBuilder = (p) => Image$Mate.network(p.get('src').value, key: p.get('key').build(), scale: p.get('scale').build(), frameBuilder: p.get('frameBuilder').build(), loadingBuilder: p.get('loadingBuilder').build(), errorBuilder: p.get('errorBuilder').build(), semanticLabel: p.get('semanticLabel').build(), excludeFromSemantics: p.get('excludeFromSemantics').build(), width: p.get('width').build(), height: p.get('height').build(), color: p.get('color').build(), opacity: p.get('opacity').build(), colorBlendMode: p.get('colorBlendMode').build(), fit: p.get('fit').build(), alignment: p.get('alignment').build(), repeat: p.get('repeat').build(), centerSlice: p.get('centerSlice').build(), matchTextDirection: p.get('matchTextDirection').build(), gaplessPlayback: p.get('gaplessPlayback').build(), filterQuality: p.get('filterQuality').build(), isAntiAlias: p.get('isAntiAlias').build(), headers: p.get('headers').build(), cacheWidth: p.get('cacheWidth').build(), cacheHeight: p.get('cacheHeight').build(), );
matePut('src', src);
matePut('key', key);
matePut('scale', scale);
matePut('frameBuilder', frameBuilder);
matePut('loadingBuilder', loadingBuilder);
matePut('errorBuilder', errorBuilder);
matePut('semanticLabel', semanticLabel);
matePut('excludeFromSemantics', excludeFromSemantics);
matePut('width', width);
matePut('height', height);
matePut('color', color);
matePut('opacity', opacity);
matePut('colorBlendMode', colorBlendMode);
matePut('fit', fit);
matePut('alignment', alignment);
matePut('repeat', repeat);
matePut('centerSlice', centerSlice);
matePut('matchTextDirection', matchTextDirection);
matePut('gaplessPlayback', gaplessPlayback);
matePut('filterQuality', filterQuality);
matePut('isAntiAlias', isAntiAlias);
matePut('headers', headers);
matePut('cacheWidth', cacheWidth);
matePut('cacheHeight', cacheHeight); }

/// Image Image.file(File file, {Key? key, double scale = 1.0, Widget Function(BuildContext, Widget, int?, bool)? frameBuilder, Widget Function(BuildContext, Object, StackTrace?)? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, FilterQuality filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight})
Image$Mate.file(/// requiredParameters: File file 
File file, {/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double scale = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
required double scale, /// optionalParameters: {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageFrameBuilder? frameBuilder, /// optionalParameters: {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageErrorWidgetBuilder? errorBuilder, /// optionalParameters: {String? semanticLabel} , hasDefaultValue:false, defaultValueCode:null
String? semanticLabel, /// optionalParameters: {bool excludeFromSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool excludeFromSemantics, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
Color? color, /// optionalParameters: {Animation<double>? opacity} , hasDefaultValue:false, defaultValueCode:null
Animation<double>? opacity, /// optionalParameters: {BlendMode? colorBlendMode} , hasDefaultValue:false, defaultValueCode:null
BlendMode? colorBlendMode, /// optionalParameters: {BoxFit? fit} , hasDefaultValue:false, defaultValueCode:null
BoxFit? fit, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , hasDefaultValue:true, defaultValueCode:ImageRepeat.noRepeat
required ImageRepeat repeat, /// optionalParameters: {Rect? centerSlice} , hasDefaultValue:false, defaultValueCode:null
Rect? centerSlice, /// optionalParameters: {bool matchTextDirection = false} , hasDefaultValue:true, defaultValueCode:false
required bool matchTextDirection, /// optionalParameters: {bool gaplessPlayback = false} , hasDefaultValue:true, defaultValueCode:false
required bool gaplessPlayback, /// optionalParameters: {bool isAntiAlias = false} , hasDefaultValue:true, defaultValueCode:false
required bool isAntiAlias, /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , hasDefaultValue:true, defaultValueCode:FilterQuality.low
required FilterQuality filterQuality, /// optionalParameters: {int? cacheWidth} , hasDefaultValue:false, defaultValueCode:null
int? cacheWidth, /// optionalParameters: {int? cacheHeight} , hasDefaultValue:false, defaultValueCode:null
int? cacheHeight, }) : super.file(file, key: key, scale: scale, frameBuilder: frameBuilder, errorBuilder: errorBuilder, semanticLabel: semanticLabel, excludeFromSemantics: excludeFromSemantics, width: width, height: height, color: color, opacity: opacity, colorBlendMode: colorBlendMode, fit: fit, alignment: alignment, repeat: repeat, centerSlice: centerSlice, matchTextDirection: matchTextDirection, gaplessPlayback: gaplessPlayback, isAntiAlias: isAntiAlias, filterQuality: filterQuality, cacheWidth: cacheWidth, cacheHeight: cacheHeight, ) { mateBuilder = (p) => Image$Mate.file(p.get('file').value, key: p.get('key').build(), scale: p.get('scale').build(), frameBuilder: p.get('frameBuilder').build(), errorBuilder: p.get('errorBuilder').build(), semanticLabel: p.get('semanticLabel').build(), excludeFromSemantics: p.get('excludeFromSemantics').build(), width: p.get('width').build(), height: p.get('height').build(), color: p.get('color').build(), opacity: p.get('opacity').build(), colorBlendMode: p.get('colorBlendMode').build(), fit: p.get('fit').build(), alignment: p.get('alignment').build(), repeat: p.get('repeat').build(), centerSlice: p.get('centerSlice').build(), matchTextDirection: p.get('matchTextDirection').build(), gaplessPlayback: p.get('gaplessPlayback').build(), isAntiAlias: p.get('isAntiAlias').build(), filterQuality: p.get('filterQuality').build(), cacheWidth: p.get('cacheWidth').build(), cacheHeight: p.get('cacheHeight').build(), );
matePut('file', file);
matePut('key', key);
matePut('scale', scale);
matePut('frameBuilder', frameBuilder);
matePut('errorBuilder', errorBuilder);
matePut('semanticLabel', semanticLabel);
matePut('excludeFromSemantics', excludeFromSemantics);
matePut('width', width);
matePut('height', height);
matePut('color', color);
matePut('opacity', opacity);
matePut('colorBlendMode', colorBlendMode);
matePut('fit', fit);
matePut('alignment', alignment);
matePut('repeat', repeat);
matePut('centerSlice', centerSlice);
matePut('matchTextDirection', matchTextDirection);
matePut('gaplessPlayback', gaplessPlayback);
matePut('isAntiAlias', isAntiAlias);
matePut('filterQuality', filterQuality);
matePut('cacheWidth', cacheWidth);
matePut('cacheHeight', cacheHeight); }

/// Image Image.asset(String name, {Key? key, AssetBundle? bundle, Widget Function(BuildContext, Widget, int?, bool)? frameBuilder, Widget Function(BuildContext, Object, StackTrace?)? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? scale, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, String? package, FilterQuality filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight})
Image$Mate.asset(/// requiredParameters: String name 
String name, {/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {AssetBundle? bundle} , hasDefaultValue:false, defaultValueCode:null
AssetBundle? bundle, /// optionalParameters: {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageFrameBuilder? frameBuilder, /// optionalParameters: {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageErrorWidgetBuilder? errorBuilder, /// optionalParameters: {String? semanticLabel} , hasDefaultValue:false, defaultValueCode:null
String? semanticLabel, /// optionalParameters: {bool excludeFromSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool excludeFromSemantics, /// optionalParameters: {double? scale} , hasDefaultValue:false, defaultValueCode:null
double? scale, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
Color? color, /// optionalParameters: {Animation<double>? opacity} , hasDefaultValue:false, defaultValueCode:null
Animation<double>? opacity, /// optionalParameters: {BlendMode? colorBlendMode} , hasDefaultValue:false, defaultValueCode:null
BlendMode? colorBlendMode, /// optionalParameters: {BoxFit? fit} , hasDefaultValue:false, defaultValueCode:null
BoxFit? fit, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , hasDefaultValue:true, defaultValueCode:ImageRepeat.noRepeat
required ImageRepeat repeat, /// optionalParameters: {Rect? centerSlice} , hasDefaultValue:false, defaultValueCode:null
Rect? centerSlice, /// optionalParameters: {bool matchTextDirection = false} , hasDefaultValue:true, defaultValueCode:false
required bool matchTextDirection, /// optionalParameters: {bool gaplessPlayback = false} , hasDefaultValue:true, defaultValueCode:false
required bool gaplessPlayback, /// optionalParameters: {bool isAntiAlias = false} , hasDefaultValue:true, defaultValueCode:false
required bool isAntiAlias, /// optionalParameters: {String? package} , hasDefaultValue:false, defaultValueCode:null
String? package, /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , hasDefaultValue:true, defaultValueCode:FilterQuality.low
required FilterQuality filterQuality, /// optionalParameters: {int? cacheWidth} , hasDefaultValue:false, defaultValueCode:null
int? cacheWidth, /// optionalParameters: {int? cacheHeight} , hasDefaultValue:false, defaultValueCode:null
int? cacheHeight, }) : super.asset(name, key: key, bundle: bundle, frameBuilder: frameBuilder, errorBuilder: errorBuilder, semanticLabel: semanticLabel, excludeFromSemantics: excludeFromSemantics, scale: scale, width: width, height: height, color: color, opacity: opacity, colorBlendMode: colorBlendMode, fit: fit, alignment: alignment, repeat: repeat, centerSlice: centerSlice, matchTextDirection: matchTextDirection, gaplessPlayback: gaplessPlayback, isAntiAlias: isAntiAlias, package: package, filterQuality: filterQuality, cacheWidth: cacheWidth, cacheHeight: cacheHeight, ) { mateBuilder = (p) => Image$Mate.asset(p.get('name').value, key: p.get('key').build(), bundle: p.get('bundle').build(), frameBuilder: p.get('frameBuilder').build(), errorBuilder: p.get('errorBuilder').build(), semanticLabel: p.get('semanticLabel').build(), excludeFromSemantics: p.get('excludeFromSemantics').build(), scale: p.get('scale').build(), width: p.get('width').build(), height: p.get('height').build(), color: p.get('color').build(), opacity: p.get('opacity').build(), colorBlendMode: p.get('colorBlendMode').build(), fit: p.get('fit').build(), alignment: p.get('alignment').build(), repeat: p.get('repeat').build(), centerSlice: p.get('centerSlice').build(), matchTextDirection: p.get('matchTextDirection').build(), gaplessPlayback: p.get('gaplessPlayback').build(), isAntiAlias: p.get('isAntiAlias').build(), package: p.get('package').build(), filterQuality: p.get('filterQuality').build(), cacheWidth: p.get('cacheWidth').build(), cacheHeight: p.get('cacheHeight').build(), );
matePut('name', name);
matePut('key', key);
matePut('bundle', bundle);
matePut('frameBuilder', frameBuilder);
matePut('errorBuilder', errorBuilder);
matePut('semanticLabel', semanticLabel);
matePut('excludeFromSemantics', excludeFromSemantics);
matePut('scale', scale);
matePut('width', width);
matePut('height', height);
matePut('color', color);
matePut('opacity', opacity);
matePut('colorBlendMode', colorBlendMode);
matePut('fit', fit);
matePut('alignment', alignment);
matePut('repeat', repeat);
matePut('centerSlice', centerSlice);
matePut('matchTextDirection', matchTextDirection);
matePut('gaplessPlayback', gaplessPlayback);
matePut('isAntiAlias', isAntiAlias);
matePut('package', package);
matePut('filterQuality', filterQuality);
matePut('cacheWidth', cacheWidth);
matePut('cacheHeight', cacheHeight); }

/// Image Image.memory(Uint8List bytes, {Key? key, double scale = 1.0, Widget Function(BuildContext, Widget, int?, bool)? frameBuilder, Widget Function(BuildContext, Object, StackTrace?)? errorBuilder, String? semanticLabel, bool excludeFromSemantics = false, double? width, double? height, Color? color, Animation<double>? opacity, BlendMode? colorBlendMode, BoxFit? fit, AlignmentGeometry alignment = Alignment.center, ImageRepeat repeat = ImageRepeat.noRepeat, Rect? centerSlice, bool matchTextDirection = false, bool gaplessPlayback = false, bool isAntiAlias = false, FilterQuality filterQuality = FilterQuality.low, int? cacheWidth, int? cacheHeight})
Image$Mate.memory(/// requiredParameters: Uint8List bytes 
Uint8List bytes, {/// optionalParameters: {Key? key} , hasDefaultValue:false, defaultValueCode:null
Key? key, /// optionalParameters: {double scale = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
required double scale, /// optionalParameters: {Widget Function(BuildContext, Widget, int?, bool)? frameBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageFrameBuilder? frameBuilder, /// optionalParameters: {Widget Function(BuildContext, Object, StackTrace?)? errorBuilder} , hasDefaultValue:false, defaultValueCode:null
ImageErrorWidgetBuilder? errorBuilder, /// optionalParameters: {String? semanticLabel} , hasDefaultValue:false, defaultValueCode:null
String? semanticLabel, /// optionalParameters: {bool excludeFromSemantics = false} , hasDefaultValue:true, defaultValueCode:false
required bool excludeFromSemantics, /// optionalParameters: {double? width} , hasDefaultValue:false, defaultValueCode:null
double? width, /// optionalParameters: {double? height} , hasDefaultValue:false, defaultValueCode:null
double? height, /// optionalParameters: {Color? color} , hasDefaultValue:false, defaultValueCode:null
Color? color, /// optionalParameters: {Animation<double>? opacity} , hasDefaultValue:false, defaultValueCode:null
Animation<double>? opacity, /// optionalParameters: {BlendMode? colorBlendMode} , hasDefaultValue:false, defaultValueCode:null
BlendMode? colorBlendMode, /// optionalParameters: {BoxFit? fit} , hasDefaultValue:false, defaultValueCode:null
BoxFit? fit, /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
required AlignmentGeometry alignment, /// optionalParameters: {ImageRepeat repeat = ImageRepeat.noRepeat} , hasDefaultValue:true, defaultValueCode:ImageRepeat.noRepeat
required ImageRepeat repeat, /// optionalParameters: {Rect? centerSlice} , hasDefaultValue:false, defaultValueCode:null
Rect? centerSlice, /// optionalParameters: {bool matchTextDirection = false} , hasDefaultValue:true, defaultValueCode:false
required bool matchTextDirection, /// optionalParameters: {bool gaplessPlayback = false} , hasDefaultValue:true, defaultValueCode:false
required bool gaplessPlayback, /// optionalParameters: {bool isAntiAlias = false} , hasDefaultValue:true, defaultValueCode:false
required bool isAntiAlias, /// optionalParameters: {FilterQuality filterQuality = FilterQuality.low} , hasDefaultValue:true, defaultValueCode:FilterQuality.low
required FilterQuality filterQuality, /// optionalParameters: {int? cacheWidth} , hasDefaultValue:false, defaultValueCode:null
int? cacheWidth, /// optionalParameters: {int? cacheHeight} , hasDefaultValue:false, defaultValueCode:null
int? cacheHeight, }) : super.memory(bytes, key: key, scale: scale, frameBuilder: frameBuilder, errorBuilder: errorBuilder, semanticLabel: semanticLabel, excludeFromSemantics: excludeFromSemantics, width: width, height: height, color: color, opacity: opacity, colorBlendMode: colorBlendMode, fit: fit, alignment: alignment, repeat: repeat, centerSlice: centerSlice, matchTextDirection: matchTextDirection, gaplessPlayback: gaplessPlayback, isAntiAlias: isAntiAlias, filterQuality: filterQuality, cacheWidth: cacheWidth, cacheHeight: cacheHeight, ) { mateBuilder = (p) => Image$Mate.memory(p.get('bytes').value, key: p.get('key').build(), scale: p.get('scale').build(), frameBuilder: p.get('frameBuilder').build(), errorBuilder: p.get('errorBuilder').build(), semanticLabel: p.get('semanticLabel').build(), excludeFromSemantics: p.get('excludeFromSemantics').build(), width: p.get('width').build(), height: p.get('height').build(), color: p.get('color').build(), opacity: p.get('opacity').build(), colorBlendMode: p.get('colorBlendMode').build(), fit: p.get('fit').build(), alignment: p.get('alignment').build(), repeat: p.get('repeat').build(), centerSlice: p.get('centerSlice').build(), matchTextDirection: p.get('matchTextDirection').build(), gaplessPlayback: p.get('gaplessPlayback').build(), isAntiAlias: p.get('isAntiAlias').build(), filterQuality: p.get('filterQuality').build(), cacheWidth: p.get('cacheWidth').build(), cacheHeight: p.get('cacheHeight').build(), );
matePut('bytes', bytes);
matePut('key', key);
matePut('scale', scale);
matePut('frameBuilder', frameBuilder);
matePut('errorBuilder', errorBuilder);
matePut('semanticLabel', semanticLabel);
matePut('excludeFromSemantics', excludeFromSemantics);
matePut('width', width);
matePut('height', height);
matePut('color', color);
matePut('opacity', opacity);
matePut('colorBlendMode', colorBlendMode);
matePut('fit', fit);
matePut('alignment', alignment);
matePut('repeat', repeat);
matePut('centerSlice', centerSlice);
matePut('matchTextDirection', matchTextDirection);
matePut('gaplessPlayback', gaplessPlayback);
matePut('isAntiAlias', isAntiAlias);
matePut('filterQuality', filterQuality);
matePut('cacheWidth', cacheWidth);
matePut('cacheHeight', cacheHeight); }

 }
