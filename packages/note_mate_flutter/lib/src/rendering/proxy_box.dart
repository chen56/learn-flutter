// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:flutter/src/rendering/box.dart';
import 'package:note/mate.dart';
import 'dart:core';
import 'package:flutter/src/animation/animation.dart';
import 'dart:ui';
import 'package:flutter/src/painting/borders.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:flutter/src/painting/decoration.dart';
import 'package:flutter/src/painting/image_provider.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/gestures/tap.dart';
import 'package:flutter/src/gestures/long_press.dart';
import 'package:flutter/src/gestures/drag_details.dart';
import 'package:flutter/src/semantics/semantics.dart';
import 'package:flutter/src/rendering/layer.dart';

/// class RenderProxyBox extends RenderBox with RenderObjectWithChildMixin<RenderBox>, RenderProxyBoxMixin<RenderBox>
class RenderProxyBox$Mate extends RenderProxyBox with Mate<RenderProxyBox$Mate> {
  /// RenderProxyBox RenderProxyBox([RenderBox? child])
  RenderProxyBox$Mate(

      /// requiredParameters: [RenderBox? child]
      RenderBox? child)
      : super(child) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderProxyBox$Mate(p.get('child').value),
    );
    mateParams.put('child', child);
  }
}

/// class RenderConstrainedBox extends RenderProxyBox
class RenderConstrainedBox$Mate extends RenderConstrainedBox with Mate<RenderConstrainedBox$Mate> {
  /// RenderConstrainedBox RenderConstrainedBox({RenderBox? child, required BoxConstraints additionalConstraints})
  RenderConstrainedBox$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required BoxConstraints additionalConstraints} , hasDefaultValue:false, defaultValueCode:null
    required BoxConstraints additionalConstraints,
  }) : super(
          child: child,
          additionalConstraints: additionalConstraints,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderConstrainedBox$Mate(
        child: p.get('child').build(),
        additionalConstraints: p.get('additionalConstraints').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('additionalConstraints', additionalConstraints);
  }
}

/// class RenderLimitedBox extends RenderProxyBox
class RenderLimitedBox$Mate extends RenderLimitedBox with Mate<RenderLimitedBox$Mate> {
  /// RenderLimitedBox RenderLimitedBox({RenderBox? child, double maxWidth = double.infinity, double maxHeight = double.infinity})
  RenderLimitedBox$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {double maxWidth = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
    required double maxWidth,

    /// optionalParameters: {double maxHeight = double.infinity} , hasDefaultValue:true, defaultValueCode:double.infinity
    required double maxHeight,
  }) : super(
          child: child,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderLimitedBox$Mate(
        child: p.get('child').build(),
        maxWidth: p.get('maxWidth').build(),
        maxHeight: p.get('maxHeight').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('maxWidth', maxWidth);
    mateParams.put('maxHeight', maxHeight);
  }
}

/// class RenderAspectRatio extends RenderProxyBox
class RenderAspectRatio$Mate extends RenderAspectRatio with Mate<RenderAspectRatio$Mate> {
  /// RenderAspectRatio RenderAspectRatio({RenderBox? child, required double aspectRatio})
  RenderAspectRatio$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required double aspectRatio} , hasDefaultValue:false, defaultValueCode:null
    required double aspectRatio,
  }) : super(
          child: child,
          aspectRatio: aspectRatio,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderAspectRatio$Mate(
        child: p.get('child').build(),
        aspectRatio: p.get('aspectRatio').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('aspectRatio', aspectRatio);
  }
}

/// class RenderIntrinsicWidth extends RenderProxyBox
class RenderIntrinsicWidth$Mate extends RenderIntrinsicWidth with Mate<RenderIntrinsicWidth$Mate> {
  /// RenderIntrinsicWidth RenderIntrinsicWidth({double? stepWidth, double? stepHeight, RenderBox? child})
  RenderIntrinsicWidth$Mate({
    /// optionalParameters: {double? stepWidth} , hasDefaultValue:false, defaultValueCode:null
    double? stepWidth,

    /// optionalParameters: {double? stepHeight} , hasDefaultValue:false, defaultValueCode:null
    double? stepHeight,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderIntrinsicWidth$Mate(
        stepWidth: p.get('stepWidth').build(),
        stepHeight: p.get('stepHeight').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('stepWidth', stepWidth);
    mateParams.put('stepHeight', stepHeight);
    mateParams.put('child', child);
  }
}

/// class RenderIntrinsicHeight extends RenderProxyBox
class RenderIntrinsicHeight$Mate extends RenderIntrinsicHeight with Mate<RenderIntrinsicHeight$Mate> {
  /// RenderIntrinsicHeight RenderIntrinsicHeight({RenderBox? child})
  RenderIntrinsicHeight$Mate(
      {
      /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
      RenderBox? child})
      : super(child: child) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderIntrinsicHeight$Mate(child: p.get('child').build()),
    );
    mateParams.put('child', child);
  }
}

/// class RenderOpacity extends RenderProxyBox
class RenderOpacity$Mate extends RenderOpacity with Mate<RenderOpacity$Mate> {
  /// RenderOpacity RenderOpacity({double opacity = 1.0, bool alwaysIncludeSemantics = false, RenderBox? child})
  RenderOpacity$Mate({
    /// optionalParameters: {double opacity = 1.0} , hasDefaultValue:true, defaultValueCode:1.0
    required double opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool alwaysIncludeSemantics,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderOpacity$Mate(
        opacity: p.get('opacity').build(),
        alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('opacity', opacity);
    mateParams.put('alwaysIncludeSemantics', alwaysIncludeSemantics);
    mateParams.put('child', child);
  }
}

/// class RenderAnimatedOpacity extends RenderProxyBox with RenderAnimatedOpacityMixin<RenderBox>
class RenderAnimatedOpacity$Mate extends RenderAnimatedOpacity with Mate<RenderAnimatedOpacity$Mate> {
  /// RenderAnimatedOpacity RenderAnimatedOpacity({required Animation<double> opacity, bool alwaysIncludeSemantics = false, RenderBox? child})
  RenderAnimatedOpacity$Mate({
    /// optionalParameters: {required Animation<double> opacity} , hasDefaultValue:false, defaultValueCode:null
    required Animation<double> opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool alwaysIncludeSemantics,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderAnimatedOpacity$Mate(
        opacity: p.get('opacity').build(),
        alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('opacity', opacity);
    mateParams.put('alwaysIncludeSemantics', alwaysIncludeSemantics);
    mateParams.put('child', child);
  }
}

/// class RenderShaderMask extends RenderProxyBox
class RenderShaderMask$Mate extends RenderShaderMask with Mate<RenderShaderMask$Mate> {
  /// RenderShaderMask RenderShaderMask({RenderBox? child, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate})
  RenderShaderMask$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required Shader Function(Rect) shaderCallback} , hasDefaultValue:false, defaultValueCode:null
    required ShaderCallback shaderCallback,

    /// optionalParameters: {BlendMode blendMode = BlendMode.modulate} , hasDefaultValue:true, defaultValueCode:BlendMode.modulate
    required BlendMode blendMode,
  }) : super(
          child: child,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderShaderMask$Mate(
        child: p.get('child').build(),
        shaderCallback: p.get('shaderCallback').build(),
        blendMode: p.get('blendMode').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('shaderCallback', shaderCallback);
    mateParams.put('blendMode', blendMode);
  }
}

/// class RenderBackdropFilter extends RenderProxyBox
class RenderBackdropFilter$Mate extends RenderBackdropFilter with Mate<RenderBackdropFilter$Mate> {
  /// RenderBackdropFilter RenderBackdropFilter({RenderBox? child, required ImageFilter filter, BlendMode blendMode = BlendMode.srcOver})
  RenderBackdropFilter$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required ImageFilter filter} , hasDefaultValue:false, defaultValueCode:null
    required ImageFilter filter,

    /// optionalParameters: {BlendMode blendMode = BlendMode.srcOver} , hasDefaultValue:true, defaultValueCode:BlendMode.srcOver
    required BlendMode blendMode,
  }) : super(
          child: child,
          filter: filter,
          blendMode: blendMode,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderBackdropFilter$Mate(
        child: p.get('child').build(),
        filter: p.get('filter').build(),
        blendMode: p.get('blendMode').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('filter', filter);
    mateParams.put('blendMode', blendMode);
  }
}

/// class ShapeBorderClipper extends CustomClipper<Path>
class ShapeBorderClipper$Mate extends ShapeBorderClipper with Mate<ShapeBorderClipper$Mate> {
  /// ShapeBorderClipper ShapeBorderClipper({required ShapeBorder shape, TextDirection? textDirection})
  ShapeBorderClipper$Mate({
    /// optionalParameters: {required ShapeBorder shape} , hasDefaultValue:false, defaultValueCode:null
    required ShapeBorder shape,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,
  }) : super(
          shape: shape,
          textDirection: textDirection,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => ShapeBorderClipper$Mate(
        shape: p.get('shape').build(),
        textDirection: p.get('textDirection').build(),
      ),
    );
    mateParams.put('shape', shape);
    mateParams.put('textDirection', textDirection);
  }
}

/// class RenderClipRect extends _RenderCustomClip<Rect>
class RenderClipRect$Mate extends RenderClipRect with Mate<RenderClipRect$Mate> {
  /// RenderClipRect RenderClipRect({RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipRect$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderClipRect$Mate(
        child: p.get('child').build(),
        clipper: p.get('clipper').build(),
        clipBehavior: p.get('clipBehavior').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('clipper', clipper);
    mateParams.put('clipBehavior', clipBehavior);
  }
}

/// class RenderClipRRect extends _RenderCustomClip<RRect>
class RenderClipRRect$Mate extends RenderClipRRect with Mate<RenderClipRRect$Mate> {
  /// RenderClipRRect RenderClipRRect({RenderBox? child, BorderRadiusGeometry borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, TextDirection? textDirection})
  RenderClipRRect$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {BorderRadiusGeometry borderRadius = BorderRadius.zero} , hasDefaultValue:true, defaultValueCode:BorderRadius.zero
    required BorderRadiusGeometry borderRadius,

    /// optionalParameters: {CustomClipper<RRect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<RRect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,
  }) : super(
          child: child,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          textDirection: textDirection,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderClipRRect$Mate(
        child: p.get('child').build(),
        borderRadius: p.get('borderRadius').build(),
        clipper: p.get('clipper').build(),
        clipBehavior: p.get('clipBehavior').build(),
        textDirection: p.get('textDirection').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('borderRadius', borderRadius);
    mateParams.put('clipper', clipper);
    mateParams.put('clipBehavior', clipBehavior);
    mateParams.put('textDirection', textDirection);
  }
}

/// class RenderClipOval extends _RenderCustomClip<Rect>
class RenderClipOval$Mate extends RenderClipOval with Mate<RenderClipOval$Mate> {
  /// RenderClipOval RenderClipOval({RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipOval$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderClipOval$Mate(
        child: p.get('child').build(),
        clipper: p.get('clipper').build(),
        clipBehavior: p.get('clipBehavior').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('clipper', clipper);
    mateParams.put('clipBehavior', clipBehavior);
  }
}

/// class RenderClipPath extends _RenderCustomClip<Path>
class RenderClipPath$Mate extends RenderClipPath with Mate<RenderClipPath$Mate> {
  /// RenderClipPath RenderClipPath({RenderBox? child, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipPath$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Path>? clipper} , hasDefaultValue:false, defaultValueCode:null
    CustomClipper<Path>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , hasDefaultValue:true, defaultValueCode:Clip.antiAlias
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderClipPath$Mate(
        child: p.get('child').build(),
        clipper: p.get('clipper').build(),
        clipBehavior: p.get('clipBehavior').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('clipper', clipper);
    mateParams.put('clipBehavior', clipBehavior);
  }
}

/// class RenderPhysicalModel extends _RenderPhysicalModelBase<RRect>
class RenderPhysicalModel$Mate extends RenderPhysicalModel with Mate<RenderPhysicalModel$Mate> {
  /// RenderPhysicalModel RenderPhysicalModel({RenderBox? child, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)})
  RenderPhysicalModel$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {BoxShape shape = BoxShape.rectangle} , hasDefaultValue:true, defaultValueCode:BoxShape.rectangle
    required BoxShape shape,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {BorderRadius? borderRadius} , hasDefaultValue:false, defaultValueCode:null
    BorderRadius? borderRadius,

    /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double elevation,

    /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
    required Color shadowColor,
  }) : super(
          child: child,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderPhysicalModel$Mate(
        child: p.get('child').build(),
        shape: p.get('shape').build(),
        clipBehavior: p.get('clipBehavior').build(),
        borderRadius: p.get('borderRadius').build(),
        elevation: p.get('elevation').build(),
        color: p.get('color').build(),
        shadowColor: p.get('shadowColor').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('shape', shape);
    mateParams.put('clipBehavior', clipBehavior);
    mateParams.put('borderRadius', borderRadius);
    mateParams.put('elevation', elevation);
    mateParams.put('color', color);
    mateParams.put('shadowColor', shadowColor);
  }
}

/// class RenderPhysicalShape extends _RenderPhysicalModelBase<Path>
class RenderPhysicalShape$Mate extends RenderPhysicalShape with Mate<RenderPhysicalShape$Mate> {
  /// RenderPhysicalShape RenderPhysicalShape({RenderBox? child, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)})
  RenderPhysicalShape$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required CustomClipper<Path> clipper} , hasDefaultValue:false, defaultValueCode:null
    required CustomClipper<Path> clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,

    /// optionalParameters: {double elevation = 0.0} , hasDefaultValue:true, defaultValueCode:0.0
    required double elevation,

    /// optionalParameters: {required Color color} , hasDefaultValue:false, defaultValueCode:null
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , hasDefaultValue:true, defaultValueCode:const Color(0xFF000000)
    required Color shadowColor,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderPhysicalShape$Mate(
        child: p.get('child').build(),
        clipper: p.get('clipper').build(),
        clipBehavior: p.get('clipBehavior').build(),
        elevation: p.get('elevation').build(),
        color: p.get('color').build(),
        shadowColor: p.get('shadowColor').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('clipper', clipper);
    mateParams.put('clipBehavior', clipBehavior);
    mateParams.put('elevation', elevation);
    mateParams.put('color', color);
    mateParams.put('shadowColor', shadowColor);
  }
}

/// class RenderDecoratedBox extends RenderProxyBox
class RenderDecoratedBox$Mate extends RenderDecoratedBox with Mate<RenderDecoratedBox$Mate> {
  /// RenderDecoratedBox RenderDecoratedBox({required Decoration decoration, DecorationPosition position = DecorationPosition.background, ImageConfiguration configuration = ImageConfiguration.empty, RenderBox? child})
  RenderDecoratedBox$Mate({
    /// optionalParameters: {required Decoration decoration} , hasDefaultValue:false, defaultValueCode:null
    required Decoration decoration,

    /// optionalParameters: {DecorationPosition position = DecorationPosition.background} , hasDefaultValue:true, defaultValueCode:DecorationPosition.background
    required DecorationPosition position,

    /// optionalParameters: {ImageConfiguration configuration = ImageConfiguration.empty} , hasDefaultValue:true, defaultValueCode:ImageConfiguration.empty
    required ImageConfiguration configuration,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          decoration: decoration,
          position: position,
          configuration: configuration,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderDecoratedBox$Mate(
        decoration: p.get('decoration').build(),
        position: p.get('position').build(),
        configuration: p.get('configuration').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('decoration', decoration);
    mateParams.put('position', position);
    mateParams.put('configuration', configuration);
    mateParams.put('child', child);
  }
}

/// class RenderTransform extends RenderProxyBox
class RenderTransform$Mate extends RenderTransform with Mate<RenderTransform$Mate> {
  /// RenderTransform RenderTransform({required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, TextDirection? textDirection, bool transformHitTests = true, FilterQuality? filterQuality, RenderBox? child})
  RenderTransform$Mate({
    /// optionalParameters: {required Matrix4 transform} , hasDefaultValue:false, defaultValueCode:null
    required Matrix4 transform,

    /// optionalParameters: {Offset? origin} , hasDefaultValue:false, defaultValueCode:null
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment} , hasDefaultValue:false, defaultValueCode:null
    AlignmentGeometry? alignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {FilterQuality? filterQuality} , hasDefaultValue:false, defaultValueCode:null
    FilterQuality? filterQuality,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          transform: transform,
          origin: origin,
          alignment: alignment,
          textDirection: textDirection,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderTransform$Mate(
        transform: p.get('transform').build(),
        origin: p.get('origin').build(),
        alignment: p.get('alignment').build(),
        textDirection: p.get('textDirection').build(),
        transformHitTests: p.get('transformHitTests').build(),
        filterQuality: p.get('filterQuality').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('transform', transform);
    mateParams.put('origin', origin);
    mateParams.put('alignment', alignment);
    mateParams.put('textDirection', textDirection);
    mateParams.put('transformHitTests', transformHitTests);
    mateParams.put('filterQuality', filterQuality);
    mateParams.put('child', child);
  }
}

/// class RenderFittedBox extends RenderProxyBox
class RenderFittedBox$Mate extends RenderFittedBox with Mate<RenderFittedBox$Mate> {
  /// RenderFittedBox RenderFittedBox({BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection, RenderBox? child, Clip clipBehavior = Clip.none})
  RenderFittedBox$Mate({
    /// optionalParameters: {BoxFit fit = BoxFit.contain} , hasDefaultValue:true, defaultValueCode:BoxFit.contain
    required BoxFit fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , hasDefaultValue:true, defaultValueCode:Alignment.center
    required AlignmentGeometry alignment,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , hasDefaultValue:true, defaultValueCode:Clip.none
    required Clip clipBehavior,
  }) : super(
          fit: fit,
          alignment: alignment,
          textDirection: textDirection,
          child: child,
          clipBehavior: clipBehavior,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderFittedBox$Mate(
        fit: p.get('fit').build(),
        alignment: p.get('alignment').build(),
        textDirection: p.get('textDirection').build(),
        child: p.get('child').build(),
        clipBehavior: p.get('clipBehavior').build(),
      ),
    );
    mateParams.put('fit', fit);
    mateParams.put('alignment', alignment);
    mateParams.put('textDirection', textDirection);
    mateParams.put('child', child);
    mateParams.put('clipBehavior', clipBehavior);
  }
}

/// class RenderFractionalTranslation extends RenderProxyBox
class RenderFractionalTranslation$Mate extends RenderFractionalTranslation with Mate<RenderFractionalTranslation$Mate> {
  /// RenderFractionalTranslation RenderFractionalTranslation({required Offset translation, bool transformHitTests = true, RenderBox? child})
  RenderFractionalTranslation$Mate({
    /// optionalParameters: {required Offset translation} , hasDefaultValue:false, defaultValueCode:null
    required Offset translation,

    /// optionalParameters: {bool transformHitTests = true} , hasDefaultValue:true, defaultValueCode:true
    required bool transformHitTests,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderFractionalTranslation$Mate(
        translation: p.get('translation').build(),
        transformHitTests: p.get('transformHitTests').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('translation', translation);
    mateParams.put('transformHitTests', transformHitTests);
    mateParams.put('child', child);
  }
}

/// class RenderPointerListener extends RenderProxyBoxWithHitTestBehavior
class RenderPointerListener$Mate extends RenderPointerListener with Mate<RenderPointerListener$Mate> {
  /// RenderPointerListener RenderPointerListener({void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child})
  RenderPointerListener$Mate({
    /// optionalParameters: {void Function(PointerDownEvent)? onPointerDown} , hasDefaultValue:false, defaultValueCode:null
    PointerDownEventListener? onPointerDown,

    /// optionalParameters: {void Function(PointerMoveEvent)? onPointerMove} , hasDefaultValue:false, defaultValueCode:null
    PointerMoveEventListener? onPointerMove,

    /// optionalParameters: {void Function(PointerUpEvent)? onPointerUp} , hasDefaultValue:false, defaultValueCode:null
    PointerUpEventListener? onPointerUp,

    /// optionalParameters: {void Function(PointerHoverEvent)? onPointerHover} , hasDefaultValue:false, defaultValueCode:null
    PointerHoverEventListener? onPointerHover,

    /// optionalParameters: {void Function(PointerCancelEvent)? onPointerCancel} , hasDefaultValue:false, defaultValueCode:null
    PointerCancelEventListener? onPointerCancel,

    /// optionalParameters: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// optionalParameters: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// optionalParameters: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd} , hasDefaultValue:false, defaultValueCode:null
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// optionalParameters: {void Function(PointerSignalEvent)? onPointerSignal} , hasDefaultValue:false, defaultValueCode:null
    PointerSignalEventListener? onPointerSignal,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderPointerListener$Mate(
        onPointerDown: p.get('onPointerDown').build(),
        onPointerMove: p.get('onPointerMove').build(),
        onPointerUp: p.get('onPointerUp').build(),
        onPointerHover: p.get('onPointerHover').build(),
        onPointerCancel: p.get('onPointerCancel').build(),
        onPointerPanZoomStart: p.get('onPointerPanZoomStart').build(),
        onPointerPanZoomUpdate: p.get('onPointerPanZoomUpdate').build(),
        onPointerPanZoomEnd: p.get('onPointerPanZoomEnd').build(),
        onPointerSignal: p.get('onPointerSignal').build(),
        behavior: p.get('behavior').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('onPointerDown', onPointerDown);
    mateParams.put('onPointerMove', onPointerMove);
    mateParams.put('onPointerUp', onPointerUp);
    mateParams.put('onPointerHover', onPointerHover);
    mateParams.put('onPointerCancel', onPointerCancel);
    mateParams.put('onPointerPanZoomStart', onPointerPanZoomStart);
    mateParams.put('onPointerPanZoomUpdate', onPointerPanZoomUpdate);
    mateParams.put('onPointerPanZoomEnd', onPointerPanZoomEnd);
    mateParams.put('onPointerSignal', onPointerSignal);
    mateParams.put('behavior', behavior);
    mateParams.put('child', child);
  }
}

/// class RenderMouseRegion extends RenderProxyBoxWithHitTestBehavior implements MouseTrackerAnnotation
class RenderMouseRegion$Mate extends RenderMouseRegion with Mate<RenderMouseRegion$Mate> {
  /// RenderMouseRegion RenderMouseRegion({void Function(PointerEnterEvent)? onEnter, void Function(PointerHoverEvent)? onHover, void Function(PointerExitEvent)? onExit, MouseCursor cursor = MouseCursor.defer, bool validForMouseTracker = true, bool opaque = true, RenderBox? child, HitTestBehavior? hitTestBehavior = HitTestBehavior.opaque})
  RenderMouseRegion$Mate({
    /// optionalParameters: {void Function(PointerEnterEvent)? onEnter} , hasDefaultValue:false, defaultValueCode:null
    PointerEnterEventListener? onEnter,

    /// optionalParameters: {void Function(PointerHoverEvent)? onHover} , hasDefaultValue:false, defaultValueCode:null
    PointerHoverEventListener? onHover,

    /// optionalParameters: {void Function(PointerExitEvent)? onExit} , hasDefaultValue:false, defaultValueCode:null
    PointerExitEventListener? onExit,

    /// optionalParameters: {MouseCursor cursor = MouseCursor.defer} , hasDefaultValue:true, defaultValueCode:MouseCursor.defer
    required MouseCursor cursor,

    /// optionalParameters: {bool validForMouseTracker = true} , hasDefaultValue:true, defaultValueCode:true
    required bool validForMouseTracker,

    /// optionalParameters: {bool opaque = true} , hasDefaultValue:true, defaultValueCode:true
    required bool opaque,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {HitTestBehavior? hitTestBehavior = HitTestBehavior.opaque} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.opaque
    HitTestBehavior? hitTestBehavior,
  }) : super(
          onEnter: onEnter,
          onHover: onHover,
          onExit: onExit,
          cursor: cursor,
          validForMouseTracker: validForMouseTracker,
          opaque: opaque,
          child: child,
          hitTestBehavior: hitTestBehavior,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderMouseRegion$Mate(
        onEnter: p.get('onEnter').build(),
        onHover: p.get('onHover').build(),
        onExit: p.get('onExit').build(),
        cursor: p.get('cursor').build(),
        validForMouseTracker: p.get('validForMouseTracker').build(),
        opaque: p.get('opaque').build(),
        child: p.get('child').build(),
        hitTestBehavior: p.get('hitTestBehavior').build(),
      ),
    );
    mateParams.put('onEnter', onEnter);
    mateParams.put('onHover', onHover);
    mateParams.put('onExit', onExit);
    mateParams.put('cursor', cursor);
    mateParams.put('validForMouseTracker', validForMouseTracker);
    mateParams.put('opaque', opaque);
    mateParams.put('child', child);
    mateParams.put('hitTestBehavior', hitTestBehavior);
  }
}

/// class RenderRepaintBoundary extends RenderProxyBox
class RenderRepaintBoundary$Mate extends RenderRepaintBoundary with Mate<RenderRepaintBoundary$Mate> {
  /// RenderRepaintBoundary RenderRepaintBoundary({RenderBox? child})
  RenderRepaintBoundary$Mate(
      {
      /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
      RenderBox? child})
      : super(child: child) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderRepaintBoundary$Mate(child: p.get('child').build()),
    );
    mateParams.put('child', child);
  }
}

/// class RenderIgnorePointer extends RenderProxyBox
class RenderIgnorePointer$Mate extends RenderIgnorePointer with Mate<RenderIgnorePointer$Mate> {
  /// RenderIgnorePointer RenderIgnorePointer({RenderBox? child, bool ignoring = true, bool? ignoringSemantics})
  RenderIgnorePointer$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool ignoring = true} , hasDefaultValue:true, defaultValueCode:true
    required bool ignoring,

    /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
    bool? ignoringSemantics,
  }) : super(
          child: child,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderIgnorePointer$Mate(
        child: p.get('child').build(),
        ignoring: p.get('ignoring').build(),
        ignoringSemantics: p.get('ignoringSemantics').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('ignoring', ignoring);
    mateParams.put('ignoringSemantics', ignoringSemantics);
  }
}

/// class RenderOffstage extends RenderProxyBox
class RenderOffstage$Mate extends RenderOffstage with Mate<RenderOffstage$Mate> {
  /// RenderOffstage RenderOffstage({bool offstage = true, RenderBox? child})
  RenderOffstage$Mate({
    /// optionalParameters: {bool offstage = true} , hasDefaultValue:true, defaultValueCode:true
    required bool offstage,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          offstage: offstage,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderOffstage$Mate(
        offstage: p.get('offstage').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('offstage', offstage);
    mateParams.put('child', child);
  }
}

/// class RenderAbsorbPointer extends RenderProxyBox
class RenderAbsorbPointer$Mate extends RenderAbsorbPointer with Mate<RenderAbsorbPointer$Mate> {
  /// RenderAbsorbPointer RenderAbsorbPointer({RenderBox? child, bool absorbing = true, bool? ignoringSemantics})
  RenderAbsorbPointer$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool absorbing = true} , hasDefaultValue:true, defaultValueCode:true
    required bool absorbing,

    /// optionalParameters: {bool? ignoringSemantics} , hasDefaultValue:false, defaultValueCode:null
    bool? ignoringSemantics,
  }) : super(
          child: child,
          absorbing: absorbing,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderAbsorbPointer$Mate(
        child: p.get('child').build(),
        absorbing: p.get('absorbing').build(),
        ignoringSemantics: p.get('ignoringSemantics').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('absorbing', absorbing);
    mateParams.put('ignoringSemantics', ignoringSemantics);
  }
}

/// class RenderMetaData extends RenderProxyBoxWithHitTestBehavior
class RenderMetaData$Mate extends RenderMetaData with Mate<RenderMetaData$Mate> {
  /// RenderMetaData RenderMetaData({dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child})
  RenderMetaData$Mate({
    /// optionalParameters: {dynamic metaData} , hasDefaultValue:false, defaultValueCode:null
    required dynamic metaData,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderMetaData$Mate(
        metaData: p.get('metaData').build(),
        behavior: p.get('behavior').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('metaData', metaData);
    mateParams.put('behavior', behavior);
    mateParams.put('child', child);
  }
}

/// class RenderSemanticsGestureHandler extends RenderProxyBoxWithHitTestBehavior
class RenderSemanticsGestureHandler$Mate extends RenderSemanticsGestureHandler
    with Mate<RenderSemanticsGestureHandler$Mate> {
  /// RenderSemanticsGestureHandler RenderSemanticsGestureHandler({RenderBox? child, void Function()? onTap, void Function()? onLongPress, void Function(DragUpdateDetails)? onHorizontalDragUpdate, void Function(DragUpdateDetails)? onVerticalDragUpdate, double scrollFactor = 0.8, HitTestBehavior behavior = HitTestBehavior.deferToChild})
  RenderSemanticsGestureHandler$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {void Function()? onTap} , hasDefaultValue:false, defaultValueCode:null
    GestureTapCallback? onTap,

    /// optionalParameters: {void Function()? onLongPress} , hasDefaultValue:false, defaultValueCode:null
    GestureLongPressCallback? onLongPress,

    /// optionalParameters: {void Function(DragUpdateDetails)? onHorizontalDragUpdate} , hasDefaultValue:false, defaultValueCode:null
    GestureDragUpdateCallback? onHorizontalDragUpdate,

    /// optionalParameters: {void Function(DragUpdateDetails)? onVerticalDragUpdate} , hasDefaultValue:false, defaultValueCode:null
    GestureDragUpdateCallback? onVerticalDragUpdate,

    /// optionalParameters: {double scrollFactor = 0.8} , hasDefaultValue:true, defaultValueCode:0.8
    required double scrollFactor,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , hasDefaultValue:true, defaultValueCode:HitTestBehavior.deferToChild
    required HitTestBehavior behavior,
  }) : super(
          child: child,
          onTap: onTap,
          onLongPress: onLongPress,
          onHorizontalDragUpdate: onHorizontalDragUpdate,
          onVerticalDragUpdate: onVerticalDragUpdate,
          scrollFactor: scrollFactor,
          behavior: behavior,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderSemanticsGestureHandler$Mate(
        child: p.get('child').build(),
        onTap: p.get('onTap').build(),
        onLongPress: p.get('onLongPress').build(),
        onHorizontalDragUpdate: p.get('onHorizontalDragUpdate').build(),
        onVerticalDragUpdate: p.get('onVerticalDragUpdate').build(),
        scrollFactor: p.get('scrollFactor').build(),
        behavior: p.get('behavior').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('onTap', onTap);
    mateParams.put('onLongPress', onLongPress);
    mateParams.put('onHorizontalDragUpdate', onHorizontalDragUpdate);
    mateParams.put('onVerticalDragUpdate', onVerticalDragUpdate);
    mateParams.put('scrollFactor', scrollFactor);
    mateParams.put('behavior', behavior);
  }
}

/// class RenderSemanticsAnnotations extends RenderProxyBox
class RenderSemanticsAnnotations$Mate extends RenderSemanticsAnnotations with Mate<RenderSemanticsAnnotations$Mate> {
  /// RenderSemanticsAnnotations RenderSemanticsAnnotations({RenderBox? child, required SemanticsProperties properties, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, TextDirection? textDirection})
  RenderSemanticsAnnotations$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required SemanticsProperties properties} , hasDefaultValue:false, defaultValueCode:null
    required SemanticsProperties properties,

    /// optionalParameters: {bool container = false} , hasDefaultValue:true, defaultValueCode:false
    required bool container,

    /// optionalParameters: {bool explicitChildNodes = false} , hasDefaultValue:true, defaultValueCode:false
    required bool explicitChildNodes,

    /// optionalParameters: {bool excludeSemantics = false} , hasDefaultValue:true, defaultValueCode:false
    required bool excludeSemantics,

    /// optionalParameters: {TextDirection? textDirection} , hasDefaultValue:false, defaultValueCode:null
    TextDirection? textDirection,
  }) : super(
          child: child,
          properties: properties,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          textDirection: textDirection,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderSemanticsAnnotations$Mate(
        child: p.get('child').build(),
        properties: p.get('properties').build(),
        container: p.get('container').build(),
        explicitChildNodes: p.get('explicitChildNodes').build(),
        excludeSemantics: p.get('excludeSemantics').build(),
        textDirection: p.get('textDirection').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('properties', properties);
    mateParams.put('container', container);
    mateParams.put('explicitChildNodes', explicitChildNodes);
    mateParams.put('excludeSemantics', excludeSemantics);
    mateParams.put('textDirection', textDirection);
  }
}

/// class RenderBlockSemantics extends RenderProxyBox
class RenderBlockSemantics$Mate extends RenderBlockSemantics with Mate<RenderBlockSemantics$Mate> {
  /// RenderBlockSemantics RenderBlockSemantics({RenderBox? child, bool blocking = true})
  RenderBlockSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool blocking = true} , hasDefaultValue:true, defaultValueCode:true
    required bool blocking,
  }) : super(
          child: child,
          blocking: blocking,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderBlockSemantics$Mate(
        child: p.get('child').build(),
        blocking: p.get('blocking').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('blocking', blocking);
  }
}

/// class RenderMergeSemantics extends RenderProxyBox
class RenderMergeSemantics$Mate extends RenderMergeSemantics with Mate<RenderMergeSemantics$Mate> {
  /// RenderMergeSemantics RenderMergeSemantics({RenderBox? child})
  RenderMergeSemantics$Mate(
      {
      /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
      RenderBox? child})
      : super(child: child) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderMergeSemantics$Mate(child: p.get('child').build()),
    );
    mateParams.put('child', child);
  }
}

/// class RenderExcludeSemantics extends RenderProxyBox
class RenderExcludeSemantics$Mate extends RenderExcludeSemantics with Mate<RenderExcludeSemantics$Mate> {
  /// RenderExcludeSemantics RenderExcludeSemantics({RenderBox? child, bool excluding = true})
  RenderExcludeSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {bool excluding = true} , hasDefaultValue:true, defaultValueCode:true
    required bool excluding,
  }) : super(
          child: child,
          excluding: excluding,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderExcludeSemantics$Mate(
        child: p.get('child').build(),
        excluding: p.get('excluding').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('excluding', excluding);
  }
}

/// class RenderIndexedSemantics extends RenderProxyBox
class RenderIndexedSemantics$Mate extends RenderIndexedSemantics with Mate<RenderIndexedSemantics$Mate> {
  /// RenderIndexedSemantics RenderIndexedSemantics({RenderBox? child, required int index})
  RenderIndexedSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,

    /// optionalParameters: {required int index} , hasDefaultValue:false, defaultValueCode:null
    required int index,
  }) : super(
          child: child,
          index: index,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderIndexedSemantics$Mate(
        child: p.get('child').build(),
        index: p.get('index').build(),
      ),
    );
    mateParams.put('child', child);
    mateParams.put('index', index);
  }
}

/// class RenderLeaderLayer extends RenderProxyBox
class RenderLeaderLayer$Mate extends RenderLeaderLayer with Mate<RenderLeaderLayer$Mate> {
  /// RenderLeaderLayer RenderLeaderLayer({required LayerLink link, RenderBox? child})
  RenderLeaderLayer$Mate({
    /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
    required LayerLink link,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          link: link,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderLeaderLayer$Mate(
        link: p.get('link').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('link', link);
    mateParams.put('child', child);
  }
}

/// class RenderFollowerLayer extends RenderProxyBox
class RenderFollowerLayer$Mate extends RenderFollowerLayer with Mate<RenderFollowerLayer$Mate> {
  /// RenderFollowerLayer RenderFollowerLayer({required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment leaderAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, RenderBox? child})
  RenderFollowerLayer$Mate({
    /// optionalParameters: {required LayerLink link} , hasDefaultValue:false, defaultValueCode:null
    required LayerLink link,

    /// optionalParameters: {bool showWhenUnlinked = true} , hasDefaultValue:true, defaultValueCode:true
    required bool showWhenUnlinked,

    /// optionalParameters: {Offset offset = Offset.zero} , hasDefaultValue:true, defaultValueCode:Offset.zero
    required Offset offset,

    /// optionalParameters: {Alignment leaderAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
    required Alignment leaderAnchor,

    /// optionalParameters: {Alignment followerAnchor = Alignment.topLeft} , hasDefaultValue:true, defaultValueCode:Alignment.topLeft
    required Alignment followerAnchor,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          leaderAnchor: leaderAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderFollowerLayer$Mate(
        link: p.get('link').build(),
        showWhenUnlinked: p.get('showWhenUnlinked').build(),
        offset: p.get('offset').build(),
        leaderAnchor: p.get('leaderAnchor').build(),
        followerAnchor: p.get('followerAnchor').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('link', link);
    mateParams.put('showWhenUnlinked', showWhenUnlinked);
    mateParams.put('offset', offset);
    mateParams.put('leaderAnchor', leaderAnchor);
    mateParams.put('followerAnchor', followerAnchor);
    mateParams.put('child', child);
  }
}

/// class RenderAnnotatedRegion<T extends Object> extends RenderProxyBox
class RenderAnnotatedRegion$Mate<T extends Object> extends RenderAnnotatedRegion<T>
    with Mate<RenderAnnotatedRegion$Mate> {
  /// RenderAnnotatedRegion<T> RenderAnnotatedRegion({required T value, required bool sized, RenderBox? child})
  RenderAnnotatedRegion$Mate({
    /// optionalParameters: {required T value} , hasDefaultValue:false, defaultValueCode:null
    required T value,

    /// optionalParameters: {required bool sized} , hasDefaultValue:false, defaultValueCode:null
    required bool sized,

    /// optionalParameters: {RenderBox? child} , hasDefaultValue:false, defaultValueCode:null
    RenderBox? child,
  }) : super(
          value: value,
          sized: sized,
          child: child,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => RenderAnnotatedRegion$Mate(
        value: p.get('value').build(),
        sized: p.get('sized').build(),
        child: p.get('child').build(),
      ),
    );
    mateParams.put('value', value);
    mateParams.put('sized', sized);
    mateParams.put('child', child);
  }
}
