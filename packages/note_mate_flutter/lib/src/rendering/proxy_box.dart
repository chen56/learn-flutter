// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/rendering/proxy_box.dart';
import 'package:note/mate.dart';
import 'package:flutter/src/rendering/box.dart';
import 'dart:core';
import 'package:flutter/src/animation/animation.dart';
import 'dart:ui';
import 'package:flutter/src/painting/borders.dart';
import 'package:flutter/src/painting/border_radius.dart';
import 'package:flutter/src/painting/box_border.dart';
import 'package:flutter/src/painting/decoration.dart';
import 'package:flutter/src/painting/image_provider.dart';
import 'package:vector_math/vector_math_64.dart';
import 'package:flutter/src/painting/alignment.dart';
import 'package:flutter/src/painting/box_fit.dart';
import 'package:flutter/src/services/mouse_tracking.dart';
import 'package:flutter/src/services/mouse_cursor.dart';
import 'package:flutter/src/gestures/tap.dart';
import 'package:flutter/src/gestures/long_press.dart';
import 'package:flutter/src/gestures/drag_details.dart';
import 'package:flutter/src/semantics/semantics.dart';
import 'package:flutter/src/rendering/layer.dart';

/// class RenderProxyBox extends RenderBox with RenderObjectWithChildMixin<RenderBox>, RenderProxyBoxMixin<RenderBox>
class RenderProxyBox$Mate extends RenderProxyBox with Mate {
  /// RenderProxyBox RenderProxyBox([RenderBox? child])
  RenderProxyBox$Mate(

      /// requiredParameters: [RenderBox? child]
      RenderBox? child)
      : super(child) {
    mateBuilder = (p) => RenderProxyBox$Mate(p.get('child').value);
    mateDeclare('child', child);
  }
}

/// class RenderConstrainedBox extends RenderProxyBox
class RenderConstrainedBox$Mate extends RenderConstrainedBox with Mate {
  /// RenderConstrainedBox RenderConstrainedBox({RenderBox? child, required BoxConstraints additionalConstraints})
  RenderConstrainedBox$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {required BoxConstraints additionalConstraints} , defaultValue:none
    required BoxConstraints additionalConstraints,
  }) : super(
          child: child,
          additionalConstraints: additionalConstraints,
        ) {
    mateBuilder = (p) => RenderConstrainedBox$Mate(
          child: p.get('child').build(),
          additionalConstraints: p.get('additionalConstraints').build(),
        );
    mateDeclare('child', child);
    mateDeclare('additionalConstraints', additionalConstraints);
  }
}

/// class RenderLimitedBox extends RenderProxyBox
class RenderLimitedBox$Mate extends RenderLimitedBox with Mate {
  /// RenderLimitedBox RenderLimitedBox({RenderBox? child, double maxWidth = double.infinity, double maxHeight = double.infinity})
  RenderLimitedBox$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {double maxWidth = double.infinity} , defaultValue:unprocessed
    required double maxWidth,

    /// optionalParameters: {double maxHeight = double.infinity} , defaultValue:unprocessed
    required double maxHeight,
  }) : super(
          child: child,
          maxWidth: maxWidth,
          maxHeight: maxHeight,
        ) {
    mateBuilder = (p) => RenderLimitedBox$Mate(
          child: p.get('child').build(),
          maxWidth: p.get('maxWidth').build(),
          maxHeight: p.get('maxHeight').build(),
        );
    mateDeclare('child', child);
    mateDeclare('maxWidth', maxWidth);
    mateDeclare('maxHeight', maxHeight);
  }
}

/// class RenderAspectRatio extends RenderProxyBox
class RenderAspectRatio$Mate extends RenderAspectRatio with Mate {
  /// RenderAspectRatio RenderAspectRatio({RenderBox? child, required double aspectRatio})
  RenderAspectRatio$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {required double aspectRatio} , defaultValue:none
    required double aspectRatio,
  }) : super(
          child: child,
          aspectRatio: aspectRatio,
        ) {
    mateBuilder = (p) => RenderAspectRatio$Mate(
          child: p.get('child').build(),
          aspectRatio: p.get('aspectRatio').build(),
        );
    mateDeclare('child', child);
    mateDeclare('aspectRatio', aspectRatio);
  }
}

/// class RenderIntrinsicWidth extends RenderProxyBox
class RenderIntrinsicWidth$Mate extends RenderIntrinsicWidth with Mate {
  /// RenderIntrinsicWidth RenderIntrinsicWidth({double? stepWidth, double? stepHeight, RenderBox? child})
  RenderIntrinsicWidth$Mate({
    /// optionalParameters: {double? stepWidth} , defaultValue:none
    double? stepWidth,

    /// optionalParameters: {double? stepHeight} , defaultValue:none
    double? stepHeight,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          stepWidth: stepWidth,
          stepHeight: stepHeight,
          child: child,
        ) {
    mateBuilder = (p) => RenderIntrinsicWidth$Mate(
          stepWidth: p.get('stepWidth').build(),
          stepHeight: p.get('stepHeight').build(),
          child: p.get('child').build(),
        );
    mateDeclare('stepWidth', stepWidth);
    mateDeclare('stepHeight', stepHeight);
    mateDeclare('child', child);
  }
}

/// class RenderIntrinsicHeight extends RenderProxyBox
class RenderIntrinsicHeight$Mate extends RenderIntrinsicHeight with Mate {
  /// RenderIntrinsicHeight RenderIntrinsicHeight({RenderBox? child})
  RenderIntrinsicHeight$Mate(
      {
      /// optionalParameters: {RenderBox? child} , defaultValue:none
      RenderBox? child})
      : super(child: child) {
    mateBuilder = (p) => RenderIntrinsicHeight$Mate(child: p.get('child').build());
    mateDeclare('child', child);
  }
}

/// class RenderOpacity extends RenderProxyBox
class RenderOpacity$Mate extends RenderOpacity with Mate {
  /// RenderOpacity RenderOpacity({double opacity = 1.0, bool alwaysIncludeSemantics = false, RenderBox? child})
  RenderOpacity$Mate({
    /// optionalParameters: {double opacity = 1.0} , defaultValue:Literal
    double opacity = 1.0,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , defaultValue:Literal
    bool alwaysIncludeSemantics = false,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateBuilder = (p) => RenderOpacity$Mate(
          opacity: p.get('opacity').build(),
          alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(),
          child: p.get('child').build(),
        );
    mateDeclare('opacity', opacity);
    mateDeclare('alwaysIncludeSemantics', alwaysIncludeSemantics);
    mateDeclare('child', child);
  }
}

/// class RenderAnimatedOpacity extends RenderProxyBox with RenderAnimatedOpacityMixin<RenderBox>
class RenderAnimatedOpacity$Mate extends RenderAnimatedOpacity with Mate {
  /// RenderAnimatedOpacity RenderAnimatedOpacity({required Animation<double> opacity, bool alwaysIncludeSemantics = false, RenderBox? child})
  RenderAnimatedOpacity$Mate({
    /// optionalParameters: {required Animation<double> opacity} , defaultValue:none
    required Animation<double> opacity,

    /// optionalParameters: {bool alwaysIncludeSemantics = false} , defaultValue:Literal
    bool alwaysIncludeSemantics = false,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          opacity: opacity,
          alwaysIncludeSemantics: alwaysIncludeSemantics,
          child: child,
        ) {
    mateBuilder = (p) => RenderAnimatedOpacity$Mate(
          opacity: p.get('opacity').build(),
          alwaysIncludeSemantics: p.get('alwaysIncludeSemantics').build(),
          child: p.get('child').build(),
        );
    mateDeclare('opacity', opacity);
    mateDeclare('alwaysIncludeSemantics', alwaysIncludeSemantics);
    mateDeclare('child', child);
  }
}

/// class RenderShaderMask extends RenderProxyBox
class RenderShaderMask$Mate extends RenderShaderMask with Mate {
  /// RenderShaderMask RenderShaderMask({RenderBox? child, required Shader Function(Rect) shaderCallback, BlendMode blendMode = BlendMode.modulate})
  RenderShaderMask$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {required Shader Function(Rect) shaderCallback} , defaultValue:none
    required ShaderCallback shaderCallback,

    /// optionalParameters: {BlendMode blendMode = BlendMode.modulate} , defaultValue:unprocessed
    required BlendMode blendMode,
  }) : super(
          child: child,
          shaderCallback: shaderCallback,
          blendMode: blendMode,
        ) {
    mateBuilder = (p) => RenderShaderMask$Mate(
          child: p.get('child').build(),
          shaderCallback: p.get('shaderCallback').build(),
          blendMode: p.get('blendMode').build(),
        );
    mateDeclare('child', child);
    mateDeclare('shaderCallback', shaderCallback);
    mateDeclare('blendMode', blendMode);
  }
}

/// class RenderBackdropFilter extends RenderProxyBox
class RenderBackdropFilter$Mate extends RenderBackdropFilter with Mate {
  /// RenderBackdropFilter RenderBackdropFilter({RenderBox? child, required ImageFilter filter, BlendMode blendMode = BlendMode.srcOver})
  RenderBackdropFilter$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {required ImageFilter filter} , defaultValue:none
    required ImageFilter filter,

    /// optionalParameters: {BlendMode blendMode = BlendMode.srcOver} , defaultValue:unprocessed
    required BlendMode blendMode,
  }) : super(
          child: child,
          filter: filter,
          blendMode: blendMode,
        ) {
    mateBuilder = (p) => RenderBackdropFilter$Mate(
          child: p.get('child').build(),
          filter: p.get('filter').build(),
          blendMode: p.get('blendMode').build(),
        );
    mateDeclare('child', child);
    mateDeclare('filter', filter);
    mateDeclare('blendMode', blendMode);
  }
}

/// class ShapeBorderClipper extends CustomClipper<Path>
class ShapeBorderClipper$Mate extends ShapeBorderClipper with Mate {
  /// ShapeBorderClipper ShapeBorderClipper({required ShapeBorder shape, TextDirection? textDirection})
  ShapeBorderClipper$Mate({
    /// optionalParameters: {required ShapeBorder shape} , defaultValue:none
    required ShapeBorder shape,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,
  }) : super(
          shape: shape,
          textDirection: textDirection,
        ) {
    mateBuilder = (p) => ShapeBorderClipper$Mate(
          shape: p.get('shape').build(),
          textDirection: p.get('textDirection').build(),
        );
    mateDeclare('shape', shape);
    mateDeclare('textDirection', textDirection);
  }
}

/// class RenderClipRect extends _RenderCustomClip<Rect>
class RenderClipRect$Mate extends RenderClipRect with Mate {
  /// RenderClipRect RenderClipRect({RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipRect$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , defaultValue:none
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , defaultValue:is!ConstVariableElement
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateBuilder = (p) => RenderClipRect$Mate(
          child: p.get('child').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateDeclare('child', child);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
  }
}

/// class RenderClipRRect extends _RenderCustomClip<RRect>
class RenderClipRRect$Mate extends RenderClipRRect with Mate {
  /// RenderClipRRect RenderClipRRect({RenderBox? child, BorderRadiusGeometry borderRadius = BorderRadius.zero, CustomClipper<RRect>? clipper, Clip clipBehavior = Clip.antiAlias, TextDirection? textDirection})
  RenderClipRRect$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {BorderRadiusGeometry borderRadius = BorderRadius.zero} , defaultValue:unprocessed
    required BorderRadiusGeometry borderRadius,

    /// optionalParameters: {CustomClipper<RRect>? clipper} , defaultValue:none
    CustomClipper<RRect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , defaultValue:is!ConstVariableElement
    required Clip clipBehavior,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,
  }) : super(
          child: child,
          borderRadius: borderRadius,
          clipper: clipper,
          clipBehavior: clipBehavior,
          textDirection: textDirection,
        ) {
    mateBuilder = (p) => RenderClipRRect$Mate(
          child: p.get('child').build(),
          borderRadius: p.get('borderRadius').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          textDirection: p.get('textDirection').build(),
        );
    mateDeclare('child', child);
    mateDeclare('borderRadius', borderRadius);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('textDirection', textDirection);
  }
}

/// class RenderClipOval extends _RenderCustomClip<Rect>
class RenderClipOval$Mate extends RenderClipOval with Mate {
  /// RenderClipOval RenderClipOval({RenderBox? child, CustomClipper<Rect>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipOval$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Rect>? clipper} , defaultValue:none
    CustomClipper<Rect>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , defaultValue:is!ConstVariableElement
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateBuilder = (p) => RenderClipOval$Mate(
          child: p.get('child').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateDeclare('child', child);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
  }
}

/// class RenderClipPath extends _RenderCustomClip<Path>
class RenderClipPath$Mate extends RenderClipPath with Mate {
  /// RenderClipPath RenderClipPath({RenderBox? child, CustomClipper<Path>? clipper, Clip clipBehavior = Clip.antiAlias})
  RenderClipPath$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {CustomClipper<Path>? clipper} , defaultValue:none
    CustomClipper<Path>? clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.antiAlias} , defaultValue:is!ConstVariableElement
    required Clip clipBehavior,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
        ) {
    mateBuilder = (p) => RenderClipPath$Mate(
          child: p.get('child').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateDeclare('child', child);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
  }
}

/// class RenderPhysicalModel extends _RenderPhysicalModelBase<RRect>
class RenderPhysicalModel$Mate extends RenderPhysicalModel with Mate {
  /// RenderPhysicalModel RenderPhysicalModel({RenderBox? child, BoxShape shape = BoxShape.rectangle, Clip clipBehavior = Clip.none, BorderRadius? borderRadius, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)})
  RenderPhysicalModel$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {BoxShape shape = BoxShape.rectangle} , defaultValue:unprocessed
    required BoxShape shape,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:is!ConstVariableElement
    required Clip clipBehavior,

    /// optionalParameters: {BorderRadius? borderRadius} , defaultValue:none
    BorderRadius? borderRadius,

    /// optionalParameters: {double elevation = 0.0} , defaultValue:Literal
    double elevation = 0.0,

    /// optionalParameters: {required Color color} , defaultValue:none
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , defaultValue:none
    required Color shadowColor,
  }) : super(
          child: child,
          shape: shape,
          clipBehavior: clipBehavior,
          borderRadius: borderRadius,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
        ) {
    mateBuilder = (p) => RenderPhysicalModel$Mate(
          child: p.get('child').build(),
          shape: p.get('shape').build(),
          clipBehavior: p.get('clipBehavior').build(),
          borderRadius: p.get('borderRadius').build(),
          elevation: p.get('elevation').build(),
          color: p.get('color').build(),
          shadowColor: p.get('shadowColor').build(),
        );
    mateDeclare('child', child);
    mateDeclare('shape', shape);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('borderRadius', borderRadius);
    mateDeclare('elevation', elevation);
    mateDeclare('color', color);
    mateDeclare('shadowColor', shadowColor);
  }
}

/// class RenderPhysicalShape extends _RenderPhysicalModelBase<Path>
class RenderPhysicalShape$Mate extends RenderPhysicalShape with Mate {
  /// RenderPhysicalShape RenderPhysicalShape({RenderBox? child, required CustomClipper<Path> clipper, Clip clipBehavior = Clip.none, double elevation = 0.0, required Color color, Color shadowColor = const Color(0xFF000000)})
  RenderPhysicalShape$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {required CustomClipper<Path> clipper} , defaultValue:none
    required CustomClipper<Path> clipper,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:is!ConstVariableElement
    required Clip clipBehavior,

    /// optionalParameters: {double elevation = 0.0} , defaultValue:Literal
    double elevation = 0.0,

    /// optionalParameters: {required Color color} , defaultValue:none
    required Color color,

    /// optionalParameters: {Color shadowColor = const Color(0xFF000000)} , defaultValue:none
    required Color shadowColor,
  }) : super(
          child: child,
          clipper: clipper,
          clipBehavior: clipBehavior,
          elevation: elevation,
          color: color,
          shadowColor: shadowColor,
        ) {
    mateBuilder = (p) => RenderPhysicalShape$Mate(
          child: p.get('child').build(),
          clipper: p.get('clipper').build(),
          clipBehavior: p.get('clipBehavior').build(),
          elevation: p.get('elevation').build(),
          color: p.get('color').build(),
          shadowColor: p.get('shadowColor').build(),
        );
    mateDeclare('child', child);
    mateDeclare('clipper', clipper);
    mateDeclare('clipBehavior', clipBehavior);
    mateDeclare('elevation', elevation);
    mateDeclare('color', color);
    mateDeclare('shadowColor', shadowColor);
  }
}

/// class RenderDecoratedBox extends RenderProxyBox
class RenderDecoratedBox$Mate extends RenderDecoratedBox with Mate {
  /// RenderDecoratedBox RenderDecoratedBox({required Decoration decoration, DecorationPosition position = DecorationPosition.background, ImageConfiguration configuration = ImageConfiguration.empty, RenderBox? child})
  RenderDecoratedBox$Mate({
    /// optionalParameters: {required Decoration decoration} , defaultValue:none
    required Decoration decoration,

    /// optionalParameters: {DecorationPosition position = DecorationPosition.background} , defaultValue:unprocessed
    required DecorationPosition position,

    /// optionalParameters: {ImageConfiguration configuration = ImageConfiguration.empty} , defaultValue:unprocessed
    required ImageConfiguration configuration,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          decoration: decoration,
          position: position,
          configuration: configuration,
          child: child,
        ) {
    mateBuilder = (p) => RenderDecoratedBox$Mate(
          decoration: p.get('decoration').build(),
          position: p.get('position').build(),
          configuration: p.get('configuration').build(),
          child: p.get('child').build(),
        );
    mateDeclare('decoration', decoration);
    mateDeclare('position', position);
    mateDeclare('configuration', configuration);
    mateDeclare('child', child);
  }
}

/// class RenderTransform extends RenderProxyBox
class RenderTransform$Mate extends RenderTransform with Mate {
  /// RenderTransform RenderTransform({required Matrix4 transform, Offset? origin, AlignmentGeometry? alignment, TextDirection? textDirection, bool transformHitTests = true, FilterQuality? filterQuality, RenderBox? child})
  RenderTransform$Mate({
    /// optionalParameters: {required Matrix4 transform} , defaultValue:none
    required Matrix4 transform,

    /// optionalParameters: {Offset? origin} , defaultValue:none
    Offset? origin,

    /// optionalParameters: {AlignmentGeometry? alignment} , defaultValue:none
    AlignmentGeometry? alignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {FilterQuality? filterQuality} , defaultValue:none
    FilterQuality? filterQuality,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          transform: transform,
          origin: origin,
          alignment: alignment,
          textDirection: textDirection,
          transformHitTests: transformHitTests,
          filterQuality: filterQuality,
          child: child,
        ) {
    mateBuilder = (p) => RenderTransform$Mate(
          transform: p.get('transform').build(),
          origin: p.get('origin').build(),
          alignment: p.get('alignment').build(),
          textDirection: p.get('textDirection').build(),
          transformHitTests: p.get('transformHitTests').build(),
          filterQuality: p.get('filterQuality').build(),
          child: p.get('child').build(),
        );
    mateDeclare('transform', transform);
    mateDeclare('origin', origin);
    mateDeclare('alignment', alignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('filterQuality', filterQuality);
    mateDeclare('child', child);
  }
}

/// class RenderFittedBox extends RenderProxyBox
class RenderFittedBox$Mate extends RenderFittedBox with Mate {
  /// RenderFittedBox RenderFittedBox({BoxFit fit = BoxFit.contain, AlignmentGeometry alignment = Alignment.center, TextDirection? textDirection, RenderBox? child, Clip clipBehavior = Clip.none})
  RenderFittedBox$Mate({
    /// optionalParameters: {BoxFit fit = BoxFit.contain} , defaultValue:unprocessed
    required BoxFit fit,

    /// optionalParameters: {AlignmentGeometry alignment = Alignment.center} , defaultValue:unprocessed
    required AlignmentGeometry alignment,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {Clip clipBehavior = Clip.none} , defaultValue:unprocessed
    required Clip clipBehavior,
  }) : super(
          fit: fit,
          alignment: alignment,
          textDirection: textDirection,
          child: child,
          clipBehavior: clipBehavior,
        ) {
    mateBuilder = (p) => RenderFittedBox$Mate(
          fit: p.get('fit').build(),
          alignment: p.get('alignment').build(),
          textDirection: p.get('textDirection').build(),
          child: p.get('child').build(),
          clipBehavior: p.get('clipBehavior').build(),
        );
    mateDeclare('fit', fit);
    mateDeclare('alignment', alignment);
    mateDeclare('textDirection', textDirection);
    mateDeclare('child', child);
    mateDeclare('clipBehavior', clipBehavior);
  }
}

/// class RenderFractionalTranslation extends RenderProxyBox
class RenderFractionalTranslation$Mate extends RenderFractionalTranslation with Mate {
  /// RenderFractionalTranslation RenderFractionalTranslation({required Offset translation, bool transformHitTests = true, RenderBox? child})
  RenderFractionalTranslation$Mate({
    /// optionalParameters: {required Offset translation} , defaultValue:none
    required Offset translation,

    /// optionalParameters: {bool transformHitTests = true} , defaultValue:Literal
    bool transformHitTests = true,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          translation: translation,
          transformHitTests: transformHitTests,
          child: child,
        ) {
    mateBuilder = (p) => RenderFractionalTranslation$Mate(
          translation: p.get('translation').build(),
          transformHitTests: p.get('transformHitTests').build(),
          child: p.get('child').build(),
        );
    mateDeclare('translation', translation);
    mateDeclare('transformHitTests', transformHitTests);
    mateDeclare('child', child);
  }
}

/// class RenderPointerListener extends RenderProxyBoxWithHitTestBehavior
class RenderPointerListener$Mate extends RenderPointerListener with Mate {
  /// RenderPointerListener RenderPointerListener({void Function(PointerDownEvent)? onPointerDown, void Function(PointerMoveEvent)? onPointerMove, void Function(PointerUpEvent)? onPointerUp, void Function(PointerHoverEvent)? onPointerHover, void Function(PointerCancelEvent)? onPointerCancel, void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart, void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate, void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd, void Function(PointerSignalEvent)? onPointerSignal, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child})
  RenderPointerListener$Mate({
    /// optionalParameters: {void Function(PointerDownEvent)? onPointerDown} , defaultValue:none
    PointerDownEventListener? onPointerDown,

    /// optionalParameters: {void Function(PointerMoveEvent)? onPointerMove} , defaultValue:none
    PointerMoveEventListener? onPointerMove,

    /// optionalParameters: {void Function(PointerUpEvent)? onPointerUp} , defaultValue:none
    PointerUpEventListener? onPointerUp,

    /// optionalParameters: {void Function(PointerHoverEvent)? onPointerHover} , defaultValue:none
    PointerHoverEventListener? onPointerHover,

    /// optionalParameters: {void Function(PointerCancelEvent)? onPointerCancel} , defaultValue:none
    PointerCancelEventListener? onPointerCancel,

    /// optionalParameters: {void Function(PointerPanZoomStartEvent)? onPointerPanZoomStart} , defaultValue:none
    PointerPanZoomStartEventListener? onPointerPanZoomStart,

    /// optionalParameters: {void Function(PointerPanZoomUpdateEvent)? onPointerPanZoomUpdate} , defaultValue:none
    PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate,

    /// optionalParameters: {void Function(PointerPanZoomEndEvent)? onPointerPanZoomEnd} , defaultValue:none
    PointerPanZoomEndEventListener? onPointerPanZoomEnd,

    /// optionalParameters: {void Function(PointerSignalEvent)? onPointerSignal} , defaultValue:none
    PointerSignalEventListener? onPointerSignal,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , defaultValue:unprocessed
    required HitTestBehavior behavior,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          onPointerDown: onPointerDown,
          onPointerMove: onPointerMove,
          onPointerUp: onPointerUp,
          onPointerHover: onPointerHover,
          onPointerCancel: onPointerCancel,
          onPointerPanZoomStart: onPointerPanZoomStart,
          onPointerPanZoomUpdate: onPointerPanZoomUpdate,
          onPointerPanZoomEnd: onPointerPanZoomEnd,
          onPointerSignal: onPointerSignal,
          behavior: behavior,
          child: child,
        ) {
    mateBuilder = (p) => RenderPointerListener$Mate(
          onPointerDown: p.get('onPointerDown').build(),
          onPointerMove: p.get('onPointerMove').build(),
          onPointerUp: p.get('onPointerUp').build(),
          onPointerHover: p.get('onPointerHover').build(),
          onPointerCancel: p.get('onPointerCancel').build(),
          onPointerPanZoomStart: p.get('onPointerPanZoomStart').build(),
          onPointerPanZoomUpdate: p.get('onPointerPanZoomUpdate').build(),
          onPointerPanZoomEnd: p.get('onPointerPanZoomEnd').build(),
          onPointerSignal: p.get('onPointerSignal').build(),
          behavior: p.get('behavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('onPointerDown', onPointerDown);
    mateDeclare('onPointerMove', onPointerMove);
    mateDeclare('onPointerUp', onPointerUp);
    mateDeclare('onPointerHover', onPointerHover);
    mateDeclare('onPointerCancel', onPointerCancel);
    mateDeclare('onPointerPanZoomStart', onPointerPanZoomStart);
    mateDeclare('onPointerPanZoomUpdate', onPointerPanZoomUpdate);
    mateDeclare('onPointerPanZoomEnd', onPointerPanZoomEnd);
    mateDeclare('onPointerSignal', onPointerSignal);
    mateDeclare('behavior', behavior);
    mateDeclare('child', child);
  }
}

/// class RenderMouseRegion extends RenderProxyBoxWithHitTestBehavior implements MouseTrackerAnnotation
class RenderMouseRegion$Mate extends RenderMouseRegion with Mate {
  /// RenderMouseRegion RenderMouseRegion({void Function(PointerEnterEvent)? onEnter, void Function(PointerHoverEvent)? onHover, void Function(PointerExitEvent)? onExit, MouseCursor cursor = MouseCursor.defer, bool validForMouseTracker = true, bool opaque = true, RenderBox? child, HitTestBehavior? hitTestBehavior = HitTestBehavior.opaque})
  RenderMouseRegion$Mate({
    /// optionalParameters: {void Function(PointerEnterEvent)? onEnter} , defaultValue:none
    PointerEnterEventListener? onEnter,

    /// optionalParameters: {void Function(PointerHoverEvent)? onHover} , defaultValue:none
    PointerHoverEventListener? onHover,

    /// optionalParameters: {void Function(PointerExitEvent)? onExit} , defaultValue:none
    PointerExitEventListener? onExit,

    /// optionalParameters: {MouseCursor cursor = MouseCursor.defer} , defaultValue:unprocessed
    required MouseCursor cursor,

    /// optionalParameters: {bool validForMouseTracker = true} , defaultValue:Literal
    bool validForMouseTracker = true,

    /// optionalParameters: {bool opaque = true} , defaultValue:Literal
    bool opaque = true,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {HitTestBehavior? hitTestBehavior = HitTestBehavior.opaque} , defaultValue:unprocessed
    HitTestBehavior? hitTestBehavior,
  }) : super(
          onEnter: onEnter,
          onHover: onHover,
          onExit: onExit,
          cursor: cursor,
          validForMouseTracker: validForMouseTracker,
          opaque: opaque,
          child: child,
          hitTestBehavior: hitTestBehavior,
        ) {
    mateBuilder = (p) => RenderMouseRegion$Mate(
          onEnter: p.get('onEnter').build(),
          onHover: p.get('onHover').build(),
          onExit: p.get('onExit').build(),
          cursor: p.get('cursor').build(),
          validForMouseTracker: p.get('validForMouseTracker').build(),
          opaque: p.get('opaque').build(),
          child: p.get('child').build(),
          hitTestBehavior: p.get('hitTestBehavior').build(),
        );
    mateDeclare('onEnter', onEnter);
    mateDeclare('onHover', onHover);
    mateDeclare('onExit', onExit);
    mateDeclare('cursor', cursor);
    mateDeclare('validForMouseTracker', validForMouseTracker);
    mateDeclare('opaque', opaque);
    mateDeclare('child', child);
    mateDeclare('hitTestBehavior', hitTestBehavior);
  }
}

/// class RenderRepaintBoundary extends RenderProxyBox
class RenderRepaintBoundary$Mate extends RenderRepaintBoundary with Mate {
  /// RenderRepaintBoundary RenderRepaintBoundary({RenderBox? child})
  RenderRepaintBoundary$Mate(
      {
      /// optionalParameters: {RenderBox? child} , defaultValue:none
      RenderBox? child})
      : super(child: child) {
    mateBuilder = (p) => RenderRepaintBoundary$Mate(child: p.get('child').build());
    mateDeclare('child', child);
  }
}

/// class RenderIgnorePointer extends RenderProxyBox
class RenderIgnorePointer$Mate extends RenderIgnorePointer with Mate {
  /// RenderIgnorePointer RenderIgnorePointer({RenderBox? child, bool ignoring = true, bool? ignoringSemantics})
  RenderIgnorePointer$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {bool ignoring = true} , defaultValue:Literal
    bool ignoring = true,

    /// optionalParameters: {bool? ignoringSemantics} , defaultValue:none
    bool? ignoringSemantics,
  }) : super(
          child: child,
          ignoring: ignoring,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateBuilder = (p) => RenderIgnorePointer$Mate(
          child: p.get('child').build(),
          ignoring: p.get('ignoring').build(),
          ignoringSemantics: p.get('ignoringSemantics').build(),
        );
    mateDeclare('child', child);
    mateDeclare('ignoring', ignoring);
    mateDeclare('ignoringSemantics', ignoringSemantics);
  }
}

/// class RenderOffstage extends RenderProxyBox
class RenderOffstage$Mate extends RenderOffstage with Mate {
  /// RenderOffstage RenderOffstage({bool offstage = true, RenderBox? child})
  RenderOffstage$Mate({
    /// optionalParameters: {bool offstage = true} , defaultValue:Literal
    bool offstage = true,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          offstage: offstage,
          child: child,
        ) {
    mateBuilder = (p) => RenderOffstage$Mate(
          offstage: p.get('offstage').build(),
          child: p.get('child').build(),
        );
    mateDeclare('offstage', offstage);
    mateDeclare('child', child);
  }
}

/// class RenderAbsorbPointer extends RenderProxyBox
class RenderAbsorbPointer$Mate extends RenderAbsorbPointer with Mate {
  /// RenderAbsorbPointer RenderAbsorbPointer({RenderBox? child, bool absorbing = true, bool? ignoringSemantics})
  RenderAbsorbPointer$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {bool absorbing = true} , defaultValue:Literal
    bool absorbing = true,

    /// optionalParameters: {bool? ignoringSemantics} , defaultValue:none
    bool? ignoringSemantics,
  }) : super(
          child: child,
          absorbing: absorbing,
          ignoringSemantics: ignoringSemantics,
        ) {
    mateBuilder = (p) => RenderAbsorbPointer$Mate(
          child: p.get('child').build(),
          absorbing: p.get('absorbing').build(),
          ignoringSemantics: p.get('ignoringSemantics').build(),
        );
    mateDeclare('child', child);
    mateDeclare('absorbing', absorbing);
    mateDeclare('ignoringSemantics', ignoringSemantics);
  }
}

/// class RenderMetaData extends RenderProxyBoxWithHitTestBehavior
class RenderMetaData$Mate extends RenderMetaData with Mate {
  /// RenderMetaData RenderMetaData({dynamic metaData, HitTestBehavior behavior = HitTestBehavior.deferToChild, RenderBox? child})
  RenderMetaData$Mate({
    /// optionalParameters: {dynamic metaData} , defaultValue:none
    dynamic metaData,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , defaultValue:unprocessed
    required HitTestBehavior behavior,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          metaData: metaData,
          behavior: behavior,
          child: child,
        ) {
    mateBuilder = (p) => RenderMetaData$Mate(
          metaData: p.get('metaData').build(),
          behavior: p.get('behavior').build(),
          child: p.get('child').build(),
        );
    mateDeclare('metaData', metaData);
    mateDeclare('behavior', behavior);
    mateDeclare('child', child);
  }
}

/// class RenderSemanticsGestureHandler extends RenderProxyBoxWithHitTestBehavior
class RenderSemanticsGestureHandler$Mate extends RenderSemanticsGestureHandler with Mate {
  /// RenderSemanticsGestureHandler RenderSemanticsGestureHandler({RenderBox? child, void Function()? onTap, void Function()? onLongPress, void Function(DragUpdateDetails)? onHorizontalDragUpdate, void Function(DragUpdateDetails)? onVerticalDragUpdate, double scrollFactor = 0.8, HitTestBehavior behavior = HitTestBehavior.deferToChild})
  RenderSemanticsGestureHandler$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {void Function()? onTap} , defaultValue:none
    GestureTapCallback? onTap,

    /// optionalParameters: {void Function()? onLongPress} , defaultValue:none
    GestureLongPressCallback? onLongPress,

    /// optionalParameters: {void Function(DragUpdateDetails)? onHorizontalDragUpdate} , defaultValue:none
    GestureDragUpdateCallback? onHorizontalDragUpdate,

    /// optionalParameters: {void Function(DragUpdateDetails)? onVerticalDragUpdate} , defaultValue:none
    GestureDragUpdateCallback? onVerticalDragUpdate,

    /// optionalParameters: {double scrollFactor = 0.8} , defaultValue:Literal
    double scrollFactor = 0.8,

    /// optionalParameters: {HitTestBehavior behavior = HitTestBehavior.deferToChild} , defaultValue:unprocessed
    required HitTestBehavior behavior,
  }) : super(
          child: child,
          onTap: onTap,
          onLongPress: onLongPress,
          onHorizontalDragUpdate: onHorizontalDragUpdate,
          onVerticalDragUpdate: onVerticalDragUpdate,
          scrollFactor: scrollFactor,
          behavior: behavior,
        ) {
    mateBuilder = (p) => RenderSemanticsGestureHandler$Mate(
          child: p.get('child').build(),
          onTap: p.get('onTap').build(),
          onLongPress: p.get('onLongPress').build(),
          onHorizontalDragUpdate: p.get('onHorizontalDragUpdate').build(),
          onVerticalDragUpdate: p.get('onVerticalDragUpdate').build(),
          scrollFactor: p.get('scrollFactor').build(),
          behavior: p.get('behavior').build(),
        );
    mateDeclare('child', child);
    mateDeclare('onTap', onTap);
    mateDeclare('onLongPress', onLongPress);
    mateDeclare('onHorizontalDragUpdate', onHorizontalDragUpdate);
    mateDeclare('onVerticalDragUpdate', onVerticalDragUpdate);
    mateDeclare('scrollFactor', scrollFactor);
    mateDeclare('behavior', behavior);
  }
}

/// class RenderSemanticsAnnotations extends RenderProxyBox
class RenderSemanticsAnnotations$Mate extends RenderSemanticsAnnotations with Mate {
  /// RenderSemanticsAnnotations RenderSemanticsAnnotations({RenderBox? child, required SemanticsProperties properties, bool container = false, bool explicitChildNodes = false, bool excludeSemantics = false, TextDirection? textDirection})
  RenderSemanticsAnnotations$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {required SemanticsProperties properties} , defaultValue:none
    required SemanticsProperties properties,

    /// optionalParameters: {bool container = false} , defaultValue:Literal
    bool container = false,

    /// optionalParameters: {bool explicitChildNodes = false} , defaultValue:Literal
    bool explicitChildNodes = false,

    /// optionalParameters: {bool excludeSemantics = false} , defaultValue:Literal
    bool excludeSemantics = false,

    /// optionalParameters: {TextDirection? textDirection} , defaultValue:none
    TextDirection? textDirection,
  }) : super(
          child: child,
          properties: properties,
          container: container,
          explicitChildNodes: explicitChildNodes,
          excludeSemantics: excludeSemantics,
          textDirection: textDirection,
        ) {
    mateBuilder = (p) => RenderSemanticsAnnotations$Mate(
          child: p.get('child').build(),
          properties: p.get('properties').build(),
          container: p.get('container').build(),
          explicitChildNodes: p.get('explicitChildNodes').build(),
          excludeSemantics: p.get('excludeSemantics').build(),
          textDirection: p.get('textDirection').build(),
        );
    mateDeclare('child', child);
    mateDeclare('properties', properties);
    mateDeclare('container', container);
    mateDeclare('explicitChildNodes', explicitChildNodes);
    mateDeclare('excludeSemantics', excludeSemantics);
    mateDeclare('textDirection', textDirection);
  }
}

/// class RenderBlockSemantics extends RenderProxyBox
class RenderBlockSemantics$Mate extends RenderBlockSemantics with Mate {
  /// RenderBlockSemantics RenderBlockSemantics({RenderBox? child, bool blocking = true})
  RenderBlockSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {bool blocking = true} , defaultValue:Literal
    bool blocking = true,
  }) : super(
          child: child,
          blocking: blocking,
        ) {
    mateBuilder = (p) => RenderBlockSemantics$Mate(
          child: p.get('child').build(),
          blocking: p.get('blocking').build(),
        );
    mateDeclare('child', child);
    mateDeclare('blocking', blocking);
  }
}

/// class RenderMergeSemantics extends RenderProxyBox
class RenderMergeSemantics$Mate extends RenderMergeSemantics with Mate {
  /// RenderMergeSemantics RenderMergeSemantics({RenderBox? child})
  RenderMergeSemantics$Mate(
      {
      /// optionalParameters: {RenderBox? child} , defaultValue:none
      RenderBox? child})
      : super(child: child) {
    mateBuilder = (p) => RenderMergeSemantics$Mate(child: p.get('child').build());
    mateDeclare('child', child);
  }
}

/// class RenderExcludeSemantics extends RenderProxyBox
class RenderExcludeSemantics$Mate extends RenderExcludeSemantics with Mate {
  /// RenderExcludeSemantics RenderExcludeSemantics({RenderBox? child, bool excluding = true})
  RenderExcludeSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {bool excluding = true} , defaultValue:Literal
    bool excluding = true,
  }) : super(
          child: child,
          excluding: excluding,
        ) {
    mateBuilder = (p) => RenderExcludeSemantics$Mate(
          child: p.get('child').build(),
          excluding: p.get('excluding').build(),
        );
    mateDeclare('child', child);
    mateDeclare('excluding', excluding);
  }
}

/// class RenderIndexedSemantics extends RenderProxyBox
class RenderIndexedSemantics$Mate extends RenderIndexedSemantics with Mate {
  /// RenderIndexedSemantics RenderIndexedSemantics({RenderBox? child, required int index})
  RenderIndexedSemantics$Mate({
    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,

    /// optionalParameters: {required int index} , defaultValue:none
    required int index,
  }) : super(
          child: child,
          index: index,
        ) {
    mateBuilder = (p) => RenderIndexedSemantics$Mate(
          child: p.get('child').build(),
          index: p.get('index').build(),
        );
    mateDeclare('child', child);
    mateDeclare('index', index);
  }
}

/// class RenderLeaderLayer extends RenderProxyBox
class RenderLeaderLayer$Mate extends RenderLeaderLayer with Mate {
  /// RenderLeaderLayer RenderLeaderLayer({required LayerLink link, RenderBox? child})
  RenderLeaderLayer$Mate({
    /// optionalParameters: {required LayerLink link} , defaultValue:none
    required LayerLink link,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          link: link,
          child: child,
        ) {
    mateBuilder = (p) => RenderLeaderLayer$Mate(
          link: p.get('link').build(),
          child: p.get('child').build(),
        );
    mateDeclare('link', link);
    mateDeclare('child', child);
  }
}

/// class RenderFollowerLayer extends RenderProxyBox
class RenderFollowerLayer$Mate extends RenderFollowerLayer with Mate {
  /// RenderFollowerLayer RenderFollowerLayer({required LayerLink link, bool showWhenUnlinked = true, Offset offset = Offset.zero, Alignment leaderAnchor = Alignment.topLeft, Alignment followerAnchor = Alignment.topLeft, RenderBox? child})
  RenderFollowerLayer$Mate({
    /// optionalParameters: {required LayerLink link} , defaultValue:none
    required LayerLink link,

    /// optionalParameters: {bool showWhenUnlinked = true} , defaultValue:Literal
    bool showWhenUnlinked = true,

    /// optionalParameters: {Offset offset = Offset.zero} , defaultValue:unprocessed
    required Offset offset,

    /// optionalParameters: {Alignment leaderAnchor = Alignment.topLeft} , defaultValue:unprocessed
    required Alignment leaderAnchor,

    /// optionalParameters: {Alignment followerAnchor = Alignment.topLeft} , defaultValue:unprocessed
    required Alignment followerAnchor,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          link: link,
          showWhenUnlinked: showWhenUnlinked,
          offset: offset,
          leaderAnchor: leaderAnchor,
          followerAnchor: followerAnchor,
          child: child,
        ) {
    mateBuilder = (p) => RenderFollowerLayer$Mate(
          link: p.get('link').build(),
          showWhenUnlinked: p.get('showWhenUnlinked').build(),
          offset: p.get('offset').build(),
          leaderAnchor: p.get('leaderAnchor').build(),
          followerAnchor: p.get('followerAnchor').build(),
          child: p.get('child').build(),
        );
    mateDeclare('link', link);
    mateDeclare('showWhenUnlinked', showWhenUnlinked);
    mateDeclare('offset', offset);
    mateDeclare('leaderAnchor', leaderAnchor);
    mateDeclare('followerAnchor', followerAnchor);
    mateDeclare('child', child);
  }
}

/// class RenderAnnotatedRegion<T extends Object> extends RenderProxyBox
class RenderAnnotatedRegion$Mate<T extends Object> extends RenderAnnotatedRegion<T> with Mate {
  /// RenderAnnotatedRegion<T> RenderAnnotatedRegion({required T value, required bool sized, RenderBox? child})
  RenderAnnotatedRegion$Mate({
    /// optionalParameters: {required T value} , defaultValue:none
    required T value,

    /// optionalParameters: {required bool sized} , defaultValue:none
    required bool sized,

    /// optionalParameters: {RenderBox? child} , defaultValue:none
    RenderBox? child,
  }) : super(
          value: value,
          sized: sized,
          child: child,
        ) {
    mateBuilder = (p) => RenderAnnotatedRegion$Mate<T>(
          value: p.get('value').build(),
          sized: p.get('sized').build(),
          child: p.get('child').build(),
        );
    mateDeclare('value', value);
    mateDeclare('sized', sized);
    mateDeclare('child', child);
  }
}
