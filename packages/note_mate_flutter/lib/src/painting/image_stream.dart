// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/painting/image_stream.dart';
import 'package:note/mate.dart';
import 'dart:ui';
import 'dart:core';
import 'dart:async';
import 'package:flutter/src/foundation/assertions.dart';

/// class ImageInfo
class ImageInfo$Mate extends ImageInfo with Mate {
  /// ImageInfo ImageInfo({required Image image, double scale = 1.0, String? debugLabel})
  ImageInfo$Mate({
    /// optionalParameters: {required Image image} , defaultValue:none
    required Image image,

    /// optionalParameters: {double scale = 1.0} , defaultValue:Literal
    double scale = 1.0,

    /// optionalParameters: {String? debugLabel} , defaultValue:none
    String? debugLabel,
  }) : super(
          image: image,
          scale: scale,
          debugLabel: debugLabel,
        ) {
    mateCreateName = 'ImageInfo';
    matePackageUrl = 'package:flutter/painting.dart';
    mateBuilder = (p) => ImageInfo$Mate(
          image: p.get('image').build(),
          scale: p.get('scale').build(),
          debugLabel: p.get('debugLabel').build(),
        );
    mateUse('image', image, isNamed: true);
    mateUse('scale', scale, isNamed: true);
    mateUse('debugLabel', debugLabel, isNamed: true);
  }
}

/// class ImageStreamListener
class ImageStreamListener$Mate extends ImageStreamListener with Mate {
  /// ImageStreamListener ImageStreamListener(void Function(ImageInfo, bool) onImage, {void Function(ImageChunkEvent)? onChunk, void Function(Object, StackTrace?)? onError})
  ImageStreamListener$Mate(
    /// requiredParameters: void Function(ImageInfo, bool) onImage
    ImageListener onImage, {
    /// optionalParameters: {void Function(ImageChunkEvent)? onChunk} , defaultValue:none
    ImageChunkListener? onChunk,

    /// optionalParameters: {void Function(Object, StackTrace?)? onError} , defaultValue:none
    ImageErrorListener? onError,
  }) : super(
          onImage,
          onChunk: onChunk,
          onError: onError,
        ) {
    mateCreateName = 'ImageStreamListener';
    matePackageUrl = 'package:flutter/painting.dart';
    mateBuilder = (p) => ImageStreamListener$Mate(
          p.get('onImage').value,
          onChunk: p.get('onChunk').build(),
          onError: p.get('onError').build(),
        );
    mateUse('onImage', onImage, isNamed: false);
    mateUse('onChunk', onChunk, isNamed: true);
    mateUse('onError', onError, isNamed: true);
  }
}

/// class ImageChunkEvent with Diagnosticable
class ImageChunkEvent$Mate extends ImageChunkEvent with Mate {
  /// ImageChunkEvent ImageChunkEvent({required int cumulativeBytesLoaded, required int? expectedTotalBytes})
  ImageChunkEvent$Mate({
    /// optionalParameters: {required int cumulativeBytesLoaded} , defaultValue:none
    required int cumulativeBytesLoaded,

    /// optionalParameters: {required int? expectedTotalBytes} , defaultValue:none
    required int? expectedTotalBytes,
  }) : super(
          cumulativeBytesLoaded: cumulativeBytesLoaded,
          expectedTotalBytes: expectedTotalBytes,
        ) {
    mateCreateName = 'ImageChunkEvent';
    matePackageUrl = 'package:flutter/painting.dart';
    mateBuilder = (p) => ImageChunkEvent$Mate(
          cumulativeBytesLoaded: p.get('cumulativeBytesLoaded').build(),
          expectedTotalBytes: p.get('expectedTotalBytes').build(),
        );
    mateUse('cumulativeBytesLoaded', cumulativeBytesLoaded, isNamed: true);
    mateUse('expectedTotalBytes', expectedTotalBytes, isNamed: true);
  }
}

/// class OneFrameImageStreamCompleter extends ImageStreamCompleter
class OneFrameImageStreamCompleter$Mate extends OneFrameImageStreamCompleter with Mate {
  /// OneFrameImageStreamCompleter OneFrameImageStreamCompleter(Future<ImageInfo> image, {Iterable<DiagnosticsNode> Function()? informationCollector})
  OneFrameImageStreamCompleter$Mate(
    /// requiredParameters: Future<ImageInfo> image
    Future<ImageInfo> image, {
    /// optionalParameters: {Iterable<DiagnosticsNode> Function()? informationCollector} , defaultValue:none
    InformationCollector? informationCollector,
  }) : super(
          image,
          informationCollector: informationCollector,
        ) {
    mateCreateName = 'OneFrameImageStreamCompleter';
    matePackageUrl = 'package:flutter/painting.dart';
    mateBuilder = (p) => OneFrameImageStreamCompleter$Mate(
          p.get('image').value,
          informationCollector: p.get('informationCollector').build(),
        );
    mateUse('image', image, isNamed: false);
    mateUse('informationCollector', informationCollector, isNamed: true);
  }
}

/// class MultiFrameImageStreamCompleter extends ImageStreamCompleter
class MultiFrameImageStreamCompleter$Mate extends MultiFrameImageStreamCompleter with Mate {
  /// MultiFrameImageStreamCompleter MultiFrameImageStreamCompleter({required Future<Codec> codec, required double scale, String? debugLabel, Stream<ImageChunkEvent>? chunkEvents, Iterable<DiagnosticsNode> Function()? informationCollector})
  MultiFrameImageStreamCompleter$Mate({
    /// optionalParameters: {required Future<Codec> codec} , defaultValue:none
    required Future<Codec> codec,

    /// optionalParameters: {required double scale} , defaultValue:none
    required double scale,

    /// optionalParameters: {String? debugLabel} , defaultValue:none
    String? debugLabel,

    /// optionalParameters: {Stream<ImageChunkEvent>? chunkEvents} , defaultValue:none
    Stream<ImageChunkEvent>? chunkEvents,

    /// optionalParameters: {Iterable<DiagnosticsNode> Function()? informationCollector} , defaultValue:none
    InformationCollector? informationCollector,
  }) : super(
          codec: codec,
          scale: scale,
          debugLabel: debugLabel,
          chunkEvents: chunkEvents,
          informationCollector: informationCollector,
        ) {
    mateCreateName = 'MultiFrameImageStreamCompleter';
    matePackageUrl = 'package:flutter/painting.dart';
    mateBuilder = (p) => MultiFrameImageStreamCompleter$Mate(
          codec: p.get('codec').build(),
          scale: p.get('scale').build(),
          debugLabel: p.get('debugLabel').build(),
          chunkEvents: p.get('chunkEvents').build(),
          informationCollector: p.get('informationCollector').build(),
        );
    mateUse('codec', codec, isNamed: true);
    mateUse('scale', scale, isNamed: true);
    mateUse('debugLabel', debugLabel, isNamed: true);
    mateUse('chunkEvents', chunkEvents, isNamed: true);
    mateUse('informationCollector', informationCollector, isNamed: true);
  }
}
