import 'package:analyzer/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/dart/analysis/context_root.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/file_system/physical_file_system.dart';
import 'package:code_builder/code_builder.dart' as code;
import 'package:code_builder/code_builder.dart';

import 'package:dart_style/dart_style.dart';
import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:glob/glob.dart';
import 'package:glob/list_local_fs.dart';
import 'package:path/path.dart' as path;

import 'package:note/env.dart';

final _dartfmt = DartFormatter(pageWidth: 120);

main() async {
  Env env = Env();
  Glob glob = Glob("lib/**page.dart");
  FileSystem fs = const LocalFileSystem();

  final collection = AnalysisContextCollection(
    includedPaths: glob.listSync().map((e) => path.normalize(path.absolute(e.path))).toList(),
    sdkPath: env.sdkDir,
    resourceProvider: PhysicalResourceProvider.INSTANCE,
  );
  for (final context in collection.contexts) {
    ContextRoot root = context.contextRoot;
    log('---------------------context:  ${root.root.path} ----------------------- ');
    List<_Page> resolvedLibs = List.empty(growable: true);
    for (final filePath in root.analyzedFiles()) {
      var resolvedLib =
          await context.currentSession.getResolvedLibrary(filePath) as ResolvedLibraryResult;
      resolvedLibs.add(_Page(filePath, resolvedLib));
    }

    // 排序，顺序可以通过为目录名添加数字前缀来强行引导： 1.pagename
    resolvedLibs.sort((a, b) => a.lib.identifier.compareTo(b.lib.identifier));

    log('gen pages.g.dart start');
    genPages(resolvedLibs.map((e) => e.lib), fs);
    log('gen pages.g.dart ok');

    log('genPages Info start');
    for (var page in resolvedLibs) {
      page.genPageInfo(fs);
    }
    log('genPages Info ok');
  }
}

void genPages(Iterable<LibraryElement> libs, FileSystem fs) {
  code.Library libGen = code.Library((b) => b
    ..comments.add("Generated by gen_pages.dart, please don't edit!")
    ..comments.add("ignore_for_file: library_prefixes, non_constant_identifier_names")
    ..directives.add(code.Directive.import("package:note/page_core.dart"))
    ..directives.add(code.Directive.import("package:note_app/note_app.dart"))
    ..directives.addAll(libs.map(
        (lib) => code.Directive.import(lib.identifier, as: "${_flatLibPath(lib.identifier)}_")))
    ..body.add(Mixin((b) => b
      ..name = "PathsMixin"
      ..fields.addAll(libs.map((lib) {
        String flatPagePath = _flatLibPath(lib.identifier);
        String path =
            lib.identifier.replaceAll("package:note_app", "").replaceAll("/page.dart", "");
        path = path == "" ? "/" : path;
        return Field((b) => b
          ..name = flatPagePath
          ..modifier = FieldModifier.final$
          ..type = refer("Path", "package:note/page_core.dart")
          ..assignment = Code('put("$path", ${flatPagePath}_.page)'));
      })))));

  String toCode =
      '${libGen.accept(DartEmitter(allocator: Allocator.none, orderDirectives: true, useNullSafetySyntax: true))}';
  toCode = _dartfmt.format(toCode);
  fs.file("lib/pages.g.dart").writeAsStringSync(toCode);
}

class _Page {
  String path;
  ResolvedLibraryResult libResult;
  _Page(this.path, this.libResult);

  LibraryElement get lib => libResult.element;
  CompilationUnit get unit => compilationUnit.unit;
  ResolvedUnitResult get compilationUnit => libResult.unitWithPath(path)!;
  FunctionDeclaration? get buildFunction {
    var whereBuild =
        unit.declarations.whereType<FunctionDeclaration>().where((e) => "${e.name}" == "build");
    return whereBuild.isEmpty ? null : whereBuild.first;
  }

  void genPageInfo(FileSystem fs) {
    log('genPages Info ${lib.identifier}');
    if (path.contains("notebook")) {
      log("debug use ${path}");
    }
    var findBuild = buildFunction;
    if (findBuild == null) {
      log("unitResult ${lib.identifier} not found page [build] func");
      return;
    }
    var funcBody = findBuild.functionExpression.body;
    assert(funcBody is BlockFunctionBody,
        "build() func only support Block Function, but(${funcBody.runtimeType})");

    String libContent = fs.file(path).readAsStringSync();

    var block = (funcBody as BlockFunctionBody).block;

    for (var statement in block.statements) {
      log("statement runtimeType:${statement.runtimeType} - offset:${statement.offset} len:${statement.length} end:${statement.end}    file.len:${libContent.length} ,unit.len:${unit.length}  ");
      log("---${libContent.toString().safeSubstring(statement.offset, statement.offset + 20)}---");
    }
    for (var entity in block.childEntities) {
      log("entity runtimeType:${entity.runtimeType} offset:${entity.offset} : ${libContent.safeSubstring(entity.offset, entity.offset + 20)} ");
    }
  }
}

extension _StrExt on String {
  String safeSubstring(int start, [int? end]) {
    end ??= length;
    end = end <= length ? end : length;
    try {
      return substring(start, end);
    } catch (e) {
      throw Exception("$e, string $this");
    }
  }
}

/// 包名平整化：
/// package:note/pages/note/1.welcome/1.note-self/page.dart
/// --->
/// note$welcome$note_self
///
/// 规则：
/// - 去掉package:note前缀
/// - 去掉用来排序的数字前缀"1."
/// - '/'换成'$'
/// - 其他特殊字符换成'_'
String _flatLibPath(String packageName) {
  String result = packageName.replaceAll("package:note_app/", "");
  if (result == "page.dart") {
    return "root";
  }
  return result
      .replaceAll(RegExp("/page.dart\$"), "") // 后缀
// ignore: unnecessary_string_escapes
      .replaceAll(RegExp("/\\d+\."), "/") // 1.note-self -> note-self
      .replaceAll("/", "_")
      .replaceAll(".", "_")
      .replaceAll("-", "_")
      .replaceAll("@", "_");
}

log(Object? o) {
  // ignore: avoid_print
  print("${DateTime.now()} - $o");
}
