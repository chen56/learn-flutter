import 'dart:convert';

import 'package:analyzer/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/dart/analysis/context_root.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/ast/ast.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/file_system/physical_file_system.dart';
import 'package:code_builder/code_builder.dart' as code;
import 'package:code_builder/code_builder.dart';

import 'package:dart_style/dart_style.dart';
import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:glob/glob.dart';
import 'package:glob/list_local_fs.dart';
import 'package:path/path.dart' as path;

import 'package:note/env.dart';
import 'package:note/utils_core.dart';


main() async {
  Env env = Env();
  Glob glob = Glob("lib/**page.dart");
  FileSystem writeFS = const LocalFileSystem();

  final collection = AnalysisContextCollection(
    includedPaths: glob.listSync().map((e) => path.normalize(path.absolute(e.path))).toList(),
    sdkPath: env.sdkDir,
    resourceProvider: PhysicalResourceProvider.INSTANCE,
  );
  for (final context in collection.contexts) {
    ContextRoot root = context.contextRoot;
    log('---------------------context:  ${root.root.path} ----------------------- ');
    List<_Page> resolvedLibs = List.empty(growable: true);
    for (final filePath in root.analyzedFiles()) {
      var resolvedLib =
      await context.currentSession.getResolvedLibrary(filePath) as ResolvedLibraryResult;
      resolvedLibs.add(_Page(filePath, resolvedLib, writeFS));
    }

    // 排序，顺序可以通过为目录名添加数字前缀来强行引导： 1.pagename
    resolvedLibs.sort((a, b) => a.lib.identifier.compareTo(b.lib.identifier));

    log('genPages Info start');
    for (var page in resolvedLibs) {
      page.genPageInfoPackage(page.collectPageInfo());
    }
    log('genPages Info ok');

    log('gen pages.g.dart start');
    genPages(resolvedLibs.map((e) => e.lib), writeFS);
    log('gen pages.g.dart ok');
  }
}

void genPages(Iterable<LibraryElement> libs, FileSystem writeFS) {
  code.Library libGen = code.Library((b) =>
  b
    ..comments.add("Generated by gen_pages.dart, please don't edit!")
    ..comments.add("ignore_for_file: library_prefixes, non_constant_identifier_names")
    ..directives.add(code.Directive.import("package:note/page_core.dart"))
    ..directives.add(code.Directive.import("package:note_app/note_app.dart"))
    ..directives.addAll(libs.map(
            (lib) {
              var p = path.join(path.dirname(lib.identifier),"page.g.dart");
          return code.Directive.import(p, as: "${_flatLibPath(p)}_");
        }))
    ..body.add(Mixin((b) =>
    b
      ..name = "PathsMixin"
      ..fields.addAll(libs.map((lib) {
        String flatPagePath = _flatLibPath(lib.identifier);
        String path =
        lib.identifier.replaceAll("package:note_app", "").replaceAll("/page.dart", "");
        path = path == "" ? "/" : path;
        return Field((b) =>
        b
          ..name = flatPagePath
          ..modifier = FieldModifier.final$
          ..type = refer("Path", "package:note/page_core.dart")
          ..assignment = Code('put("$path", ${flatPagePath}_.noteInfo)'));
      })))));

  String toCode =
      '${libGen.accept(
      DartEmitter(allocator: Allocator.none, orderDirectives: true, useNullSafetySyntax: true))}';
  // toCode = _dartfmt.format(toCode);
  writeFS.file("lib/pages.g.dart").writeAsStringSync(toCode);
}

class _Page {
  String fullPath;
  ResolvedLibraryResult libResult;

  FileSystem writeFS;

  _Page(this.fullPath, this.libResult, this.writeFS);

  LibraryElement get lib => libResult.element;

  CompilationUnit get unit => compilationUnit.unit;

  ResolvedUnitResult get compilationUnit => libResult.unitWithPath(fullPath)!;

  FunctionDeclaration? get buildFunction {
    var whereBuild =
    unit.declarations.whereType<FunctionDeclaration>().where((e) => "${e.name}" == "build");
    return whereBuild.isEmpty ? null : whereBuild.first;
  }


  _NoteInfo collectPageInfo() {
    log('genPages Info ${lib.identifier}');

    String fileContent = compilationUnit.content;

    if (fullPath.contains("notebook")) {
      log("debug use $fullPath");
    }
    var findBuild = buildFunction;
    if (findBuild == null) {
      log(" ${lib.identifier} [build] func not found, so it is not a note");
      return (
        code: compilationUnit.content,
        header: (offset: 0, end: unit.end, cellStatements:[]),
        body:[],
        tail:(offset:0, end:0, cellStatements:[])
      );
    }
    var buildBody = findBuild.functionExpression.body;
    assert(buildBody is BlockFunctionBody,
    "build() func only support Block Function, but(${buildBody.runtimeType})");

    var buildBodyBlock = (buildBody as BlockFunctionBody).block;

    List<_CodeBlock> body = [];
    List<Statement> cellStatements = [];
    int offset = buildBodyBlock.offset +1;
    for (var st in buildBodyBlock.statements) {
      log("statement runtimeType:${st.runtimeType} - offset:${st
          .offset} len:${st.length} end:${st.end}    file.len:${fileContent
          .length} ,unit.len:${unit.length}  ");
      log("---${fileContent.toString().safeSubstring(st.offset, st.offset + 20)}---");
      if (isCellStatement(st)) {
        //上方代码块
        body.add((offset:offset, end:st.offset,cellStatements:cellStatements));
        cellStatements=[];
        //cell/markdown方法明确的代码块
        body.add((offset:st.offset, end:st.end,cellStatements:[st]));
        offset = st.end;
      }else{
        cellStatements.add(st);
      }
    }
    //最后补一个代码块
    body.add((offset:offset, end:buildBodyBlock.end - 1,cellStatements:cellStatements));

    // for (var entity in buildBodyBlock.childEntities) {
    //   log("entity runtimeType:${entity.runtimeType} offset:${entity.offset} : ${fileContent
    //       .safeSubstring(entity.offset, entity.offset + 20)} ");
    // }

    return (
      code: compilationUnit.content,
      header: (offset: 0, end: findBuild.offset,cellStatements:[]),
      body:body,
      tail:(offset:findBuild.end, end:unit.end,cellStatements:[])
    );
  }

  bool isCellStatement(Statement statement) {
    if (statement is! ExpressionStatement) {
      return false;
    }
    var expression = statement.expression;
    if (expression is! MethodInvocation) {
      return false;
    }
    String? typeName = expression.target?.staticType!.getDisplayString(withNullability: true);
    if (typeName != "Pen") {
      return false;
    }
    var cellMethods = ["markdown", "md", "cell"];
    if (!cellMethods.contains(expression.methodName.name)) {
      return false;
    }
    return true;
  }

  /*
    import 'package:note/page_core.dart';
    // ignore: always_use_package_imports
    import 'page.dart';

    final noteInfo = NoteInfo(
      meta: page,
      source: NoteSource(
        header: CodeBlock(offset: 0, end: 20),
        body: [
          CodeBlock(offset: 100, end: 120),
          CodeBlock(offset: 100, end: 120),
        ],
        tail: CodeBlock(offset: 100, end: 120),
      ),
    );
  */
  void genPageInfoPackage(_NoteInfo source) {
    final encodedCode = base64.encode(utf8.encode(source.code));

    source.body.map((e) =>
        refer("CodeBlock").newInstance(
          [], {"offset": code.literalNum(e.offset),
          "end": code.literalNum(e.end),},));
    var body = source.body.map((e) =>
    """ /// ${e.cellStatements.map((e) => e.toString().replaceAll("\n", " ").safeSubstring(0,30))}
    CodeBlock(offset:${e.offset}, end:${e.end}, statementCount: ${e.cellStatements.length} ) """).join(",");
    Library lib = Library((b) =>
    b
      ..comments.addAll(["/// Generated by gen_maters.dart, please don't edit! "])
      ..body.add(
        code.Block((b) =>
        b
          ..statements.addAll([
            Code('''
    import 'package:note/page_core.dart';
    // ignore: always_use_package_imports
    import 'page.dart';

    final noteInfo = NoteInfo(
      meta: page,
      source: NoteSource(
        header: CodeBlock(offset:  ${source.header.offset}, end: ${source.header.end}, statementCount: ${source.header.cellStatements.length}),
        body: [ $body ],
        tail: CodeBlock(offset:  ${source.tail.offset}, end: ${source.tail.end}, statementCount: ${source.tail.cellStatements.length}),
        code: """$encodedCode"""
      ),
    ); '''),
          ])),
      ));

    var toFile = path.join(path.dirname(fullPath), "page.g.dart");
    log("genPageInfo toFile $toFile");
    DartEmitter emitter = DartEmitter(
      allocator: Allocator.none, orderDirectives: true, useNullSafetySyntax: true,);
    String writeContent = lib.accept(emitter).toString();
    var dartFormatter = DartFormatter(pageWidth: 120);
    writeContent = dartFormatter.format(writeContent);
    writeFS.directory(path.dirname(toFile)).createSync(recursive: true);
    writeFS.file(toFile).writeAsStringSync(writeContent);
  }


}

typedef _CodeBlock=({int offset, int end,List<Statement> cellStatements,});
typedef _NoteInfo=({
String code,
_CodeBlock header,
List<_CodeBlock> body,
_CodeBlock tail,
});

/// 包名平整化：
/// package:note/pages/note/1.welcome/1.note-self/page.dart
/// --->
/// note$welcome$note_self
///
/// 规则：
/// - 去掉package:note前缀
/// - 去掉用来排序的数字前缀"1."
/// - '/'换成'$'
/// - 其他特殊字符换成'_'
String _flatLibPath(String packageName) {
  String result = packageName.replaceAll("package:note_app/", "");
  result=path.dirname(result);

  if (result == "." ) {
    return "root";
  }
  return result
      // .replaceAll(RegExp("/page.dart\$"), "") // 后缀
      // .replaceAll(RegExp("/page.g.dart\$"), "") // 后缀
// ignore: unnecessary_string_escapes
      .replaceAll(RegExp("/\\d+\."), "/") // 1.note-self -> note-self
      .replaceAll("/", "_")
      .replaceAll(".", "_")
      .replaceAll("-", "_")
      .replaceAll("@", "_");
}

log(Object? o) {
  // ignore: avoid_print
  print("${DateTime.now()} - $o");
}
