import 'package:analyzer/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/file_system/physical_file_system.dart';
import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:file/file.dart';
import 'package:file/local.dart';
import 'package:flutter_test/flutter_test.dart';
import "package:path/path.dart" as path;
import 'package:note/env.dart';

// ref: ElementDisplayStringBuilder 代码生成
main() async {
  _log("## main");
  var env = Env();

  genAll(
    env: env,
    // 直接扫icons.dart会得到错误的字段类型dynamic
    // entryFile: env.flutterPackageAbstractPath("package:flutter/src/material/icons.dart"),
    entryFile: path.absolute("tools/gen_mate_icons_sample.dart"),
    // writeFS: MemoryFileSystem(),
    writeFS: const LocalFileSystem(),
    // libPath: 比如包package:flutter/material.dart 应提供的libPath: material.dart
    writeTo: (libPath) {
      return path.join("lib", libPath);
    },
    emitter: DartEmitter(
        allocator: Allocator.simplePrefixing(), useNullSafetySyntax: true),
    dartFormatter: DartFormatter(pageWidth: 120),
  );

  // make `flutter run xxx.dart` no error
  test("stub", () {});
}

Future<void> genAll({
  required Env env,
  required String entryFile, //入口lib的文件绝对路径
  required FileSystem writeFS,
  required String Function(String libPath) writeTo,
  required DartEmitter emitter,
  required DartFormatter dartFormatter, //void Function(LibraryBuilder) updates
}) async {
  _log("## resolve entry lib");
  final collection = AnalysisContextCollection(
    includedPaths: [entryFile],
    sdkPath: env.dartSdkDir,
    resourceProvider: PhysicalResourceProvider.INSTANCE,
  );
  var entryLib = (await collection.contexts.first.currentSession
          .getResolvedLibrary(entryFile) as ResolvedLibraryResult)
      .element;

  _log("## gen icon register:");
  _genIcons(
    writeFS: writeFS,
    writeTo: writeTo,
    entryLib: entryLib,
    emitter: emitter,
    dartFormatter: dartFormatter,
  );
  _log("## gen icon register ok!");
}

/*
import 'package:flutter/material.dart';
import 'package:note/mate_core.dart';

IconRegister registerIcon() {
  IconRegister result = IconRegister("Icons", "package:flutter/material.dart");
  result.register(Icons.add, "add");
  result.register(Icons.wifi, "wifi");
  return result;
}    */
_genIcons({
  required FileSystem writeFS,
  required String Function(String libPath) writeTo,
  required DartFormatter dartFormatter,
  required LibraryElement entryLib,
  required DartEmitter emitter,
}) {
  var clazz = entryLib.exportNamespace.definedNames["Icons"] as ClassElement;
  var statements = clazz.fields
      .where(
          (e) => e.type.element != null && e.type.element!.name == "IconData")
      .map((e) => refer("result.register").call(
            [
              refer("Icons", "package:flutter/material.dart").property(e.name),
              literalString("${e.name}")
            ],
          ).statement);

  Library lib = Library((b) => b
    ..comments.addAll(["/// Generated by gen_maters.dart, please don't edit! "])
    ..directives.add(Directive((b) => b
      ..type = DirectiveType.import
      ..url = "package:note/mate_core.dart"))
    ..body.add(
      Block((b) => b
        ..statements.addAll([
          const Code("""
              IconRegister registerIcon() {
                IconRegister result = IconRegister("Icons", "package:flutter/material.dart");
          """),
          ...statements,
          const Code("""
                return result;
              }
          """),
        ])),
    ));

  var toFile = writeTo("mate_icons.g.dart");

  String writeContent = lib.accept(emitter).toString();
  writeContent = dartFormatter.format(writeContent);
  writeFS.directory(path.dirname(toFile)).createSync(recursive: true);
  writeFS.file(toFile).writeAsStringSync(writeContent);
}

_log(Object? o) {
  // ignore: avoid_print
  print("${DateTime.now()} - $o");
}
