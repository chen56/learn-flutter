// /// Generated by gen_maters.dart, please don't edit!

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:flutter/src/painting/image_stream.dart' as _i1;
import 'package:note/mate_core.dart' as _i2;
import 'dart:ui' as _i3;
import 'dart:async' as _i4;
import 'package:flutter/src/foundation/assertions.dart' as _i5;

/// class ImageInfo
class ImageInfo$Mate extends _i1.ImageInfo with _i2.Mate {
  /// ImageInfo ImageInfo({required Image image, double scale = 1.0, String? debugLabel})
  ImageInfo$Mate({
    /// optionalParameters: {required Image image} , default:none
    required super.image,

    /// optionalParameters: {double scale = 1.0} , default:processed=DoubleLiteralImpl
    super.scale,

    /// optionalParameters: {String? debugLabel} , default:none
    super.debugLabel,
  })  : mateParams = {
          'image': _i2.BuilderArg<_i3.Image>(
            name: 'image',
            init: image,
            isNamed: true,
          ),
          'scale': _i2.BuilderArg<double>(
            name: 'scale',
            init: scale,
            isNamed: true,
            defaultValue: 1.0,
          ),
          'debugLabel': _i2.BuilderArg<String?>(
            name: 'debugLabel',
            init: debugLabel,
            isNamed: true,
          ),
        },
        super() {
    mateBuilderName = 'ImageInfo';
    matePackageUrl = 'package:flutter/cupertino.dart';
    mateBuilder = (p) => ImageInfo$Mate(
          image: p.get('image').build(),
          scale: p.get('scale').build(),
          debugLabel: p.get('debugLabel').build(),
        );
  }

  @override
  final Map<String, _i2.BuilderArg> mateParams;
}

/// class ImageStreamListener
class ImageStreamListener$Mate extends _i1.ImageStreamListener with _i2.Mate {
  /// ImageStreamListener ImageStreamListener(void Function(ImageInfo, bool) onImage, {void Function(ImageChunkEvent)? onChunk, void Function(Object, StackTrace?)? onError})
  ImageStreamListener$Mate(
    /// requiredParameters: void Function(ImageInfo, bool) onImage
    super.onImage, {
    /// optionalParameters: {void Function(ImageChunkEvent)? onChunk} , default:none
    super.onChunk,

    /// optionalParameters: {void Function(Object, StackTrace?)? onError} , default:none
    super.onError,
  })  : mateParams = {
          'onImage': _i2.BuilderArg<_i1.ImageListener>(
            name: 'onImage',
            init: onImage,
            isNamed: false,
          ),
          'onChunk': _i2.BuilderArg<_i1.ImageChunkListener?>(
            name: 'onChunk',
            init: onChunk,
            isNamed: true,
          ),
          'onError': _i2.BuilderArg<_i1.ImageErrorListener?>(
            name: 'onError',
            init: onError,
            isNamed: true,
          ),
        },
        super() {
    mateBuilderName = 'ImageStreamListener';
    matePackageUrl = 'package:flutter/cupertino.dart';
    mateBuilder = (p) => ImageStreamListener$Mate(
          p.get('onImage').value,
          onChunk: p.get('onChunk').build(),
          onError: p.get('onError').build(),
        );
  }

  @override
  final Map<String, _i2.BuilderArg> mateParams;
}

/// class ImageChunkEvent with Diagnosticable
class ImageChunkEvent$Mate extends _i1.ImageChunkEvent with _i2.Mate {
  /// ImageChunkEvent ImageChunkEvent({required int cumulativeBytesLoaded, required int? expectedTotalBytes})
  ImageChunkEvent$Mate({
    /// optionalParameters: {required int cumulativeBytesLoaded} , default:none
    required super.cumulativeBytesLoaded,

    /// optionalParameters: {required int? expectedTotalBytes} , default:none
    required super.expectedTotalBytes,
  })  : mateParams = {
          'cumulativeBytesLoaded': _i2.BuilderArg<int>(
            name: 'cumulativeBytesLoaded',
            init: cumulativeBytesLoaded,
            isNamed: true,
          ),
          'expectedTotalBytes': _i2.BuilderArg<int?>(
            name: 'expectedTotalBytes',
            init: expectedTotalBytes,
            isNamed: true,
          ),
        },
        super() {
    mateBuilderName = 'ImageChunkEvent';
    matePackageUrl = 'package:flutter/cupertino.dart';
    mateBuilder = (p) => ImageChunkEvent$Mate(
          cumulativeBytesLoaded: p.get('cumulativeBytesLoaded').build(),
          expectedTotalBytes: p.get('expectedTotalBytes').build(),
        );
  }

  @override
  final Map<String, _i2.BuilderArg> mateParams;
}

/// class OneFrameImageStreamCompleter extends ImageStreamCompleter
class OneFrameImageStreamCompleter$Mate extends _i1.OneFrameImageStreamCompleter
    with _i2.Mate {
  /// OneFrameImageStreamCompleter OneFrameImageStreamCompleter(Future<ImageInfo> image, {Iterable<DiagnosticsNode> Function()? informationCollector})
  OneFrameImageStreamCompleter$Mate(
    /// requiredParameters: Future<ImageInfo> image
    super.image, {
    /// optionalParameters: {Iterable<DiagnosticsNode> Function()? informationCollector} , default:none
    super.informationCollector,
  })  : mateParams = {
          'image': _i2.BuilderArg<_i4.Future<_i1.ImageInfo>>(
            name: 'image',
            init: image,
            isNamed: false,
          ),
          'informationCollector': _i2.BuilderArg<_i5.InformationCollector?>(
            name: 'informationCollector',
            init: informationCollector,
            isNamed: true,
          ),
        },
        super() {
    mateBuilderName = 'OneFrameImageStreamCompleter';
    matePackageUrl = 'package:flutter/cupertino.dart';
    mateBuilder = (p) => OneFrameImageStreamCompleter$Mate(
          p.get('image').value,
          informationCollector: p.get('informationCollector').build(),
        );
  }

  @override
  final Map<String, _i2.BuilderArg> mateParams;
}

/// class MultiFrameImageStreamCompleter extends ImageStreamCompleter
class MultiFrameImageStreamCompleter$Mate
    extends _i1.MultiFrameImageStreamCompleter with _i2.Mate {
  /// MultiFrameImageStreamCompleter MultiFrameImageStreamCompleter({required Future<Codec> codec, required double scale, String? debugLabel, Stream<ImageChunkEvent>? chunkEvents, Iterable<DiagnosticsNode> Function()? informationCollector})
  MultiFrameImageStreamCompleter$Mate({
    /// optionalParameters: {required Future<Codec> codec} , default:none
    required super.codec,

    /// optionalParameters: {required double scale} , default:none
    required super.scale,

    /// optionalParameters: {String? debugLabel} , default:none
    super.debugLabel,

    /// optionalParameters: {Stream<ImageChunkEvent>? chunkEvents} , default:none
    super.chunkEvents,

    /// optionalParameters: {Iterable<DiagnosticsNode> Function()? informationCollector} , default:none
    super.informationCollector,
  })  : mateParams = {
          'codec': _i2.BuilderArg<_i4.Future<_i3.Codec>>(
            name: 'codec',
            init: codec,
            isNamed: true,
          ),
          'scale': _i2.BuilderArg<double>(
            name: 'scale',
            init: scale,
            isNamed: true,
          ),
          'debugLabel': _i2.BuilderArg<String?>(
            name: 'debugLabel',
            init: debugLabel,
            isNamed: true,
          ),
          'chunkEvents': _i2.BuilderArg<_i4.Stream<_i1.ImageChunkEvent>?>(
            name: 'chunkEvents',
            init: chunkEvents,
            isNamed: true,
          ),
          'informationCollector': _i2.BuilderArg<_i5.InformationCollector?>(
            name: 'informationCollector',
            init: informationCollector,
            isNamed: true,
          ),
        },
        super() {
    mateBuilderName = 'MultiFrameImageStreamCompleter';
    matePackageUrl = 'package:flutter/cupertino.dart';
    mateBuilder = (p) => MultiFrameImageStreamCompleter$Mate(
          codec: p.get('codec').build(),
          scale: p.get('scale').build(),
          debugLabel: p.get('debugLabel').build(),
          chunkEvents: p.get('chunkEvents').build(),
          informationCollector: p.get('informationCollector').build(),
        );
  }

  @override
  final Map<String, _i2.BuilderArg> mateParams;
}
