#!/usr/bin/env bash
set -o errtrace  # -E trap inherited in sub script
set -o errexit   # -e
set -o functrace # -T If set, any trap on DEBUG and RETURN are inherited by shell functions
set -o pipefail  # default pipeline status==last command status, If set, status=any command fail
#set -o nounset # -u: don't use it ,it is crazy, 1.bash version is diff Behavior 2.we need like this: ${arr[@]+"${arr[@]}"}

# v0.2.20230525 - It can run normally on macos
#
# chinese-----------------------------------------------------------------------
# bake == (bash)ake == 去Make的bash tool
# bake 是个简单的命令行工具，以替代Makefile的子命令功能
# make工具的主要特点是处理文件依赖进行增量编译，但flutter、golang、java、js项目的build工具
# 太厉害了，这几年唯一还在用Makefile的理由就是他的子命令机制: "make build"、
# "make run", 可以方便的自定义单一入口的父子命令，但Makefile本身的语法套路也很复杂，
# 很多批处理还是要靠bash, 这就尴尬了，工具太多，麻烦！本脚本尝试彻底摆脱使用Makefile。
# 经尝试，代码很少啊 ，核心代码几百行啊，父子命令2百行左右，option解析2百行左右，功能足够了：
#
# english-----------------------------------------------------------------------
# bake == (bash)ake == De-Make bash tool
# bake is a simple cli tool to replace the subcommand function of Makefile
# The main feature of the make tool is to process file dependencies for
# incremental compilation, but the build tools for flutter, golang, java,
# and js projects, It's so powerful, the only reason why I still use Makefile
# in recent years is its subcommand mechanism: "make build",
# "make run", it is convenient to customize the parent-child command of a
# single entry, but the syntax of the Makefile itself is also very complicated.
# A lot of batch processing still depends on bash, which is embarrassing,
# too many tools, So complicated! This script attempts to get rid of Makefiles
# altogether. After trying, the code is very little, the core code is
# hundreds of lines, the parent-child command is about 200 lines,
# and the option parse is about 200 lines, the function is enough:

# chinese-----------------------------------------------------------------------
# bake命令规则：
# 1. 函数即命令，所有bake内的函数均可以在脚本外运行：
#      ./bake [all function]     # bake内的所有函数均可以在脚本外直接运行
#      ./bake _self              # 比如这个内部函数, 看bake内部变量，调试脚本用
#      ./bake test              # 你如果定义过test()函数，就可以这样运行
# 2. 带"."的函数，形成父子命令，比如 bake.opt.set()函数是bake.opt()的子命令，bake.opt()
#    是bake()的子命令，即便未定义父命令，也可以通过父命令列子命令看帮助:
#      ./bake bake -h           # 运行子命令,或看帮助
#      ./bake bake opt -h       # 运行子命令,或看帮助
#      ./bake bake opt set -h   # 运行子命令,或看帮助
#      ./bake bake opt set -h   # 由于规则1，可直接用函数名运行子命令
# 3. 你可以定义根命令"_root()"
#      ./bake                   # 如果有_root()函数，就执行它
# 4. 像其他高级语言的cli工具一样，用简单变量就可以获取命令option:
#    # a. 先在bake文件里里定义app options
#      bake.opt.set --cmd build --name "target" --type string
#    # b. 解析和使用option
#      function build() {
#         eval "$(bake.opt.parse "${FUNCNAME[0]}" "$@")";
#         echo "build ... your option：target: $target";
#      }
#    # c. 调用看看:
#      ./bake build --target "macos"
# 5. bake尽量不依赖bash以外的其他工具，包括linux coreutils,更简单通用,但由于用了关联数组等
#    依赖bash4+
# 6. 这个文件copy走，把"bake common script end line."之下的脚本替换成你的就可以用了.

# english-----------------------------------------------------------------------
# bake rules:
# 1. bash function are cmd, all functions in bake can be run outside the script:
#     ./bake [all func]   # All functions in bake can be run outside script
#     ./bake _self        # For example, this internal function,
#                         # see bake internal variables, used to debug scripts
#     ./bake test        # If you have a test() function, you can run it like this
# 2. Functions with "." is parent-child commands, such as bake.opt.set() function
#    is a subcommand of bake.opt(), bake.opt()  is a subcommand of bake(),
#    even the parent command is not defined, you can also view the help :
#     ./bake bake -h          # Run subcommands, or see help
#     ./bake bake opt -h      # Run subcommands, or see help
#     ./bake bake.opt.set -h  # Run subcommands, or see help
#     ./bake bake.opt.set -h  # Due to rule 1, the subcommand can be run directly with the function name
# 3. You can define the root command "_root()"
#     ./bake                  # If there is a _root() function, execute it
# 4. Like other high-level language cli tools, command options can be obtained with simple variables:
#     # a. Define options before the command function
#     bake.opt.set --cmd build --name "target" --type string
#     # b. Parse and use option
#       function build() {
#         eval "$(bake.opt.parse "${FUNCNAME[0]}" "$@")";
#         echo "build ... your option: target: $target";
#       }
#     # c. Call it:
#       ./bake build --target "macos"
# 5. bake try not to depends on too many external tools other than bash,
#    including linux coreutils, keep it simple, But because of the use of
#    associative arrays arrays, Depend on bash4+
# 6. Copy this file, replace the script under "bake common script end line."
#    with yours and it will be ready to use.
#
# other command framework ref:
# https://pub.dev/documentation/args/latest/args/ArgParser-class.html
# https://github.com/spf13/pflag
# https://oclif.io/docs/flags

# know bash version
# ref: https://ftp.gnu.org/gnu/bash/
# 1. ${parameter@operator} : from 2016 bash 4.4
#      ${parameter@Q} quoted in a format that can be reused as input
#      ${parameter@E} expanded as with the $'...' quoting mechansim
#      ${parameter@A} an assignment statement or declare command
# 2. associative array : from 2009 bash 4.0
#    declare -A
_on_error() {
  echo "trapped an error: ↑ , trace: ↓" >&2
  _stack_frame
}
# Add the error catch first
#https://www.gnu.org/software/bash/manual/html_node/Bourne-Shell-Builtins.html#index-trap
trap "_on_error" ERR
# todo trap exit and kill all subprocess

# check bake dependencies
if ((BASH_VERSINFO[0] < 4 || (\
  BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 4))); then
  echo "Error: It's 2082 ，Your bash is still this version(BASH_VERSINFO: ${BASH_VERSINFO[*]})，Please install bash 4.4+:
    apt install bash  # ubuntu
    brew install bash # mac"
  exit 1
fi

# copy from flutter
# ----------------------
# On Mac OS, readlink -f doesn't work, so bake.readlink traverses the path one
# link at a time, and then cds into the link destination and find out where it
# ends up.
# The function is enclosed in a subshell to avoid changing the working directory
# of the caller.
function _readlink() (
  cd -P "$(dirname -- "$1")"
  file="$PWD/$(basename -- "$1")"
  while [[ -L "$file" ]]; do
    cd -P "$(dirname -- "$file")"
    file="$(readlink -- "$file")"
    cd -P "$(dirname -- "$file")"
    file="$PWD/$(basename -- "$file")"
  done
  echo "$file"
)
# bake context
BAKE_PATH="$(_readlink "${BASH_SOURCE[0]}")"
BAKE_DIR="$(dirname "$BAKE_PATH")"
BAKE_FILE="$(basename "$BAKE_PATH")"
cd "${BAKE_DIR}" # set workdir

declare -r _LOG_LEVELS=(error info debug)
declare LOG=${LOG:-info}
_current_dir() {
  echo "${PWD/#$HOME/\~}" # replace $HOME with "~"
}
_error() {
  if [[ "${_LOG_LEVELS[@]:0}" != *"$LOG"* ]]; then return 0; fi
  echo -e "ERROR $(date "+%F %T") $(_current_dir)\$ ${FUNCNAME[1]}() : $*" >&2
}
_info() {
  if [[ "${_LOG_LEVELS[@]:1}" != *"$LOG"* ]]; then return 0; fi
  echo -e "INFO  $(date "+%F %T") $(_current_dir)\$ ${FUNCNAME[1]}() : $*" >&2
}
_debug() {
  if [[ "${_LOG_LEVELS[@]:2}" != *"$LOG"* ]]; then return 0; fi
  echo -e "DEBUG $(date "+%F %T") $(_current_dir)\$ ${FUNCNAME[1]}() : $*" >&2
}
_debug "LOG level is $LOG :===${_LOG_LEVELS[@]:0}==="

# list internal var , used to debug bake self
function _self() (
  echo '# bake _self internal var'
  echo
  echo '## _cmdTree'
  echo
  for key in "${!_cmdTree[@]}"; do
    printf "cmd  - %-40s = %q\n" "$key" "${_cmdTree["$key"]:0:100}"
  done | sort
  echo
  echo '## _data'
  echo
  for key in "${!_data[@]}"; do
    printf "data - %-40s = %q\n" "$key" "${_data["$key"]:0:100}"
  done | sort
)

# Usage: _stack_frame
_stack_frame() {
  local i=0
  local stackInfo
  while true; do
    stackInfo=$(caller $i 2>&1 && true) && true
    if [[ $? != 0 ]]; then break; fi

    # parse
    # 97 test_bake.str.split ./test/bake2_test.bash
    local no func file
    IFS=' ' read -r no func file <<<"$stackInfo"

    # clickable stack:
    # /Users/c/git/younpc/note/test/bake2_test.bash:38 bake.test.runTest()
    printf "%s\n" "$(_readlink $file):$no $func()" >&2

    i=$((i + 1))
  done
}

##########################################
# bake common script
##########################################

# Simulating object-oriented data structures with flat associative arrays
# use ./bake _self to see internal var
# save all other data
declare -A _data

# only save all commands, we use it to build command tree
# it is cache cmd tree from _data
declare -A _cmdTree

TYPE_CMD="type:cmd"

##########################################
# bake common function
##########################################

# Usage: bake.str.cutLeft <str> <left>
# bake.path.dirname a/b/c  a/b    => c
bake.str.cutLeft() { printf "${1#$2}"; }

# escape to 'xxx' or $'xxx'
#  https://www.gnu.org/software/bash/manual/bash.html#ANSI_002dC-Quoting
bake.str.escape() {
  #  from 2016 bash 4.4
  #  ${parameter@Q} : quoted in a format that can be reused as input
  # to 'xxx' or $'xxx'
  printf '%s\n' "${1@Q}"
}
# unescape from 'xxx' or $'xxx'
bake.str.unescape() {
  local str=${1}
  # $'xx' => xx
  if [[ "$str" == "\$'"*"'" ]]; then
    str="${str:2:-1}"
  # 'xx' => xx
  elif [[ "${str}" == "'"*"'" ]]; then
    str="${str:1:-1}"
  fi
  #  from 2016 bash 4.4
  #  ${parameter@E} expanded as with the $'...' quoting mechansim
  printf '%s' "${str@E}"
}

# Usage: bake.str.split <str> [delimiter:default /]
bake.str.split() {
  local str=$1 delimiter=${2:-/}
  #  # use <() process-substitution
  #  # don't use <<< "" its add newline
  local arr
  readarray -t arr < <(printf '%s' "${str//$delimiter/$'\n'}")
  printf '%s\n' "${arr[@]}"
}

# Usage: bake.str.revertLines <<< "$(echo -e "a\nb\nc")"  => "c\nb\na"
function bake.str.revertLines() {
  # cat xxx | tail -r; # macos bsd only, not work on linux
  # so use sed
  sed '1!G;h;$!d' # sed magic
}

# Usage: bake.path.dirname <str> [delimiter:default /]
# similar command dirname, but
#     dirname root is ".", only work with "/"
#     bake.path.dirname root is "" , can set delimiter
# bake.path.dirname a.b.c .    => a.b
bake.path.dirname() {
  local pathLikeStr="$1" delimiter="${2:-/}"
  if [[ "$pathLikeStr" != *"$delimiter"* ]]; then
    return
  fi
  printf '%s' "${pathLikeStr%$delimiter*}"
}
# Usage: bake.path.first <str> [delimiter:default /]
# bake.path.first a.b.c .    => a
bake.path.first() {
  local pathLikeStr="$1" delimiter="${2:-/}"
  # if /a/b/c , call :bake.path.first a/b/c /
  if [[ "$pathLikeStr" == "$delimiter"* ]]; then
    local removeDelim
    removeDelim=$(bake.str.cutLeft "$pathLikeStr" "$delimiter")
    printf "$delimiter$(bake.path.first "$removeDelim" "$delimiter")"
  else # a/b/c
    printf "${pathLikeStr%%$delimiter*}"
  fi
}
# similar command basename
# Usage: bake.path.basename <str> [delimiter:default /]
bake.path.basename() {
  local pathLikeStr="$1" delimiter="${2:-/}"
  # ${1##*/}  => ## left remove until last "/"
  printf "${pathLikeStr##*$delimiter}"
}

# Usage: bake.data.children <dataPath>
#   return <dataPath> children name
bake.data.children() {
  local path="$1"
  # ${!_data[@]}: get all array keys
  local key
  for key in "${!_data[@]}"; do
    # if start $path
    if [[ "$key" == "$path"* ]]; then
      # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
      # remove prefix : key:build/opts/dir/type/x leftPathToBeCut:build/opts => dir/type/x
      local child=$(bake.str.cutLeft "$key" "$path/")
      # remove suffix:  dir/type/x => dir
      child=$(bake.path.first "$child" "/")
      printf '%s\n' "$child"
    fi
  done | sort -u
}

bake.cmd.childrenNameMaxLength() {
  local cmd="$1" maxLengthOfCmd=0
  for child in $(bake.cmd.children "$cmd"); do
    if ((${#child} > maxLengthOfCmd)); then maxLengthOfCmd=${#child}; fi
  done
  printf "$maxLengthOfCmd"
}
bake.cmd.children() (
  path="$1"
  if [[ "$path" == _root ]]; then
    path=""
  fi

  # ${!_data[@]}: get all array keys
  for key in "${!_cmdTree[@]}"; do
    # if start $path
    if [[ "$key" == "$path"* && "$key" != "$path" && "$key" != "_root" ]]; then
      # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
      # remove prefix : key:a.b.c leftPathToBeCut:a => b.c
      child=$(bake.str.cutLeft "$key" "$path.")
      # remove suffix:  b.c => c
      child=$(bake.path.first "$child" ".")
      printf '%s\n' "$child"
    fi
  done | sort -u
)

# Usage: bake.cmd.up_chain <cmd>
# sample: bake.cmd.up_chain a.b      => "a.b", "a", "_root"
function bake.cmd.up_chain() {
  local path="${1:-_root}"
  local up="$path"
  while [[ "$up" != "" ]]; do
    printf '%s\n' "$up"
    up=$(bake.path.dirname "$up" ".")
  done
  if [[ "$path" != "_root" ]]; then printf "_root\n"; fi
}
# Usage: bake.cmd.down_chain <cmd>
# reverse of bake.cmd.up_chain
function bake.cmd.down_chain() {
  bake.cmd.up_chain "$1" | bake.str.revertLines
}

# Usage: bake.opt.cmd_chain_opts <cmd>
# return optionDataPath list
function bake.opt.cmd_chain_opts() {
  local cmd=$1
  local upCmds
  readarray -t upCmds <<<"$(bake.cmd.up_chain "$cmd")"

  local key
  for key in "${!_data[@]}"; do
    if [[ "${_data["$key"]}" != "type:opt" ]]; then continue; fi
    local upCmd
    for upCmd in "${upCmds[@]}"; do
      if [[ "$key" == "$upCmd/opts/"* ]]; then
        printf '%s\n' "$key"
      fi
    done
  done | sort
}

# only use by bake.opt.set,
# because "bake.opt.set" is meta function, use this func to add self
bake.opt._internal_add() {
  local cmd="$1" opt="$2" type="$3" required="$4" default="$5" abbr="$6" help="$7"
  _data["$cmd/opts/$opt"]="type:opt"
  _data["$cmd/opts/$opt/name"]="$opt"
  _data["$cmd/opts/$opt/type"]="$type"
  _data["$cmd/opts/$opt/required"]="$required"
  _data["$cmd/opts/$opt/abbr"]="$abbr"
  _data["$cmd/opts/$opt/default"]="$default"
  _data["$cmd/opts/$opt/optHelp"]="$optHelp"
}
bake.opt._internal_add bake.opt.set "cmd" "string" "true" "" "" "cmd name"
bake.opt._internal_add bake.opt.set "name" "string" "true" "" "" "option name"
bake.opt._internal_add bake.opt.set "type" "string" "true" "" "" "option type"
bake.opt._internal_add bake.opt.set "required" "bool" "false" "false" "" "option required"
bake.opt._internal_add bake.opt.set "abbr" "string" "false" "" "" "option abbr"
bake.opt._internal_add bake.opt.set "default" "string" "false" "" "" "option abbr"
bake.opt._internal_add bake.opt.set "optHelp" "string" "false" "" "" "option help"
bake.opt.set() {
  eval "$(bake.opt.parse ""${FUNCNAME[0]}"" "$@")"
  if [[ "$name" == "" ]]; then
    echo "error: option [--name] required " >&2 && return 1
  fi
  if [[ "$type" == "" ]]; then
    echo "error: option [--type] required " >&2 && return 1
  fi
  if [[ "$type" != "bool" && "$type" != "string" && "$type" != "list" ]]; then
    echo "error: option [--type] must in [bool|string|list] " >&2 && return 1
  fi
  bake.opt._internal_add "$cmd" "$name" "$type" "${required:-false}" "$default" "$abbr" "$optHelp"
}

# only use by bake.opt.set,
function bake.opt.value() {
  local cmd="$1" opt="$2"
  printf '%s' "${_data["$cmd/opts/$opt/value"]}"
}

# Usage: bake.opt.parse <cmd:default _root> [arg1] [arg2] ...
function bake.opt.parse() {
  local cmd="${1:_root}"
  shift # shift cmd arg, left all is options maybe
  # key is -h --help ... candidate words ,
  # value is optPath
  declare -A allOptOnCmdChain
  # collect opt from command chain : _root>pub>pub.get
  #   root option first , priority low -> priority high:
  for optPath in $(bake.opt.cmd_chain_opts "$cmd" | bake.str.revertLines); do
    local opt
    opt=$(bake.path.basename "$optPath")
    local abbr
    abbr=${_data["$optPath/abbr"]}
    allOptOnCmdChain["--$opt"]="${optPath}"
    if [[ "$abbr" != "" ]]; then allOptOnCmdChain["-$abbr"]="${optPath}"; fi
  done

  # dynamic opt variable map : optPath:optVarName
  # Why use dynamic variables: because the variable name is not fixed
  # and We want to manipulate arrays(list type opt) more conveniently
  local -A optVars
  local totalArgs="$#"
  # while all args , until it is not opt
  while (($# > 0)); do
    # match $1 arg in allOptOnCmdChain, guess $1 is a "-h" "-help" ...
    local optPath
    optPath=${allOptOnCmdChain["$1"]}
    # if next arg not a opt , parsing complete;
    if [[ "${optPath}" == "" ]]; then break; fi

    # _opt_value_ prefix : avoid conflicts in the current context
    optVars["$optPath"]="_opt_value_$(bake.path.basename "$optPath")"
    declare "${optVars["$optPath"]}"
    # reference to the current dynamic  opt variable
    declare -n currentOptValue=${optVars["$optPath"]}

    local optType=${_data["$optPath/type"]}
    case $optType in
    bool)
      currentOptValue=true
      shift 1
      ;;
    string)
      [[ ! "${2+declare}" ]] && echo "parse error: opt need a value: $arg <value> " >&2 && return 1
      currentOptValue="$2"
      shift 2
      ;;
    list)
      [[ ! "${2+declare}" ]] && echo "parse error: opt need a value: $arg <value> " >&2 && return 1
      currentOptValue+=("$2") # array add
      shift 2
      ;;
    *)
      echo "parse error: not support $optPath.type: <$optType> " >&2
      return 1
      ;;
    esac
  done

  local resultStr
  for optPath in "${!optVars[@]}"; do
    local declareStr
    declareStr=$(declare -p "${optVars["$optPath"]}")
    resultStr+="${declareStr/#*_opt_value_/declare };\n"
  done
  resultStr+="declare optShift=$((totalArgs - $#));\n"
  echo -e "$resultStr" # echo -e : unescapes backslash
}

bake.opt.set --cmd bake.cmd.set --name "cmd" --type string --optHelp "cmd, function name"
bake.opt.set --cmd bake.cmd.set --name "usage" --type string --optHelp "usage"
bake.opt.set --cmd bake.cmd.set --name "summary" --type string --optHelp "summary help, short, show on cmd list"
bake.opt.set --cmd bake.cmd.set --name "description" --type string --optHelp "description, long help ,show on cmd help page"

function bake.cmd.set() {
  # 模版代码，放到每个需要使用option的函数中，然后就可以使用option了
  eval "$(bake.opt.parse "${FUNCNAME[0]}" "$@")"
  if [[ "$cmd" == "" ]]; then
    echo "error: bake.cmd.set [--cmd] required " >&2
    return 1
  fi
  #  bake.opt.parse "${FUNCNAME[0]}" "$@" >&2
  _data["$cmd/usage"]="$usage"
  _data["$cmd/summary"]="$summary"
  _data["$cmd/description"]="$description"
}

# Usage: bake.cmd.register
# ensure all cmd register
function bake.cmd.register() {
  local functionName
  while IFS=$'\n' read -r functionName; do
    if [[ "$functionName" == */* ]]; then
      echo "error: function $functionName() can not contains '/' " >&2
      return 1
    fi
    local upCmd
    for upCmd in $(bake.cmd.up_chain "$functionName"); do
      # if upCmd is a function , set upCmd value to data path
      if compgen -A function | grep -q "^$upCmd$"; then
        _cmdTree["$upCmd"]="$upCmd"
      else
        _cmdTree["$upCmd"]="PARENT_CMD_NOT_FUNC"
      fi
    done

    # list all function name
    # declare -F | awk {'print $3'} == compgen -A function
    # declare -f func1  -> func1
    # declare -fx func2 -> func2
  done <<<"$(compgen -A function)"
}

function bake.help() (
  local cmd="$1"
  shift
  eval "$(bake.opt.parse "${FUNCNAME[0]}" "$@")"

  local usage
  usage="${_data["${cmd}/usage"]}"
  if [[ "$usage" != "" ]]; then
    echo -e "\nUsage:  $usage "
  else
    echo -e "\nUsage:  ./$BAKE_FILE $(bake.str.split "$cmd" "." | tr "\n" " ") [options] [args...]"
  fi

  echo

  echo "Currently running: $(_current_dir)/$BAKE_FILE $cmd $@"

  echo

  if [[ "${_data["${cmd}/description"]}" != "" ]]; then
    echo "Description: ${_data["${cmd}/description"]}"
  elif [[ "${_data[${cmd} / summary]}" != "" ]]; then
    echo "Description: ${_data["${cmd}/summary"]}"
  else
    echo "no description"
  fi

  echo

  echo "Available Options:"
  for optPath in $(bake.opt.cmd_chain_opts "$cmd"); do
    local opt
    opt=$(bake.path.basename "$optPath")
    local name=${_data["$optPath/name"]}
    local type=${_data["$optPath/type"]}
    local required=${_data["$optPath/required"]}
    local abbr=${_data["$optPath/abbr"]}
    local default=${_data["$optPath/default"]}
    local optHelp="${_data["$optPath/optHelp"]}"

    local optArgDesc=""
    if [[ "$type" == "string" ]]; then
      if [[ "$default" != "" ]]; then
        optArgDesc+="<$type:${default}>"
      else
        optArgDesc="<$type>"
      fi
    fi

    printf " --%-20s -%-2s %-6s required:[%s] %b\n" "$name $optArgDesc" "$abbr" "$type" "$required" "$optHelp"
  done

  echo "
Available Commands:"
  local maxLengthOfCmd
  maxLengthOfCmd="$(bake.cmd.childrenNameMaxLength "$cmd")"
  for subcmdName in $(bake.cmd.children "$cmd"); do

    # only show public cmd if not verbose
    if [[ "$verbose" == "" && ("$subcmdName" == _* ||
      "$subcmdName" == bake*) ||
      "$subcmdName" == @* ]]; then
      continue
    fi

    local subCmd="$cmd/$subcmdName"
    [[ "$cmd" == "_root" ]] && subCmd="$subcmdName"

    # 第二行开始，都补空格
    local summary usage
    summary="${_data["$subCmd/summary"]}"
    usage="${_data["$subCmd/usage"]}"
    if [[ "$usage" != "" ]]; then
      [[ "$summary" == "" ]] && summary="Usage: $usage" || summary+="\nUsage: $usage"
    fi
    summary="$(echo -e "$summary")" #  backslash escapes interpretation

    local padding
    padding=$(printf %-$((maxLengthOfCmd + 6))b "")
    summary=$(sed "2,1000s/^/$padding/g" <<<"$summary")

    printf "  %-$((maxLengthOfCmd))s    ${summary}\n" "${subcmdName}"
  done
)

function bake.go() {
  # init register all cmd

  bake.cmd.register

  # parse cmd :
  #   ./bake pub get -v -b
  #     -> { cmd:"pub.get", args:"-v -b" }
  #   ./bake -h
  #     -> { cmd:"", args:"-h" }
  local cmd nextCmd arg
  for arg in "$@"; do
    nextCmd="$([[ "$cmd" == "" ]] && echo "$arg" || echo "$cmd.$arg")"
    if [[ "${_cmdTree["$nextCmd"]}" == "" ]]; then break; fi
    cmd="$nextCmd"
    shift
  done

  if [[ "$cmd" == "" ]]; then cmd="_root"; fi
  eval "$(bake.opt.parse "$cmd" "$@")"

  if [[ "$help" == "true" ]]; then
    bake.help "$cmd" "$@"
    return 0
  fi
  if [[ "$log" != "" ]]; then LOG="$log"; fi

  #    # parse opts
  if ! declare -f "$cmd" >/dev/null 2>&1; then
    if [[ "${_cmdTree["$cmd"]}" == "PARENT_CMD_NOT_FUNC" ]]; then
      bake.help "$cmd" "$@"
      return 0
    fi
    _error "Error: 404 ,cmd '${cmd}' not define, please define cmd function '${cmd}()'"
    return 1
  fi

  $cmd "$@"
}

# _root is special cmd(you can define it), bake add some common options to this cmd, you can add yourself options
bake.opt.set --cmd _root --name "help" --abbr h --type bool --default false --optHelp "print help, show all commands"
bake.opt.set --cmd _root --name "verbose" --abbr v --type bool --default false --optHelp "verbose, show more info, more hidden commands"
bake.opt.set --cmd _root --name "log" --type string --default info --optHelp "log level: debug, info, error"

# BASH_SOURCE > 1 , means bake import from other script, it is lib mode
# lib mod is not load app function, so we need to stop here
if ((${#BASH_SOURCE[@]} > 1)); then
  _debug "【${BAKE_FILE}】 call by other script【$(printf " ▶︎ %s" "${BASH_SOURCE[@]}")】, lib mode on, not load below app script" >&2
  return 0
fi

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# bake common script end line.
# The above code is common code that is not related to the specific app,
# if you want to define app-related commands,
# please define them below to clean and separate the common and app code
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

####################################################################################
# app script
# 应用项目补充的公共脚本，不在bake维护范围
# 此位置以上的全都是bake工具脚本，copy走可以直接用，之下的为项目特定cmd，自己弄
####################################################################################
# print first, then _exec
function _exec() {
  local project
  project=$(basename "$PWD")
  #  [[ "$PWD" == "$BAKE_DIR" ]] && project="_root"
  _info "${FUNCNAME[1]}() ▶︎【$*】"
  "$@"
  return $?
}

##########################################
# app cmd script
# 应用的命令脚本
##########################################

bake.cmd.set --cmd _root \
  --usage "./$BAKE_FILE [cmd] [opts] [args...]" \
  --summary "flutter-note build cli." \
  --description "$(
    cat <<-EOF

____ _    _  _ ___ ___ ____ ____    _  _ ____ ___ ____
|___ |    |  |  |   |  |___ |__/ __ |\ | |  |  |  |___
|    |___ |__|  |   |  |___ |  \    | \| |__|  |  |___

flutter-note build tools.

Samples:
 ./${BAKE_FILE}                          # default run "get()"
 ./${BAKE_FILE} -h                       # show all commands help
 ./${BAKE_FILE} -h -v                    # show all commands help , include internal commands
 ./${BAKE_FILE} all  flutter pub get     # run "flutter pub get" on all mono projects
 ./${BAKE_FILE} note flutter pub get     # run "flutter pub get" on note project

EOF
  )"

init() {
  run git lfs install
  note_app flutter create --platforms=macos .
}

bake.cmd.set --cmd all --summary "<mono>  run cmd on all mono project" \
  --usage "Usage: ./$BAKE_FILE all [any command]"

function all() {
  #       目录中有"pubspec.yaml"的，认为是flutter项目
  #        for project in $( find . -name pubspec.yaml | sed s/pubspec.yaml$//g ) ; do
  #          # 用括号()开启子进程执行，可以不影响当前进程的环境
  #          ( cd "$project" ;  run "$@" ; )
  #        done
  (cd learn_dart && _exec "$@")
  (cd note && _exec "$@")
  (cd mate_flutter && _exec "$@")
  (cd mate && _exec "$@")
  (cd note_app && _exec "$@")
  (cd note_test && _exec "$@")
}

bake.cmd.set --cmd note --usage "./$BAKE_FILE note [any command]" --summary "<project> run cmd on project"
bake.cmd.set --cmd note_app --usage "./$BAKE_FILE note_app [any command]"
bake.cmd.set --cmd mate --usage "./$BAKE_FILE mate [any command]"
bake.cmd.set --cmd mate_flutter --usage "./$BAKE_FILE mate_flutter [any command]"
bake.cmd.set --cmd note_test --usage "./$BAKE_FILE note_test [any command]"
function note() (cd note && _exec "$@")
function note_app() (cd note_app && _exec "$@")
function mate() (cd mate && _exec "$@")
function mate_flutter() (cd mate_flutter && _exec "$@")
function note_test() (cd note_test && _exec "$@")

bake.cmd.set --cmd get --usage "./$BAKE_FILE get" --summary "<shortcut> ./bake all flutter pub get"
function get() {
  _exec all flutter pub get
}

bake.cmd.set --cmd test --usage "./$BAKE_FILE test" --summary "<shortcut> run all tests in all projects"

function test() {
  ./test/bake2_test.bash test
  _exec all flutter test
}

run() {
  # only work on macos
  # shellcheck disable=SC2155
  local ip=$(ifconfig -l | xargs -n1 ipconfig getifaddr) || true
  note_app flutter run --web-hostname "$ip" --web-port 8888 --web-renderer html --device-id chrome  "$@"
}

build() {
  note_app flutter build web -v  \
    --release --tree-shake-icons \
    --web-renderer html "$@"
}

docker.build() (
    _exec docker build --progress plain --tag younpc/note:latest . ;
    _exec mkdir -p build/web
    _exec sh -c "docker run --rm --workdir /usr/share/nginx/html/note younpc/note tar cf - ./ | ( cd build/note_app/web; tar xf -)"
)
docker.run() {
    _exec echo  "note preview http://localhost:8888/note/"
    _exec docker run --rm --name note -p 8888:80 -u root:root younpc/note
}
docker.preview() {
  _exec docker build --progress plain --build-arg test=off --tag younpc/note:latest . ;
  docker.run
}

preview() {
  #   http-server 不支持base href设置，所以单独build,并设置base-href为"/",而github-pages的base-href必须是repository名
#  build "$@"
  # 	npx http-server ./app_note/build/web --port 8000
  _exec deno run --allow-env --allow-read --allow-sys --allow-net npm:http-server ./note_app/build/web --port 8000 -g --brotli
}

####################################################
# app entry script & _root cmd
####################################################

bake.go "$@"
