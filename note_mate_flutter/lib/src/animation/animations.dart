// /// Generated by gen_maters.dart, please don't edit!

import 'package:flutter/src/animation/animations.dart';
import 'package:note/mate.dart';
import 'package:flutter/src/animation/animation.dart';
import 'dart:core';
import 'package:flutter/src/animation/curves.dart';
import 'dart:ui';

/// class AlwaysStoppedAnimation<T> extends Animation<T>
class AlwaysStoppedAnimation$Mate<T> extends AlwaysStoppedAnimation<T> with Mate<AlwaysStoppedAnimation$Mate> {
  /// AlwaysStoppedAnimation<T> AlwaysStoppedAnimation(T value)
  AlwaysStoppedAnimation$Mate(

      /// requiredParameters: T value
      T value)
      : super(value) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => AlwaysStoppedAnimation$Mate(p.get('value').value),
    );
    mateParams.put('value', init: value);
  }
}

/// class ProxyAnimation extends Animation<double> with AnimationLazyListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin
class ProxyAnimation$Mate extends ProxyAnimation with Mate<ProxyAnimation$Mate> {
  /// ProxyAnimation ProxyAnimation([Animation<double>? animation])
  ProxyAnimation$Mate(

      /// requiredParameters: [Animation<double>? animation]
      Animation<double>? animation)
      : super(animation) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => ProxyAnimation$Mate(p.get('animation').value),
    );
    mateParams.put('animation', init: animation);
  }
}

/// class ReverseAnimation extends Animation<double> with AnimationLazyListenerMixin, AnimationLocalStatusListenersMixin
class ReverseAnimation$Mate extends ReverseAnimation with Mate<ReverseAnimation$Mate> {
  /// ReverseAnimation ReverseAnimation(Animation<double> parent)
  ReverseAnimation$Mate(

      /// requiredParameters: Animation<double> parent
      Animation<double> parent)
      : super(parent) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => ReverseAnimation$Mate(p.get('parent').value),
    );
    mateParams.put('parent', init: parent);
  }
}

/// class CurvedAnimation extends Animation<double> with AnimationWithParentMixin<double>
class CurvedAnimation$Mate extends CurvedAnimation with Mate<CurvedAnimation$Mate> {
  /// CurvedAnimation CurvedAnimation({required Animation<double> parent, required Curve curve, Curve? reverseCurve})
  CurvedAnimation$Mate({
    /// optionalParameters: {required Animation<double> parent} , hasDefaultValue:false, defaultValueCode:null
    required Animation<double> parent,

    /// optionalParameters: {required Curve curve} , hasDefaultValue:false, defaultValueCode:null
    required Curve curve,

    /// optionalParameters: {Curve? reverseCurve} , hasDefaultValue:false, defaultValueCode:null
    Curve? reverseCurve,
  }) : super(
          parent: parent,
          curve: curve,
          reverseCurve: reverseCurve,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => CurvedAnimation$Mate(
        parent: p.get('parent').value,
        curve: p.get('curve').value,
        reverseCurve: p.get('reverseCurve').value,
      ),
    );
    mateParams.put('parent', init: parent);
    mateParams.put('curve', init: curve);
    mateParams.put('reverseCurve', init: reverseCurve);
  }
}

/// class TrainHoppingAnimation extends Animation<double> with AnimationEagerListenerMixin, AnimationLocalListenersMixin, AnimationLocalStatusListenersMixin
class TrainHoppingAnimation$Mate extends TrainHoppingAnimation with Mate<TrainHoppingAnimation$Mate> {
  /// TrainHoppingAnimation TrainHoppingAnimation(Animation<double> _currentTrain, Animation<double>? _nextTrain, {void Function()? onSwitchedTrain})
  TrainHoppingAnimation$Mate(
    /// requiredParameters: Animation<double> _currentTrain
    Animation<double> _currentTrain,

    /// requiredParameters: Animation<double>? _nextTrain
    Animation<double>? _nextTrain, {
    /// optionalParameters: {void Function()? onSwitchedTrain} , hasDefaultValue:false, defaultValueCode:null
    VoidCallback? onSwitchedTrain,
  }) : super(
          _currentTrain,
          _nextTrain,
          onSwitchedTrain: onSwitchedTrain,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => TrainHoppingAnimation$Mate(
        p.get('_currentTrain').value,
        p.get('_nextTrain').value,
        onSwitchedTrain: p.get('onSwitchedTrain').value,
      ),
    );
    mateParams.put('_currentTrain', init: _currentTrain);
    mateParams.put('_nextTrain', init: _nextTrain);
    mateParams.put('onSwitchedTrain', init: onSwitchedTrain);
  }
}

/// class AnimationMean extends CompoundAnimation<double>
class AnimationMean$Mate extends AnimationMean with Mate<AnimationMean$Mate> {
  /// AnimationMean AnimationMean({required Animation<double> left, required Animation<double> right})
  AnimationMean$Mate({
    /// optionalParameters: {required Animation<double> left} , hasDefaultValue:false, defaultValueCode:null
    required Animation<double> left,

    /// optionalParameters: {required Animation<double> right} , hasDefaultValue:false, defaultValueCode:null
    required Animation<double> right,
  }) : super(
          left: left,
          right: right,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => AnimationMean$Mate(
        left: p.get('left').value,
        right: p.get('right').value,
      ),
    );
    mateParams.put('left', init: left);
    mateParams.put('right', init: right);
  }
}

/// class AnimationMax<T extends num> extends CompoundAnimation<T>
class AnimationMax$Mate<T extends num> extends AnimationMax<T> with Mate<AnimationMax$Mate> {
  /// AnimationMax<T> AnimationMax(Animation<T> first, Animation<T> next)
  AnimationMax$Mate(
    /// requiredParameters: Animation<T> first
    Animation<T> first,

    /// requiredParameters: Animation<T> next
    Animation<T> next,
  ) : super(
          first,
          next,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => AnimationMax$Mate(
        p.get('first').value,
        p.get('next').value,
      ),
    );
    mateParams.put('first', init: first);
    mateParams.put('next', init: next);
  }
}

/// class AnimationMin<T extends num> extends CompoundAnimation<T>
class AnimationMin$Mate<T extends num> extends AnimationMin<T> with Mate<AnimationMin$Mate> {
  /// AnimationMin<T> AnimationMin(Animation<T> first, Animation<T> next)
  AnimationMin$Mate(
    /// requiredParameters: Animation<T> first
    Animation<T> first,

    /// requiredParameters: Animation<T> next
    Animation<T> next,
  ) : super(
          first,
          next,
        ) {
    mateParams = ObjectParam(
      init: this,
      builder: (p) => AnimationMin$Mate(
        p.get('first').value,
        p.get('next').value,
      ),
    );
    mateParams.put('first', init: first);
    mateParams.put('next', init: next);
  }
}
