#!/usr/bin/env bash
set -o errtrace # -E trap inherited in sub script
set -o errexit # -e
set -o functrace # -T If set, any trap on DEBUG and RETURN are inherited by shell functions
set -o pipefail  # default pipeline status==last command status, If set, status=any command fail
#set -o nounset # -u: don't use it ,it is crazy, 1.bash version is diff Behavior 2.we need like this: ${arr[@]+"${arr[@]}"}
# todo trap exit and kill all subprocess


# bake == (bash)ake == 去make的bash工具
# v0.2.20230521 搞docker那样的多级命令树 目前仅在macos上跑过
# ------------------------------------------------------------------------------
# bake 是个简单的自建命令工具，以替代Makefile的子命令功能
# make工具的主要特点是处理文件依赖进行增量编译，但flutter、golang、java、js项目的build工具
# 太厉害了，这几年唯一还在用Makefile的理由就是他的子命令机制: "make build"、
# "make run", 可以方便的自定义单一入口的父子命令，但Makefile本身的语法套路也很复杂，
# 很多批处理还是要靠bash, 这就尴尬了，工具太多，麻烦！本脚本尝试彻底摆脱使用Makefile。
# 经尝试，代码很少啊 ，核心公共代码百十行啊，还主要是提取显示子命令帮助的，功能足够了：
#   ./bake -h      # 列子命令看帮助，
#   ./bake -h -v   # 列隐藏命令子命令，
#   ./bake build # 子命令
#   ./bake run   # 子命令
# bake命令规则：
# 1. 命令函数通过"."来形成父子关系树 pub.get、assets.list，
#    运行，运行：
#      ./bake2 pub -h #看帮助
#      ./bake2 pub pub -x -y -z  # 运行pub.get函数
#      ./bake2 pub.pub -x -y -z  # 或直接
# 2. 尽量不依赖bash以外的其他工具，包括linux coreutils,以便跨平台更简单
# 搞docker那样的命令树，应该也不难，目前和make一样只支持一级子命令，暂时够用。
# ref
# https://pub.dev/documentation/args/latest/args/ArgParser-class.html
# https://github.com/spf13/pflag/blob/master/string_array.go
# https://oclif.io/docs/flags
# ------------------------------------------------------------------------------

if ((BASH_VERSINFO[0] < 4)); then
  echo "Error: 都2082年了，您的bash还是这个版本(BASH_VERSINFO: ${BASH_VERSINFO[*]})，请安装bash 4+ 后重启terminal:
  apt install bash  # ubuntu
  brew install bash # mac"
  exit 1
fi

# copy from flutter
# ----------------------
# On Mac OS, readlink -f doesn't work, so bake.readlink traverses the path one
# link at a time, and then cds into the link destination and find out where it
# ends up.
# The function is enclosed in a subshell to avoid changing the working directory
# of the caller.
function _readlink() (
  cd -P "$(dirname -- "$1")"
  file="$PWD/$(basename -- "$1")"
  while [[ -L "$file" ]]; do
    cd -P "$(dirname -- "$file")"
    file="$(readlink -- "$file")"
    cd -P "$(dirname -- "$file")"
    file="$PWD/$(basename -- "$file")"
  done
  echo "$file"
)
_error(){
  echo -e "ERROR $(date "+%F %T")-【▶︎${FUNCNAME[1]}】-︎ $*" >&2
}
_log(){
  echo -e "INFO  $(date "+%F %T")-【▶︎${FUNCNAME[1]}】-︎ $*" >&2
}
_debug(){
  echo -e "DEBUG $(date "+%F %T")-【▶︎${FUNCNAME[1]}】-︎ $*" >&2
}

function doctor()(
  echo '# doctor'
  echo '## _cmdTree'
  for key in "${!_cmdTree[@]}"; do
    echo "cmd  - $key=${_cmdTree[$key]:0:100}"
  done
  echo '## _data'
  for key in "${!_data[@]}"; do
    echo "data - $key=${_data[$key]:0:100}"
  done
)

_on_error() {
  echo "trapped an error: ↑ , trace: ↓" >&2
  _stack_frame
}

# Usage: _stack_frame
_stack_frame() {
  local i=0
  local stackInfo
  while true; do
    stackInfo=$(caller $i 2>&1 && true) && true
    if [[ $? != 0 ]]; then break; fi

    # parse
    # 97 test_bake.str.split ./test/bake2_test.bash
    local no func file;
    IFS=' ' read -r no func file <<< "$stackInfo"

    # clickable stack:
    # /Users/c/git/younpc/note/test/bake2_test.bash:38 bake.test.runTest()
    printf "%s\n" "$(_readlink $file):$no $func()" >&2

    i=$((i + 1))
  done
}
# Add the error catch first
trap " set +x; _on_error " ERR

##########################################
# bake common script
##########################################
BAKE_PATH="$(_readlink "${BASH_SOURCE[0]}")"
BAKE_DIR="$(dirname "$BAKE_PATH")"
BAKE_FILE="$(basename "$BAKE_PATH")"

# set workdir
cd "${BAKE_DIR}"

# Simulating object-oriented data structures with flat associative arrays
# opts define:
#_root/opts/help/abbr=h
#_root/opts/help/cmd=_root
#_root/opts/help/name=help
#_root/opts/help/optHelp=print help, show all commands
#_root/opts/help/type=bool
#_root/opts/verbose/abbr=v
#_root/opts/verbose/cmd=_root
#_root/opts/verbose/name=verbose
#_root/opts/verbose/optHelp=verbose, show more info, more hidden commands
#_root/opts/verbose/type=bool
#bake.opt.add/opts/abbr/name=abbr
#bake.opt.add/opts/abbr/type=string
#bake.opt.add/opts/cmd/name=cmd
#bake.opt.add/opts/cmd/type=string
#bake.opt.add/opts/name/name=name
#bake.opt.add/opts/name/required=true
#bake.opt.add/opts/name/type=string
#bake.opt.add/opts/optHelp/name=optHelp
#bake.opt.add/opts/optHelp/type=string
#bake.opt.add/opts/type/name=type
#bake.opt.add/opts/type/type=string
# parsed opts value:
#  _data[_root/opts/verbose/value]=true
#  _data[pub.get/opts/notes/value/0]="..lib/note.page"
#  _data[pub.get/opts/notes/value/1]="./lib/a/note.page"
# save all other data
declare -A _data

# only save all commands, we use it to build command tree
# it is cache data from _data
declare -A _cmdTree

TYPE_CMD="type:cmd"

##########################################
# bake common function
##########################################

# Usage: bake.str.cutLeft <str> <left>
# bake.path.dirname a/b/c  a/b    => c
bake.str.cutLeft(){ printf "${1#$2}"; }

# Usage: bake.str.split <str> [delimiter:default /]
bake.str.split() {
  local str=$1 delimiter=${2:-/};
#  # use <() process-substitution
#  # don't use <<< "" its add newline
  local arr
  readarray -t arr < <(printf '%s' "${str//$delimiter/$'\n'}")
  printf '%s\n' "${arr[@]}"
}
# Usage: bake.str.revertLines <<< "$(echo -e "a\nb\nc")"  => "c\nb\na"
function bake.str.revertLines(){
  sed '1!G;h;$!d'  # sed magic
}

# Usage: bake.path.dirname <str> [delimiter:default /]
# similar command dirname, but
#     dirname root is ".", only work with "/"
#     bake.path.dirname root is "" , can set delimiter
# bake.path.dirname a.b.c .    => a.b
bake.path.dirname(){
  local pathLikeStr="$1" delimiter="${2:-/}"
  if [[ "$pathLikeStr" != *"$delimiter"* ]]; then printf '' ; return ; fi
  printf '%s' "${pathLikeStr%$delimiter*}"
}
# Usage: bake.path.first <str> [delimiter:default /]
# bake.path.first a.b.c .    => a
bake.path.first(){
  local pathLikeStr="$1" delimiter="${2:-/}"
  # if /a/b/c , call :bake.path.first a/b/c /
  if [[ "$pathLikeStr" == "$delimiter"* ]] ; then
    local removeDelim; removeDelim=$(bake.str.cutLeft "$pathLikeStr" "$delimiter")
    printf "$delimiter$(bake.path.first "$removeDelim" "$delimiter" )"
  else # a/b/c
    printf "${pathLikeStr%%$delimiter*}"
  fi
}
# similar command basename
# Usage: bake.path.basename <str> [delimiter:default /]
bake.path.basename(){
  local pathLikeStr="$1" delimiter="${2:-/}"
  # ${1##*/}  => ## left remove until last "/"
  printf "${pathLikeStr##*$delimiter}";
}

# Usage: bake.data.children <dataPath>
#   return <dataPath> children name
bake.data.children() {
  path="$1"
  # ${!_data[@]}: get all array keys
  for key in "${!_data[@]}"; do
    # if start $path
    if [[ "$key" == "$path"* ]]; then
      # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
      # remove prefix : key:build/opts/dir/type/x leftPathToBeCut:build/opts => dir/type/x
      child=$(bake.str.cutLeft "$key" "$path/")
      # remove suffix:  dir/type/x => dir
#      child=${child%%/*}
      child=$(bake.path.first "$child" "/")
      printf '%s\n' "$child"
    fi
  done | sort -u
}

bake.cmd.childrenNameMaxLength() {
  local cmd="$1" maxLengthOfCmd=0
  for  child in $(bake.cmd.children "$cmd") ; do
    if ((${#child} > maxLengthOfCmd)); then maxLengthOfCmd=${#child}; fi
  done
  printf "$maxLengthOfCmd"
}
bake.cmd.children() (
  path="$1"
  if [[ "$path" == _root ]]; then
    path=""
  fi

  # ${!_data[@]}: get all array keys
  for key in "${!_cmdTree[@]}"; do
    # if start $path
    if [[ "$key" == "$path"* && "$key" != "$path" && "$key" != "_root" ]]; then
      # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
      # remove prefix : key:a.b.c leftPathToBeCut:a => b.c
      child=$(bake.str.cutLeft "$key" "$path.")
      # remove suffix:  b.c => c
      child=$(bake.path.first "$child" ".")
      printf '%s\n' "$child"
    fi
  done | sort -u
)

# Usage: bake.cmd.list_up <cmd>
# sample: bake.cmd.list_up a.b      => "a.b\n", "a\n", "_root"
function bake.cmd.list_up(){
  local path="${1:-_root}"
  local up="$path"
  while [[ "$up" != "" ]]; do
    printf '%s\n' "$up"
    up=$(bake.path.dirname "$up" ".")
  done
  if [[ "$path" != "_root" ]]; then printf "_root\n"; fi
}
# Usage: bake.cmd.list_down <cmd>
# reverse of bake.cmd.list_up
function bake.cmd.list_down(){
  bake.cmd.list_up "$1" | bake.str.revertLines ;
#  bake.cmd.list_up "$1" | tail -r; # macos bsd only, not work on linux
}


# Usage: bake.opt.list <cmd>
# return optionDataPath list
function bake.opt.list(){
  local cmd=$1
  local upCmds;
  readarray -t upCmds <<< "$(bake.cmd.list_up "$cmd")"

  local key
  for key in "${!_data[@]}"; do
    if [[ "${_data[$key]}" != "type:opt" ]]; then continue ; fi
    local upCmd
    for upCmd in "${upCmds[@]}"; do
      if [[ "$key" == "$upCmd/opts/"* ]]; then
        printf '%s\n' "$key"
      fi
    done
  done | sort
}

# only use by bake.opt.add,
# because "bake.opt.add" is meta function, use this func to add self
bake.opt._internal_add(){
  local cmd="$1" opt="$2" type="$3" required="$4" abbr="$5" help="$6"
  _data[$cmd/opts/$opt]="type:opt"
  _data[$cmd/opts/$opt/name]="$opt"
  _data[$cmd/opts/$opt/type]="$type"
  _data[$cmd/opts/$opt/required]="$required"
  _data[$cmd/opts/$opt/abbr]="$abbr"
  _data[$cmd/opts/$opt/optHelp]="$optHelp"
}
bake.opt._internal_add bake.opt.add "cmd" "string" "true" "" "cmd name"
bake.opt._internal_add bake.opt.add "name" "string" "true" "" "option name"
bake.opt._internal_add bake.opt.add "type" "string" "true" "" "option type"
bake.opt._internal_add bake.opt.add "required" "bool" "false" "" "option required"
bake.opt._internal_add bake.opt.add "abbr" "string" "false" "" "option abbr"
# avoid use 'help' as  option name,because it is root command option
bake.opt._internal_add bake.opt.add "optHelp" "string" "false" "" "option help"
bake.opt.add(){
  local selfCmd="${FUNCNAME[0]}"
  eval "$(bake.opt.parse "$selfCmd" "$@")"
#  bake.opt.parse "$selfCmd" "$@" > /dev/null
#  local name; name="$(bake.opt.value "$selfCmd" "name")"
#  local cmd; cmd="$(bake.opt.value "$selfCmd" "cmd")"
#  local type; type="$(bake.opt.value "$selfCmd" "type")"
#  local abbr; abbr="$(bake.opt.value "$selfCmd" "abbr")"
#  local optHelp; optHelp="$(bake.opt.value "$selfCmd" "optHelp")"
  if [[ "$name" == "" ]] ;then
    echo "error: option [--name] required " >&2 && return 1 ;
  fi
  if [[ "$type" == "" ]] ;then
    echo "error: option [--type] required " >&2  && return 1 ;
  fi
  if [[ "$type" != "bool" && "$type" != "string" && "$type" != "list"  ]] ;then
    echo "error: option [--type] must in [bool|string|list] " >&2  && return 1 ;
  fi
#  bake.opt._internal_add "cmd" "string" "true" "" "cmd name"
  bake.opt._internal_add "$cmd" "$name" "$type" "$required" "$abbr" "$optHelp"
}


# only use by bake.opt.add,
function bake.opt.value(){
  local cmd="$1" opt="$2"
  printf '%s' "${_data["$cmd/opts/$opt/value"]}"
}
# Usage: bake.opt.parse <cmd:default _root> [arg1] [arg2] ...
function bake.opt.parse() {
    local cmd; cmd="${1:_root}"
    shift
    local optCount; optCount=0
    local result;
    # while bake.opt.list
    local optList
    # sort: root option first , priority low -> priority high: _root>pub>pub.get
    readarray -t optList < <(bake.opt.list "$cmd" | bake.str.revertLines )
    # convert to associative arrays , use to check if a opt is in optMap
    declare -A optMap;
    declare -A optNameMap;
    for optPath in "${optList[@]}"; do
      local opt ; opt=$(bake.path.basename "$optPath")
      local abbr ; abbr=${_data["$optPath/abbr"]}
      optMap["--$opt"]="${optPath}"
      if [[ "$abbr" != "" ]] ; then optMap["-$abbr"]="${optPath}" ; fi
      optNameMap["$optPath"]="$opt"
    done

    # while all args , until it is not opt
    while (( $# > 0 )); do
      # find $1 arg in optMap, guess $1 is a "-h" "-help" ...
      local optPath; optPath=${optMap[$1]}
      # if next arg not a opt , parsing complete;
      if [[ "$optPath" == "" ]] ; then break;  fi
      # "${pathLikeStr##*$delimiter}"
#      local opt; opt=$(bake.path.basename "$optPath")
      local opt; opt=${optNameMap["$optPath"]}
#      echo "opt:$optPath   -   ${optNameMap["$optPath"]}" >&2
      # remove the prefix：build.@fields.opts.base_uri => base_uri
      local optType; optType=${_data["$optPath/type"]}

      case $optType in
        bool)   _data[$optPath/value]=true;
                optCount=$((optCount+1)) ;
                result+="local $opt=true;\n"
                shift;;
        string) [[ "$2" == "" ]] && echo "error: opt need a value: --$opt <value> " >&2 && return 1 ;
                local optValue; optValue="$(printf '%q' "$2")";
                _data[$optPath/value]="$optValue";
                optCount=$((optCount+1))
                result+="local $opt=$optValue;\n"
                shift 2 ;;
        list)   [[ "$2" == "" ]] && echo "error: option $arg need a value arg: $arg <value> " >&2 && return 1 ;
                local optValue; optValue="$2";
                local length; length=${_cmdTree[$optPath/value]};
                if [[  "$length" == "" ]] ;then
                  length=1
                  result+="local $opt;\n"
                else
                  length=$((length+1))
                fi
                local index ; index=$((length-1))
                _data[$optPath/value]="$length";
                _data[$optPath/value/$index]="$optValue";
                arr+=("$value")
                result+="${option}+=($(printf '%q',"$optValue"));\n"
                shift 2 ;;
        *) echo "parse error: not support $cmd.opts.$opt.type: <$optType> " >&2 ; return 1 ;;
      esac
    done
    result+="local optCount=$optCount;\n"
    echo -e "$result" # -e show raw string
}
bake.opt.add --cmd bake.cmd.set --name "cmd"         --type string --optHelp "cmd, function name"
bake.opt.add --cmd bake.cmd.set --name "usage"       --type string --optHelp "usage"
bake.opt.add --cmd bake.cmd.set --name "summary"     --type string --optHelp "summary help, short, show on cmd list"
bake.opt.add --cmd bake.cmd.set --name "description" --type string --optHelp "description, long help ,show on cmd help page"

function bake.cmd.set(){
  # 模版代码，放到每个需要使用option的函数中，然后就可以使用option了
  eval "$(bake.opt.parse "${FUNCNAME[0]}" "$@")"
  if [[ "$cmd" == "" ]]; then
    echo "error: bake.cmd.set [--cmd] required " >&2 && return 1 ;
  fi
#  bake.opt.parse "${FUNCNAME[0]}" "$@" >&2
  _data[$cmd/usage]="$usage"
  _data[$cmd/summary]="$summary"
  _data[$cmd/description]="$description"
}

# Usage: bake.cmd.register
# ensure all cmd register
function bake.cmd.register() {
     local functionName
     while IFS=$'\n' read -r functionName ; do
      if [[ "$functionName" == */*  ]]; then
        echo "error: function $functionName() can not contains '/' " >&2 && return 1
      fi
      local traverseUpPath
      for traverseUpPath in $(bake.cmd.list_up "$functionName");do
        _cmdTree["$traverseUpPath"]="PARENT_CMD_NOT_FUNC"
      done
      _cmdTree[$functionName]=$functionName

      # list all function name
      # declare -F | awk {'print $3'} == compgen -A function
      # declare -f func1  -> func1
      # declare -fx func2 -> func2
    done <<< "$(compgen -A function)"
}

function bake.help()(
  cmd="$1"
  local selfCmd="${FUNCNAME[0]}"
  eval "$(bake.opt.parse "$selfCmd" "$@")"

  local usage; usage="${_data[${cmd}/usage]}"
  if [[ "$usage" != "" ]]; then
    echo -e "\nUsage($cmd):  $usage \n"
  fi

  if [[ "${_data[${cmd}/description]}" != "" ]]; then
     echo "${_data[${cmd}/description]}"
  else
     echo "${_data[${cmd}/summary]}"
  fi

  echo "

Available Options:"
  for optPath in $(bake.opt.list "$cmd"); do
    local opt; opt=$(bake.path.basename "$optPath")
    local optName; optName=${_data[$optPath/name]}
    local optType; optType=${_data[$optPath/type]}
    local optAbbr; optAbbr=${_data[$optPath/abbr]}
    local optHelp; optHelp="${_data[$optPath/optHelp]}"
    printf " --%-15s -%-5s %-10s %b\n" "$optName" "$optAbbr" "$optType" "$optHelp"
  done


  echo "
Available Commands:"
  local maxLengthOfCmd; maxLengthOfCmd="$(bake.cmd.childrenNameMaxLength "$cmd")"
  for subcmdName in $(bake.cmd.children "$cmd"); do

    # only show public cmd if not verbose
    if [[ "$verbose" == "" && ("$subcmdName" == _* || "$subcmdName" == bake*) ]]; then
       continue
    fi

    local subCmd
    if [[ "$cmd" == "_root" ]] ; then
      subCmd="$subcmdName"
    else
      subCmd="$cmd/$subcmdName"
    fi

    # 第二行开始，都补空格
    local summary usage
    summary="${_data[$subCmd/summary]:--}"
    usage="${_data[$subCmd/usage]}"
    [[ "$usage" != "" ]] &&  summary+="\nUsage: $usage"
    summary="$(echo -e "$summary")" #  backslash escapes interpretation

    local padding; padding=$(printf %-$((maxLengthOfCmd + 6))b "")
    summary=$(sed "2,1000s/^/$padding/g" <<<"$summary" )

    printf "  %-$((maxLengthOfCmd))s    ${summary}\n" "${subcmdName}"
  done
)

# _root is special cmd, it is root of all cmd
bake.opt.add --cmd _root --name "help"    --abbr h --type bool --optHelp "print help, show all commands"
bake.opt.add --cmd _root --name "verbose" --abbr v --type bool --optHelp "verbose, show more info, more hidden commands"
function bake.run() {
    # init
    bake.cmd.register
    # parse cmd :
    #   ./bake pub get -v -b
    #     -> { cmd:"pub.get", args:"-v -b" }
    #   ./bake -h
    #     -> { cmd:"", args:"-h" }
    local cmd nextCmd  arg;
    for arg in "$@"; do
      nextCmd="$( [[ "$cmd" == "" ]] && echo "$arg" || echo "$cmd.$arg" )"
      if  [[ "${_cmdTree[$nextCmd]}" == "" ]] ; then  break; fi
      cmd="$nextCmd" ;
      shift ;
    done

    if [[ "$cmd" == "" ]] ; then cmd="_root" ; fi

    eval "$(bake.opt.parse "$cmd" "$@")"

    if [[ "$help" == "true" ]] ; then bake.help "$cmd" ; return 0;  fi

#    # parse opts
    if ! declare -f "$cmd" >/dev/null 2>&1; then
      if [[ "${_cmdTree[$cmd]}" == "PARENT_CMD_NOT_FUNC" ]] ; then bake.help "$cmd" ; return 0; fi
      _error "Error: 404 ,cmd '${cmd}' not define, please define cmd function '${cmd}()'"
      return 1
    fi

    # run cmd chain from _root:
    # ./bake2 pub get   => run _root() -> pub() -> pub.get()
    for upCmd in $(bake.cmd.list_down "$cmd"  ); do
      if  [[ "${_cmdTree[$upCmd]}" == "PARENT_CMD_NOT_FUNC" ]]; then continue ; fi
      $upCmd "$@"
    done
}

##########################################
# app script
# 应用项目补充的公共脚本，不在bake维护范围
##########################################
# print first, then _run
_run() {
  local project; project=$(basename "$PWD")
  [[ "$PWD" == "$BAKE_DIR" ]] && project="_root"
  _log "【${project}】▶︎${FUNCNAME[1]} ▶︎ $*"
  "$@"
  return $?
}


##########################################
# app cmd script
# 应用的命令脚本
##########################################
bake.cmd.set --cmd all --summary "<mono>  run cmd on all mono project"\
  --usage "Usage: ./$BAKE_FILE all [any command]"

all() {
    #       目录中有"pubspec.yaml"的，认为是flutter项目
    #        for project in $( find . -name pubspec.yaml | sed s/pubspec.yaml$//g ) ; do
    #          # 用括号()开启子进程执行，可以不影响当前进程的环境
    #          ( cd "$project" ;  run "$@" ; )
    #        done
    (cd packages/learn_dart;        _run "$@";  )
    (cd packages/note;              _run "$@";  )
    (cd packages/note_mate_flutter; _run "$@";  )
    (cd packages/note_mate;         _run "$@";  )
    (cd packages/note_app;          _run "$@";  )
    (cd packages/note_test;         _run "$@";  )
}

bake.cmd.set --cmd note              --usage "./$BAKE_FILE note [any command]" --summary "<project> run cmd on project"
bake.cmd.set --cmd note_app          --usage "./$BAKE_FILE note_app [any command]"
bake.cmd.set --cmd note_mate         --usage "./$BAKE_FILE note_mate [any command]"
bake.cmd.set --cmd note_mate_flutter --usage "./$BAKE_FILE note_mate_flutter [any command]"
bake.cmd.set --cmd note_test         --usage "./$BAKE_FILE note_test [any command]"
note() (              cd packages/note;                  _run "$@";  )
note_app() (          cd packages/note_app;              _run "$@";  )
note_mate() (         cd packages/note_mate;             _run "$@";  )
note_mate_flutter() ( cd packages/note_mate_flutter;     _run "$@";  )
note_test() (         cd packages/note_test;             _run "$@";  )


bake.cmd.set --cmd dep --usage "./$BAKE_FILE pub" --summary "<shortcut> ./bake all flutter pub get"
dep(){
  _run all flutter pub get
}

####################################################
# app entry script & _root cmd
# _root cmd is no function ,all it is this file
####################################################
# cmd settings use bash associative array

bake.cmd.set --cmd _root \
  --usage "./$BAKE_FILE [cmd] [opts] [args...]" \
  --summary "bake is a bash script tool to build project, manage dependencies, and run commands." \
  --description "$(cat <<- EOF
____ _    _  _ ___ ___ ____ ____    _  _ ____ ___ ____
|___ |    |  |  |   |  |___ |__/ __ |\ | |  |  |  |___
|    |___ |__|  |   |  |___ |  \    | \| |__|  |  |___

bake is a bash script tool to build project, manage dependencies, and run commands.

Samples:
 ./${BAKE_FILE} -h                       # show all commands help
 ./${BAKE_FILE} -h -v                    # show all commands help , include internal commands
 ./${BAKE_FILE} all  flutter pub get     # run "flutter pub get" on all mono projects
 ./${BAKE_FILE} note flutter pub get     # run "flutter pub get" on note project

EOF
)"

# lib_mode use for other script import
if [[ "$1" == "--lib_mode"  ]]; then
  echo "lib_mode import: $BAKE_PATH"
else
  bake.run "$@"
fi
