#!/usr/bin/env bash
set -o errtrace # trap inherited in sub script
set -o errexit
set -o functrace # If set, any trap on DEBUG and RETURN are inherited by shell functions

# bake == (bash)ake == 去make的bash工具
# v0.2.20230515 目前仅在macos上跑过
# ------------------------------------------------------------------------------
# bake 是个简单的自建命令工具，以替代Makefile的子命令功能
# make工具的主要特点是处理文件依赖进行增量编译，但flutter、golang、java、js项目的build工具
# 太厉害了，这几年唯一还在用Makefile的理由就是他的子命令机制: "make build"、
# "make run", 可以方便的自定义单一入口的父子命令，但Makefile本身的语法套路也很复杂，
# 很多批处理还是要靠bash, 这就尴尬了，工具太多，麻烦！本脚本尝试彻底摆脱使用Makefile。
# 经尝试，代码很少啊 ，核心公共代码百十行啊，还主要是提取显示子命令帮助的，功能足够了：
#   ./bake       # 列子命令看帮助，
#   ./bake build # 子命令
#   ./bake run   # 子命令
# bake命令规则：
# 1. 定义以斜杠"/"为前缀的function作为子命令，/build、/run、/assets/list、
#    表示命令的其父子关系，执行时去掉斜杠/, 构成父子命令：./bake assets list -x -y -z
# 2. 除bash外，尽量不依赖其他工具，包括linux coreutils,以便跨平台更简单
# 搞docker那样的命令树，应该也不难，目前和make一样只支持一级子命令，暂时够用。
# ref
# https://pub.dev/documentation/args/latest/args/ArgParser-class.html
# https://github.com/spf13/pflag/blob/master/string_array.go
# https://oclif.io/docs/flags
# ------------------------------------------------------------------------------

if ((BASH_VERSINFO[0] < 4)); then
  echo "Error: 都2082年了，您的bash还是这个版本(BASH_VERSINFO: ${BASH_VERSINFO[*]})，请安装bash 4+ 后重启terminal:
  apt install bash  # ubuntu
  brew install bash # mac"
  exit 1
fi

# copy from flutter
# ----------------------
# On Mac OS, readlink -f doesn't work, so bake.readlink traverses the path one
# link at a time, and then cds into the link destination and find out where it
# ends up.
# The function is enclosed in a subshell to avoid changing the working directory
# of the caller.
function _readlink() (
  cd -P "$(dirname -- "$1")"
  file="$PWD/$(basename -- "$1")"
  while [[ -L "$file" ]]; do
    cd -P "$(dirname -- "$file")"
    file="$(readlink -- "$file")"
    cd -P "$(dirname -- "$file")"
    file="$PWD/$(basename -- "$file")"
  done
  echo "$file"
)

_on_error() {
  echo "trapped an error: ↑ , trace: ↓" >&2
  _stack_frame
}
# Usage: _stack_frame
_stack_frame() {
  local i=0
  local stackInfo
  while true; do
    stackInfo=$(caller $i 2>&1 && true) && true
    if [[ $? != 0 ]]; then break; fi

    # parse
    # 97 test_bake.split ./test/bake2_test.bash
    local no func file;
    IFS=' ' read -r no func file <<< "$stackInfo"

    # clickable stack:
    # /Users/c/git/younpc/note/test/bake2_test.bash:38 bake.test.runTest()
    printf "%s\n" "$(_readlink $file):$no $func()" >&2

    i=$((i + 1))
  done
}
# Add the error catch first
#
trap " set +x; _on_error " ERR

##########################################
# bake common script
##########################################
BAKE_PATH="$(_readlink "${BASH_SOURCE[0]}")"
BAKE_DIR="$(dirname "$BAKE_PATH")"
BAKE_FILE="$(basename "$BAKE_PATH")"

# set workdir
cd "${BAKE_DIR}"

# Simulating object-oriented data structures with flat associative arrays
# opts define:
#  _cmdTree[@fields.summary]="bake root cmd"
#  _cmdTree[@fields.help]="bake root cmd"
#  _cmdTree[pub]="type:cmd"
#  _cmdTree[pub.@fields.summary]="flutter pub"
#  _cmdTree[pub.@fields.opts.notes]="type:option"
#  _cmdTree[pub.@fields.opts.notes.type]="list"
#  _cmdTree[pub.@fields.opts.notes.abbr]="n"
#  _cmdTree[pub.get]="type:cmd"
#  _cmdTree[pub.get.@fields.summary]="flutter pub get"
#  _cmdTree[pub.get.@fields.opts.verbose]="type:option"
#  _cmdTree[pub.get.@fields.opts.verbose.type]="bool"
#  _cmdTree[pub.get.@fields.opts.verbose.abbr]="v"
# parsed opts value:
#  _cmdTree[@fields.opts.verbose.value]=true
#  _cmdTree[pub.get.@fields.opts.notes.value.0]="..lib/note.page"
#  _cmdTree[pub.get.@fields.opts.notes.value.1]="./lib/a/note.page"
# app script dont use this variable directly, use function access

#  _cmdTree[summary]="bake root cmd"
#  _cmdTree[help]="bake root cmd"
#  _cmdTree[kids.pub]="type:cmd"
#  _cmdTree[kids.pub.summary]="flutter pub"
#  _cmdTree[kids.pub.opts.notes]="type:option"
#  _cmdTree[kids.pub.opts.notes.type]="list"
#  _cmdTree[kids.pub.opts.notes.abbr]="n"
#  _cmdTree[kids.pub.kids.get]="type:cmd"
#  _cmdTree[kids.pub.kids.get.summary]="flutter pub get"
#  _cmdTree[kids.pub.kids.get.opts.verbose]="type:option"
#  _cmdTree[kids.pub.kids.get.opts.verbose.type]="bool"
#  _cmdTree[kids.pub.kids.get.opts.verbose.abbr]="v"
# parsed opts value:
#  _cmdTree[opts.verbose.value]=true
#  _cmdTree[kids.pub.kids.get.opts.notes.value.0]="..lib/note.page"
#  _cmdTree[kids.pub.kids.get.opts.notes.value.1]="./lib/a/note.page"

#  _cmdTree[root/summary]="bake root cmd"
#  _cmdTree[root/help]="bake root cmd"
#  _cmdTree[pub]="type:cmd"
#  _cmdTree[pub/summary]="flutter pub"
#  _cmdTree[pub/opts/notes]="type:option"
#  _cmdTree[pub/opts/notes/type]="list"
#  _cmdTree[pub/opts/notes/abbr]="n"
#  _cmdTree[pub.get]="type:cmd"
#  _cmdTree[pub.get/summary]="flutter pub get"
#  _cmdTree[pub.get/opts/verbose]="type:option"
#  _cmdTree[pub.get/opts/verbose/type]="bool"
#  _cmdTree[pub.get/opts/verbose/abbr]="v"
# parsed opts value:
#  _cmdTree[root/opts/verbose/value]=true
#  _cmdTree[pub.get/opts/notes/value/0]="..lib/note.page"
#  _cmdTree[pub.get/opts/notes/value/1]="./lib/a/note.page"

# only save all commands, we use it to build command tree
# it is cache data from _data
declare -A _cmdTree

# save all other data
declare -A _data

TYPE_CMD="type:cmd"

##########################################
# bake common function
##########################################
# Usage: bake.data.children <dataPath>
#   return <dataPath> children name
bake.data.children() (
  path="$1"
  # ${!_data[@]}: get all array keys
  for key in "${!_data[@]}"; do
    # if start $path
    if [[ "$key" == "$path"* ]]; then
      # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
      # remove prefix : path:build/opts  key:build/opts/dir/type => dir/type
      child=${key#$path/}
      # remove suffix:  dir/type => dir
      child=${child%%/*}
      printf '%s\n' "$child"
    fi
  done | sort -u
)

function bake.cmd.list()(
  contextCmd=$1
  doctor
#  showList=()
#  maxLengthOfCmd=0
  for child in $(bake.data.children "$contextCmd"); do
    [[ "$contextCmd" == "" ]] && key="$child" || key="$contextCmd/$child"
    if   [[ "$key"              == bake*      ]]; then continue; fi
    if   [[ "$key"              == @fields*   ]]; then continue; fi
    if   [[ "$key"              == _*         ]]; then continue; fi
    if   [[ "${_cmdTree[$key]}" != "type:cmd" ]]; then continue; fi
    echo "$key : ${_cmdTree[$key.@fields.summary]}"
  done
)

# Usage: bake.cmd.register
# ensure all cmd register
function bake.cmd.register() {
     local functionName
     while IFS=$'\n' read -r functionName ; do
      if [[ "$functionName" == */*  ]]; then
        echo "error: function $functionName() can not contains '/' " >&2 && return 1
      fi
      local traverseUpPath
      for traverseUpPath in $(bake.path_traverse_up "$functionName" ".");do
        local key; key=$([[ "$traverseUpPath" == / ]] && echo "/" || echo "$traverseUpPath" )
        _cmdTree["$traverseUpPath"]=""
      done
      _cmdTree[$functionName]=$functionName

      # list all function name
      # declare -F | awk {'print $3'} == compgen -A function
      # declare -f func1  -> func1
      # declare -fx func2 -> func2
    done <<< "$(compgen -A function)"
}

# Usage: bake.path_traverse_up <str> <delimiter:"/">
# sample:
#   bake.path_traverse_up a.b "."    => "a.b", "a", ""
function bake.path_traverse_up()(
  local path=$1 delimiter=${2:-/}

  current="${path}"
  while [ "$current" != "" ]
  do
    printf '%s\n' "$current"
    removed=${current%$delimiter*}
    if [[ "$removed" == "$current" ]] ; then  break; fi
    current="$removed"
  done
  # last is root
  printf '\n'
)

# Usage: split <str> [delimiter:default \n]
bake.split() {
  local str=$1 delimiter=${2:-.};
#  # use <() process-substitution
#  # don't use <<< "" its add newline
  local arr
  readarray -t arr < <(printf '%s' "${str//$delimiter/$'\n'}")
  printf '%s\n' "${arr[@]}"
}

# Usage: bake.opt.match <cmd> <arg>
# match a <arg> is a option return optionDataPath else return ""
# Sample: bake.opt.match "build" "--dir" someDir
#      => "build.opts.dir"
function bake.opt.match()(
  local cmd=$1 arg=$2
  for traverseUpCmd in $(bake.path_traverse_up "$cmd" ".") ; do
    local opt;
    for opt in $(bake.data.children "$traverseUpCmd/opts"); do
       local abbr; abbr=${_data["$traverseUpCmd/opts/$opt/abbr"]}
       if [[ "--$opt" == "$arg" || ("$abbr" != "" && "-$abbr" == "$arg") ]] ; then
         printf '%s' "$opt"  ;
       fi
    done
  done
  printf ''
)

# because this func is meta function, so can not use option to add self
_data[bake.opt.add/opts/cmd/type]=string

_data[bake.opt.add/opts/name/type]=string
_data[bake.opt.add/opts/name/required]=true

_data[bake.opt.add/opts/type/type]=string

_data[bake.opt.add/opts/abbr/type]=string

_data[bake.opt.add/opts/help/type]=string
# bake.opt.add --cmd root --name "help" --type bool --help "print help, show all commands"
bake.opt.add(){
  # 模版代码，放到每个需要使用option的函数中，然后就可以使用option了
  eval "$(bake.opt.parse "${FUNCNAME[0]}" "$@")"
  if [[ "$name" == "" ]] ;then
    echo "error: option [--name] required " >&2 && return 1 ;
  fi
  if [[ "$type" == "" ]] ;then
    echo "error: option [--type] required " >&2  && return 1 ;
  fi
  if [[ "$type" != "bool" && "$type" != "string" && "$type" != "list"  ]] ;then
    echo "error: option [--type] must in [bool|string|list] " >&2  && return 1 ;
  fi
#  _data[$cmd/opts/$name/type]="$type"
#  _data[$cmd/opts/$name/abbr]="$abbr"
#  _data[$cmd/opts/$name/help]="$help"
}

# Usage: bake.opt.parse <cmd> [arg1] [arg2] ...
function bake.opt.parse() {
    local cmd; cmd="$1"
    shift
    local optCount; optCount=0
    local result;

    # parse opts
    while (( $# > 0 )); do
      local opt; opt=$(bake.opt.match "$cmd" "$1")
      # if arg not a opt , parsing complete;
      if [[ "$opt" == "" ]] ; then break;  fi
      # remove the prefix：build.@fields.opts.base_uri => base_uri
      local optType; optType=${_data["$cmd/opts/$opt/type"]}

      case $optType in
        bool)   _data[$cmd/opts/$opt/value]=true;
                optCount=$((optCount+1)) ;
                result+="local $opt=true;\n"
                shift;;
        string) [[ "$2" == "" ]] && echo "error: opt need a value: --$opt <value> " >&2 && return 1 ;
                local optValue; optValue=$(printf '%q' "$2");
                _data[$cmd/opts/$opt/value]="$optValue";
                optCount=$((optCount+1))
                result+="local $opt=$optValue;\n"
                shift 2 ;;
        list)   [[ "$2" == "" ]] && echo "error: option $arg need a value arg: $arg <value> " >&2 && return 1 ;
                local optValue; optValue="$2";
                local length; length=${_cmdTree[$cmd/opts/$opt.value]};
                if [[  "$length" == "" ]] ;then
                  length=1
                  result+="local $opt;\n"
                else
                  length=$((length+1))
                fi
                local index ; index=$((length-1))
                _cmdTree[$cmd.@fields.opts.$opt.value]="$length";
                _cmdTree[$cmd.@fields.opts.$opt.value.$index]="$optValue";
                arr+=("$value")
                result+="${option}+=($(printf '%q',"$optValue"));\n"
#                result+="${option}[$index]=$(printf '%q',"$optValue");\n"
                shift 2 ;;
        *) echo "error: not support cmd.$cmd.opts.$opt.type: <$optType> " >&2 ; return 1 ;;
      esac
    done
    result+="local optCount=$optCount;\n"
#    printf '%s' "$result"
    echo -e "$result"
}
function bake.help()(
  cmd="$1"
  echo bake.help $cmd
)

bake.opt.add --cmd bake.main --name "help"    --abbr h --type bool --help "print help, show all commands"
bake.opt.add --cmd bake.main --name "verbose" --abbr v --type bool --help "verbose run all commands"

function bake.main() {
    bake.cmd.register
    # parse cmd :
    #   ./bake pub get -v -b
    #     -> { cmd:"pub.get", args:"-v -b" }
    #   ./bake -h
    #     -> { cmd:"", args:"-h" }
    local cmd nextCmd  arg;
    for arg in "$@"; do
      nextCmd=$( [[ "$cmd" == "" ]] && echo "$arg" || echo "$cmd.$arg" )
      [[  "${_cmdTree[$nextCmd]}" != "type:cmd" ]] && break;
      cmd="$nextCmd" ;
      shift ;
    done
    # "" is root cmd
    if [[ "$cmd" == "" ]] ; then bake.help "" ; return 0;  fi

    if ! declare -f "$cmd" >/dev/null 2>&1; then
      _error "Error: 404 ,cmd '${cmd}' not define, please define cmd function '${cmd}()'"
      return 1
    fi
    $cmd "$@"
}

##########################################
# app script
# 应用项目补充的公共脚本，不在bake维护范围
##########################################
# print first, then _run
_run() {
  local project; project=$(basename "$PWD")
  [[ "$PWD" == "$BAKE_DIR" ]] && project="root"
  _log "【${project}】▶︎${FUNCNAME[1]} ▶︎ $*"
  "$@"
  return $?
}

_error(){
  echo -e "ERROR -【▶︎${FUNCNAME[1]}】-︎ $*" >&2
}
_log(){
  echo -e "INFO  -【▶︎${FUNCNAME[1]}】-︎ $*" >&2
}

##########################################
# app cmd script
# 应用的命令脚本
##########################################

pub.get(){
  # 模版代码，放到每个需要使用option的函数中，然后就可以使用option了
  bake.opt.parse "${FUNCNAME[0]}" "$@"
  declare -p
#  _run echo "_run flutter pub [$*]  verbose: $(bake.opt "pub.get" verbose)"
#  shift "$(bake.opt.parse "$@" )"
#  _run echo "_run flutter pub [$*]  verbose: $(bake.opt "pub.get" verbose)"
#  doctor
}

function doctor()(
  echo '# doctor'
  echo '## _cmdTree'
  for key in "${!_cmdTree[@]}"; do
    echo "cmd  - $key=${_cmdTree[$key]:0:100}"
  done
  echo '## _data'
  for key in "${!_data[@]}"; do
    echo "data - $key=${_data[$key]:0:100}"
  done
)


####################################################
# app entry script & root cmd
# root cmd is no function ,all it is this file
####################################################
# cmd settings use bash associative array
_rootHelp="$(cat <<- EOF
____ _    _  _ ___ ___ ____ ____    _  _ ____ ___ ____
|___ |    |  |  |   |  |___ |__/ __ |\ | |  |  |  |___
|    |___ |__|  |   |  |___ |  \    | \| |__|  |  |___
Usage:
./${BAKE_FILE} [cmd] [opts] [args...]

  ./${BAKE_FILE}       # 列子命令看帮助，
  ./${BAKE_FILE} build # 子命令
  ./${BAKE_FILE} run   # 子命令
EOF
)"
#bake.opt.add --cmd root --name "help" --type bool --help "print help, show all commands"



# lib_mode use for other script import
if [[ "$1" == "--lib_mode"  ]]; then
  echo "lib_mode import: $BAKE_PATH"
else
  bake.main "$@"
fi
