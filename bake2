#!/usr/bin/env bash
set -o errtrace #trap inherited in sub script
set -o errexit
set -o functrace #trap inherited in function
# set -x

# bake == (bash)ake == 去make的bash工具
# v0.2.20230515
# ------------------------------------------------------------------------------
# bake 是个简单的自建命令工具，以替代Makefile的子命令功能
# make工具的主要特点是处理文件依赖进行增量编译，但flutter、golang、java、js项目的build工具
# 太厉害了，这几年唯一还在用Makefile的理由就是他的子命令机制: "make build"、
# "make run", 可以方便的自定义单一入口的父子命令，但Makefile本身的语法套路也很复杂，
# 很多批处理还是要靠bash, 这就尴尬了，工具太多，麻烦！本脚本尝试彻底摆脱使用Makefile。
# 经尝试，代码很少啊 ，核心公共代码百十行啊，还主要是提取显示子命令帮助的，功能足够了：
#   ./bake       # 列子命令看帮助，
#   ./bake build # 子命令
#   ./bake run   # 子命令
# bake命令规则：
# 1. 定义以斜杠"/"为前缀的function作为子命令，/build、/run、/assets/list、
#    表示命令的其父子关系，执行时去掉斜杠/, 构成父子命令：./bake assets list -x -y -z
# 2. 除bash外，尽量不依赖其他工具，包括linux coreutils,以便跨平台更简单
# 搞docker那样的命令树，应该也不难，目前和make一样只支持一级子命令，暂时够用。
# ref
# https://pub.dev/documentation/args/latest/args/ArgParser-class.html
# https://github.com/spf13/pflag/blob/master/string_array.go
# https://oclif.io/docs/flags
# ------------------------------------------------------------------------------

#if ((BASH_VERSINFO[0] < 4)); then
#  echo "Error: 都2082年了，您的bash还是这个版本(BASH_VERSINFO: ${BASH_VERSINFO[*]})，请安装bash 4+ 后重启terminal:
#  apt install bash  # ubuntu
#  brew install bash # mac"
#  exit 1
#fi

# copy from flutter
# ----------------------
# On Mac OS, readlink -f doesn't work, so bake.readlink traverses the path one
# link at a time, and then cds into the link destination and find out where it
# ends up.
# The function is enclosed in a subshell to avoid changing the working directory
# of the caller.
function bake.readlink() (
  cd -P "$(dirname -- "$1")"
  file="$PWD/$(basename -- "$1")"
  while [[ -L "$file" ]]; do
    cd -P "$(dirname -- "$file")"
    file="$(readlink -- "$file")"
    cd -P "$(dirname -- "$file")"
    file="$PWD/$(basename -- "$file")"
  done
  echo "$file"
)

##########################################
# bake common script
##########################################
declare BAKE_DIR
BAKE_PATH="$(bake.readlink "${BASH_SOURCE[0]}")"
BAKE_DIR="$(dirname "$BAKE_PATH")"
BAKE_FILE="$(basename "$BAKE_PATH")"

# set workdir
cd "${BAKE_DIR}"

# Simulating object-oriented data structures with flat associative arrays
# options define:
#  _data[cmd./.shortHelp]="bake root cmd"
#  _data[cmd./.help]="bake root cmd"
#  _data[cmd./pub.shortHelp]="flutter pub"
#  _data[cmd./pub.options.notes.type]="list"
#  _data[cmd./pub.options.notes.abbr]="n"
#  _data[cmd./pub/get.shortHelp]="flutter pub get"
#  _data[cmd./pub/get.options.verbose.abbr]="v"
# parsed options value:
#  _data[cmd./.options.verbose.value]=true
#  _data[cmd./pub/get.options.notes.value.0]="./lib/note.page"
#  _data[cmd./pub/get.options.notes.value.1]="./lib/a/note.page"
declare -A _data

##########################################
# bake common function
##########################################

bake.project.current(){
  local project; project=$(basename "$PWD")
  [[ "$PWD" == "$BAKE_DIR" ]] && project="root"
  printf '%s' "$project"
}

function bake.data.set() {
  local path; path=$1 ; local value; value=$2 ;
  _data[$path]="${value}"
}
function bake.data.get() (
  path=$1
  printf '%s' "${_data[$path]}"
)

# Usage: bake.data.children <dataPath>
#   return <dataPath> children name
bake.data.children() (
  path=$1

  for key in "${!_data[@]}"; do
    if [[ "$key" == $path.* ]]; then
      # https://www.gnu.org/software/bash/manual/html_node/Shell-Parameter-Expansion.html
      # prefix: remove the "cmds." prefix
      child=${key#$path.}
      # suffix: remove everything after the first dot
      child=${child%%.*}
      printf '%s\n' "$child"
    fi
  done | sort -u
)

# Usage: bake.cmd.register
# ensure all cmd register
function bake.cmd.register() {
    while IFS=$'\n' read -r func ; do
      # "declare -f /pub/get" cut prefix "declare -f " -> "/pub/get"
      cmd=${func#declare -f }
      # func start with "/" is cmd
     ! [[ "$cmd" =~ ^/.* ]] && continue
     ! [[ ${_data[cmd.$cmd.shortHelp]} == "" ]] && continue
     _data[cmd.$cmd.shortHelp]="-";
    done <<< "$(declare -F)"
}

# Usage: bake.option.match <cmd> <arg>
# match a <arg> is a option, if true return option else return ""
function bake.option.match()(
  cmd=$1; arg=$2
  for traverseUpCmd in $(bake.path_traverse_up "$cmd") ; do
    for option in $(bake.data.children "cmd.$traverseUpCmd.options"); do
       abbr=$(bake.data.get "cmd.$traverseUpCmd.options.$option.abbr")
       if [[ "--$option" == "$arg" || ("$abbr" != "" && "-$abbr" == "$arg") ]] ; then
         printf '%s' "cmd.$traverseUpCmd.options.$option"  ;
       fi
    done
  done
  printf ''
)
function bake.option()(
  printf '%s' "$(bake.data.get "cmd.$1.options.$2.value")"
)
function bake.option.parse() {
    local cmd; cmd=${FUNCNAME[1]}
    shift
    local argCount; argCount=0
    # parse options
    while (( $# > 0 )); do
      optionPath=$(bake.option.match "$cmd" "$1")

      # if arg not a option , parsing complete;
      if [[ "$optionPath" == "" ]] ; then break;  fi

      optionType=$(bake.data.get "$optionPath.type" )

      case $optionType in
        bool)   bake.data.set "cmd.$cmd.options.$option.value" true;
                argCount=$((argCount+1)) ;
                shift;;
        string) [[ "$2" == "" ]] && echo "error: option $arg need a value arg: $arg <string> " >&2 && exit 1 ;
                bake.data.set "cmd.$cmd.options.$option.value" $2
                argCount=$((argCount+1)) && shift 2 ;;
        list)   echo "todo." ;;
        *) echo "error: not support cmd.$cmd.options.$option.type: <$optionType> " >&2 ; exit 1 ;;
      esac
    done
    printf '%s' "$argCount"
}

# Usage: bake.path_traverse_up <cmd>
# sample: bake.path_traverse_up /a/b
#   /a/b
#   /a
#   /
function bake.path_traverse_up()(
  cmd=$1

  currentCmd="${cmd}"
  while [ "$currentCmd" != "" ]
  do
    printf '%s\n' "$currentCmd"
    removed=${currentCmd%/*}
    if [[ "$removed" == "$currentCmd" ]] ; then  break; fi
    currentCmd="$removed"
  done
  # 如果是"/" root cmd,上面的循环不会轮到它，补一个
  if [[ "$cmd" != "/" ]]; then
    printf '%s\n' "/"
  fi
)

# Usage: split <str> <delimiter>
bake.split() (
  str=$1; delimiter=$2;
  IFS="$delimiter"; declare -a list=("$str")
  printf '%s\n' "${list[@]}"
)

function bake.main() {
    bake.cmd.register

    # parse cmd :
    #   ./bake pub get -v -b
    #     -> { cmd:"/pub/get", args:"-v -b" }
    #   ./bake -h
    #     -> { cmd:"/", args:"-h" }
    local cmd=""
    for arg in "$@"; do
      if ! ( printf '%s\n' "${!_data[@]}" | grep "cmd.$cmd/$arg" ) > /dev/null ; then
        break;
      fi
      cmd="$cmd/$arg" ;
      shift ;
    done
    # if nothing cmd find then root cmd
    if [[ "$cmd" == "" ]] ; then cmd="/"; fi

    if ! declare -f "$cmd" >/dev/null 2>&1; then
      error "Error: 404 ,cmd '${cmd}' not exists, please define cmd function '${cmd}()'"
      exit 1
    fi
    $cmd "$@"
}

##########################################
# app script
# 应用项目补充的公共脚本，不在bake维护范围
##########################################
# print first, then run
run() {
  local project; project=$(basename "$PWD")
  [[ "$PWD" == "$BAKE_DIR" ]] && project="root"
  log "【${project}】▶︎${FUNCNAME[1]} ▶︎ $*"
  "$@"
  return $?
}

on_error() {
  echo "trapped an error: ↑ , trace: ↓" >&2
  stack_frame
}

stack_frame() {
  local i=0
  local stackInfo
  while true; do
    stackInfo=$(caller $i 2>&1 && true) && true
    if [[ $? != 0 ]]; then break; fi
    echo "  $stackInfo" >&2
    i=$((i + 1))
  done
}
error(){
  echo -e "ERROR -【$(bake.project.current) ▶︎${FUNCNAME[1]}】-︎ $*" >&2
}
log(){
  echo -e "INFO  -【$(bake.project.current) ▶︎${FUNCNAME[1]}】-︎ $*" >&2
}

##########################################
# app cmd script
# 应用的命令脚本
##########################################

# cmd settings use bash associative array
bake.data.set cmd."/".shortHelp            "[mono project] flutter pub get"
bake.data.set cmd."/".options.help.abbr    h
bake.data.set cmd."/".options.help.type    bool
bake.data.set cmd."/".help                 "$(cat <<- EOF
____ _    _  _ ___ ___ ____ ____    _  _ ____ ___ ____
|___ |    |  |  |   |  |___ |__/ __ |\ | |  |  |  |___
|    |___ |__|  |   |  |___ |  \    | \| |__|  |  |___
Usage:
./${BAKE_FILE} [cmd] [options] [args...]

  ./${BAKE_FILE}       # 列子命令看帮助，
  ./${BAKE_FILE} build # 子命令
  ./${BAKE_FILE} run   # 子命令
EOF
)"


bake.data.set cmd."/pub/get".shortHelp            "[mono project] flutter pub get"
bake.data.set cmd."/pub/get".help                 "[mono project] flutter pub get"
bake.data.set cmd."/pub/get".options.verbose.name verbose
bake.data.set cmd."/pub/get".options.verbose.abbr v
bake.data.set cmd."/pub/get".options.verbose.type bool
/pub/get(){
  run echo "run flutter pub [$*]  verbose: $(bake.option "/pub/get" verbose)"
  shift "$(bake.option.parse "$@" )"
  run echo "run flutter pub [$*]  verbose: $(bake.option "/pub/get" verbose)"
  /doctor
}
.(){
  echo x
}

.

function /doctor()(
  log "# doctor -----------------------------------"
  echo
  log "## list data"
  for key in "${!_data[@]}"; do
    log "$key=${_data[$key]:0:50}"
  done
  echo
  log "## list cmds"
  for cmd in $(bake.data.children cmd); do
    log "cmd: $cmd"
  done
  echo
)

##########################################
# bake common entry script
##########################################
trap " set +x; on_error " ERR

bake.main "$@"
#bake.path_traverse_up $1